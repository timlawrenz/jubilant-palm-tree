[
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 36,
    "raw_source": "def accept\n      @env['sinatra.accept'] ||= if @env.include?('HTTP_ACCEPT') && (@env['HTTP_ACCEPT'].to_s != '')\n                                   @env['HTTP_ACCEPT']\n                                     .to_s\n                                     .scan(HEADER_VALUE_WITH_PARAMS)\n                                     .map! { |e| AcceptEntry.new(e) }\n                                     .sort\n                                 else\n                                   [AcceptEntry.new('*/*')]\n                                 end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 48,
    "raw_source": "def accept?(type)\n      preferred_type(type).to_s.include?(type)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 52,
    "raw_source": "def preferred_type(*types)\n      return accept.first if types.empty?\n\n      types.flatten!\n      return types.first if accept.empty?\n\n      accept.detect do |accept_header|\n        type = types.detect { |t| MimeTypeEntry.new(t).accepts?(accept_header) }\n        return type if type\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 66,
    "raw_source": "def forwarded?\n      !forwarded_authority.nil?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 70,
    "raw_source": "def safe?\n      get? || head? || options? || trace?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 74,
    "raw_source": "def idempotent?\n      safe? || put? || delete? || link? || unlink?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 78,
    "raw_source": "def link?\n      request_method == 'LINK'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 82,
    "raw_source": "def unlink?\n      request_method == 'UNLINK'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 86,
    "raw_source": "def params\n      super\n    rescue Rack::Utils::ParameterTypeError, Rack::Utils::InvalidParameterError => e\n      raise BadRequest, \"Invalid query parameters: #{Rack::Utils.escape_html(e.message)}\"\n    rescue EOFError => e\n      raise BadRequest, \"Invalid multipart/form-data: #{Rack::Utils.escape_html(e.message)}\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 98,
    "raw_source": "def initialize(entry)\n        params = entry.scan(HEADER_PARAM).map! do |s|\n          key, value = s.strip.split('=', 2)\n          value = value[1..-2].gsub(/\\\\(.)/, '\\1') if value.start_with?('\"')\n          [key, value]\n        end\n\n        @entry  = entry\n        @type   = entry[/[^;]+/].delete(' ')\n        @params = params.to_h\n        @q      = @params.delete('q') { 1.0 }.to_f\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 111,
    "raw_source": "def <=>(other)\n        other.priority <=> priority\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 115,
    "raw_source": "def priority\n        # We sort in descending order; better matches should be higher.\n        [@q, -@type.count('*'), @params.size]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 120,
    "raw_source": "def to_str\n        @type\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 124,
    "raw_source": "def to_s(full = false)\n        full ? entry : to_str\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 128,
    "raw_source": "def respond_to?(*args)\n        super || to_str.respond_to?(*args)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 132,
    "raw_source": "def method_missing(*args, &block)\n        to_str.send(*args, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 140,
    "raw_source": "def initialize(entry)\n        params = entry.scan(HEADER_PARAM).map! do |s|\n          key, value = s.strip.split('=', 2)\n          value = value[1..-2].gsub(/\\\\(.)/, '\\1') if value.start_with?('\"')\n          [key, value]\n        end\n\n        @type   = entry[/[^;]+/].delete(' ')\n        @params = params.to_h\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 151,
    "raw_source": "def accepts?(entry)\n        File.fnmatch(entry, self) && matches_params?(entry.params)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 155,
    "raw_source": "def to_str\n        @type\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 159,
    "raw_source": "def matches_params?(params)\n        return true if @params.empty?\n\n        params.all? { |k, v| !@params.key?(k) || @params[k] == v }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 174,
    "raw_source": "def body=(value)\n      value = value.body while Rack::Response === value\n      @body = String === value ? [value.to_str] : value\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 179,
    "raw_source": "def each\n      block_given? ? super : enum_for(:each)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 183,
    "raw_source": "def finish\n      result = body\n\n      if drop_content_info?\n        headers.delete 'content-length'\n        headers.delete 'content-type'\n      end\n\n      if drop_body?\n        close\n        result = []\n      end\n\n      if calculate_content_length?\n        # if some other code has already set content-length, don't muck with it\n        # currently, this would be the static file-handler\n        headers['content-length'] = body.map(&:bytesize).reduce(0, :+).to_s\n      end\n\n      [status, headers, result]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 207,
    "raw_source": "def calculate_content_length?\n      headers['content-type'] && !headers['content-length'] && (Array === body)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 211,
    "raw_source": "def drop_content_info?\n      informational? || drop_body?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 215,
    "raw_source": "def drop_body?\n      DROP_BODY_RESPONSES.include?(status)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 226,
    "raw_source": "def call(env)\n      result = app.call(env)\n      callback = env['async.callback']\n      return result unless callback && async?(*result)\n\n      after_response { callback.call result }\n      setup_close(env, *result)\n      throw :async\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 238,
    "raw_source": "def setup_close(env, _status, _headers, body)\n      return unless body.respond_to?(:close) && env.include?('async.close')\n\n      env['async.close'].callback { body.close }\n      env['async.close'].errback { body.close }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 245,
    "raw_source": "def after_response(&block)\n      raise NotImplementedError, 'only supports EventMachine at the moment' unless defined? EventMachine\n\n      EventMachine.next_tick(&block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 251,
    "raw_source": "def async?(status, _headers, body)\n      return true if status == -1\n\n      body.respond_to?(:callback) && body.respond_to?(:errback)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 261,
    "raw_source": "def call(env)\n      env['sinatra.commonlogger'] ? @app.call(env) : super\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 267,
    "raw_source": "def call(env)\n        env['sinatra.commonlogger'] = true\n        call_without_check(env)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 278,
    "raw_source": "def http_status; 400 end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 282,
    "raw_source": "def http_status; 404 end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 288,
    "raw_source": "def status(value = nil)\n      response.status = Rack::Utils.status_code(value) if value\n      response.status\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 295,
    "raw_source": "def body(value = nil, &block)\n      if block_given?\n        def block.each; yield(call) end\n        response.body = block\n      elsif value\n        unless request.head? || value.is_a?(Rack::Files::BaseIterator) || value.is_a?(Stream)\n          headers.delete 'content-length'\n        end\n        response.body = value\n      else\n        response.body\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 297,
    "raw_source": "def block.each; yield(call) end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 310,
    "raw_source": "def redirect(uri, *args)\n      # SERVER_PROTOCOL is required in Rack 3, fall back to HTTP_VERSION\n      # for servers not updated for Rack 3 (like Puma 5)\n      http_version = env['SERVER_PROTOCOL'] || env['HTTP_VERSION']\n      if (http_version == 'HTTP/1.1') && (env['REQUEST_METHOD'] != 'GET')\n        status 303\n      else\n        status 302\n      end\n\n      # According to RFC 2616 section 14.30, \"the field value consists of a\n      # single absolute URI\"\n      response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?)\n      halt(*args)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 328,
    "raw_source": "def uri(addr = nil, absolute = true, add_script_name = true)\n      return addr if addr.to_s =~ /\\A[a-z][a-z0-9+.\\-]*:/i\n\n      uri = [host = String.new]\n      if absolute\n        host << \"http#{'s' if request.secure?}://\"\n        host << if request.forwarded? || (request.port != (request.secure? ? 443 : 80))\n                  request.host_with_port\n                else\n                  request.host\n                end\n      end\n      uri << request.script_name.to_s if add_script_name\n      uri << (addr || request.path_info).to_s\n      File.join uri\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 349,
    "raw_source": "def error(code, body = nil)\n      if code.respond_to? :to_str\n        body = code.to_str\n        code = 500\n      end\n      response.body = body unless body.nil?\n      halt code\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 359,
    "raw_source": "def not_found(body = nil)\n      error 404, body\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 364,
    "raw_source": "def headers(hash = nil)\n      response.headers.merge! hash if hash\n      response.headers\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 370,
    "raw_source": "def session\n      request.session\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 375,
    "raw_source": "def logger\n      request.logger\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 380,
    "raw_source": "def mime_type(type)\n      Base.mime_type(type)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 386,
    "raw_source": "def content_type(type = nil, params = {})\n      return response['content-type'] unless type\n\n      default = params.delete :default\n      mime_type = mime_type(type) || default\n      raise format('Unknown media type: %p', type) if mime_type.nil?\n\n      mime_type = mime_type.dup\n      unless params.include?(:charset) || settings.add_charset.all? { |p| !(p === mime_type) }\n        params[:charset] = params.delete('charset') || settings.default_encoding\n      end\n      params.delete :charset if mime_type.include? 'charset'\n      unless params.empty?\n        mime_type << ';'\n        mime_type << params.map do |key, val|\n          val = val.inspect if val.to_s =~ /[\";,]/\n          \"#{key}=#{val}\"\n        end.join(';')\n      end\n      response['content-type'] = mime_type\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 417,
    "raw_source": "def attachment(filename = nil, disposition = :attachment)\n      response['Content-Disposition'] = disposition.to_s.dup\n      return unless filename\n\n      params = format('; filename=\"%s\"', File.basename(filename).gsub(/[\"\\r\\n]/, MULTIPART_FORM_DATA_REPLACEMENT_TABLE))\n      response['Content-Disposition'] << params\n      ext = File.extname(filename)\n      content_type(ext) unless response['content-type'] || ext.empty?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 428,
    "raw_source": "def send_file(path, opts = {})\n      if opts[:type] || !response['content-type']\n        content_type opts[:type] || File.extname(path), default: 'application/octet-stream'\n      end\n\n      disposition = opts[:disposition]\n      filename    = opts[:filename]\n      disposition = :attachment if disposition.nil? && filename\n      filename    = path        if filename.nil?\n      attachment(filename, disposition) if disposition\n\n      last_modified opts[:last_modified] if opts[:last_modified]\n\n      file   = Rack::Files.new(File.dirname(settings.app_file))\n      result = file.serving(request, path)\n\n      result[1].each { |k, v| headers[k] ||= v }\n      headers['content-length'] = result[1]['content-length']\n      opts[:status] &&= Integer(opts[:status])\n      halt (opts[:status] || result[0]), result[2]\n    rescue Errno::ENOENT\n      not_found\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 461,
    "raw_source": "def self.schedule(*) yield end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 462,
    "raw_source": "def self.defer(*)    yield end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 464,
    "raw_source": "def initialize(scheduler = self.class, keep_open = false, &back)\n        @back = back.to_proc\n        @scheduler = scheduler\n        @keep_open = keep_open\n        @callbacks = []\n        @closed = false\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 472,
    "raw_source": "def close\n        return if closed?\n\n        @closed = true\n        @scheduler.schedule { @callbacks.each { |c| c.call } }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 479,
    "raw_source": "def each(&front)\n        @front = front\n        @scheduler.defer do\n          begin\n            @back.call(self)\n          rescue Exception => e\n            @scheduler.schedule { raise e }\n          ensure\n            close unless @keep_open\n          end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 492,
    "raw_source": "def <<(data)\n        @scheduler.schedule { @front.call(data.to_s) }\n        self\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 497,
    "raw_source": "def callback(&block)\n        return yield if closed?\n\n        @callbacks << block\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 505,
    "raw_source": "def closed?\n        @closed\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 515,
    "raw_source": "def stream(keep_open = false)\n      scheduler = env['async.callback'] ? EventMachine : Stream\n      current   = @params.dup\n      stream = if scheduler == Stream  && keep_open\n        Stream.new(scheduler, false) do |out|\n          until out.closed?\n            with_params(current) { yield(out) }\n          end\n        end\n      else\n        Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } }\n      end\n      body stream\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 540,
    "raw_source": "def cache_control(*values)\n      if values.last.is_a?(Hash)\n        hash = values.pop\n        hash.reject! { |_k, v| v == false }\n        hash.reject! { |k, v| values << k if v == true }\n      else\n        hash = {}\n      end\n\n      values.map! { |value| value.to_s.tr('_', '-') }\n      hash.each do |key, value|\n        key = key.to_s.tr('_', '-')\n        value = value.to_i if %w[max-age s-maxage].include? key\n        values << \"#{key}=#{value}\"\n      end\n\n      response['Cache-Control'] = values.join(', ') if values.any?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 568,
    "raw_source": "def expires(amount, *values)\n      values << {} unless values.last.is_a?(Hash)\n\n      if amount.is_a? Integer\n        time    = Time.now + amount.to_i\n        max_age = amount\n      else\n        time    = time_for amount\n        max_age = time - Time.now\n      end\n\n      values.last.merge!(max_age: max_age) { |_key, v1, v2| v1 || v2 }\n      cache_control(*values)\n\n      response['Expires'] = time.httpdate\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 592,
    "raw_source": "def last_modified(time)\n      return unless time\n\n      time = time_for time\n      response['Last-Modified'] = time.httpdate\n      return if env['HTTP_IF_NONE_MATCH']\n\n      if (status == 200) && env['HTTP_IF_MODIFIED_SINCE']\n        # compare based on seconds since epoch\n        since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i\n        halt 304 if since >= time.to_i\n      end\n\n      if (success? || (status == 412)) && env['HTTP_IF_UNMODIFIED_SINCE']\n        # compare based on seconds since epoch\n        since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i\n        halt 412 if since < time.to_i\n      end\n    rescue ArgumentError\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 623,
    "raw_source": "def etag(value, options = {})\n      # Before touching this code, please double check RFC 2616 14.24 and 14.26.\n      options      = { kind: options } unless Hash === options\n      kind         = options[:kind] || :strong\n      new_resource = options.fetch(:new_resource) { request.post? }\n\n      unless ETAG_KINDS.include?(kind)\n        raise ArgumentError, ':strong or :weak expected'\n      end\n\n      value = format('\"%s\"', value)\n      value = \"W/#{value}\" if kind == :weak\n      response['ETag'] = value\n\n      return unless success? || status == 304\n\n      if etag_matches?(env['HTTP_IF_NONE_MATCH'], new_resource)\n        halt(request.safe? ? 304 : 412)\n      end\n\n      if env['HTTP_IF_MATCH']\n        return if etag_matches?(env['HTTP_IF_MATCH'], new_resource)\n\n        halt 412\n      end\n\n      nil\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 653,
    "raw_source": "def back\n      request.referer\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 658,
    "raw_source": "def informational?\n      status.between? 100, 199\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 663,
    "raw_source": "def success?\n      status.between? 200, 299\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 668,
    "raw_source": "def redirect?\n      status.between? 300, 399\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 673,
    "raw_source": "def client_error?\n      status.between? 400, 499\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 678,
    "raw_source": "def server_error?\n      status.between? 500, 599\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 683,
    "raw_source": "def not_found?\n      status == 404\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 688,
    "raw_source": "def bad_request?\n      status == 400\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 694,
    "raw_source": "def time_for(value)\n      if value.is_a? Numeric\n        Time.at value\n      elsif value.respond_to? :to_s\n        Time.parse value.to_s\n      else\n        value.to_time\n      end\n    rescue ArgumentError => e\n      raise e\n    rescue Exception\n      raise ArgumentError, \"unable to convert #{value.inspect} to a Time object\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 711,
    "raw_source": "def etag_matches?(list, new_resource = request.post?)\n      return !new_resource if list == '*'\n\n      list.to_s.split(/\\s*,\\s*/).include? response['ETag']\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 717,
    "raw_source": "def with_params(temp_params)\n      original = @params\n      @params = temp_params\n      yield\n    ensure\n      @params = original if original\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 749,
    "raw_source": "def initialize\n      super\n      @default_layout = :layout\n      @preferred_extension = nil\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 755,
    "raw_source": "def erb(template, options = {}, locals = {}, &block)\n      render(:erb, template, options, locals, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 759,
    "raw_source": "def haml(template, options = {}, locals = {}, &block)\n      render(:haml, template, options, locals, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 763,
    "raw_source": "def sass(template, options = {}, locals = {})\n      options[:default_content_type] = :css\n      options[:exclude_outvar] = true\n      options[:layout] = nil\n      render :sass, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 770,
    "raw_source": "def scss(template, options = {}, locals = {})\n      options[:default_content_type] = :css\n      options[:exclude_outvar] = true\n      options[:layout] = nil\n      render :scss, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 777,
    "raw_source": "def builder(template = nil, options = {}, locals = {}, &block)\n      options[:default_content_type] = :xml\n      render_ruby(:builder, template, options, locals, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 782,
    "raw_source": "def liquid(template, options = {}, locals = {}, &block)\n      render(:liquid, template, options, locals, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 786,
    "raw_source": "def markdown(template, options = {}, locals = {})\n      options[:exclude_outvar] = true\n      render :markdown, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 791,
    "raw_source": "def rdoc(template, options = {}, locals = {})\n      render :rdoc, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 795,
    "raw_source": "def asciidoc(template, options = {}, locals = {})\n      render :asciidoc, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 799,
    "raw_source": "def markaby(template = nil, options = {}, locals = {}, &block)\n      render_ruby(:mab, template, options, locals, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 803,
    "raw_source": "def nokogiri(template = nil, options = {}, locals = {}, &block)\n      options[:default_content_type] = :xml\n      render_ruby(:nokogiri, template, options, locals, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 808,
    "raw_source": "def slim(template, options = {}, locals = {}, &block)\n      render(:slim, template, options, locals, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 812,
    "raw_source": "def yajl(template, options = {}, locals = {})\n      options[:default_content_type] = :json\n      render :yajl, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 817,
    "raw_source": "def rabl(template, options = {}, locals = {})\n      Rabl.register!\n      render :rabl, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 824,
    "raw_source": "def find_template(views, name, engine)\n      yield ::File.join(views, \"#{name}.#{@preferred_extension}\")\n\n      Tilt.default_mapping.extensions_for(engine).each do |ext|\n        yield ::File.join(views, \"#{name}.#{ext}\") unless ext == @preferred_extension\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 835,
    "raw_source": "def render_ruby(engine, template, options = {}, locals = {}, &block)\n      if template.is_a?(Hash)\n        options = template\n        template = nil\n      end\n      template = proc { block } if template.nil?\n      render engine, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 844,
    "raw_source": "def render(engine, data, options = {}, locals = {}, &block)\n      # merge app-level options\n      engine_options = settings.respond_to?(engine) ? settings.send(engine) : {}\n      options.merge!(engine_options) { |_key, v1, _v2| v1 }\n\n      # extract generic options\n      locals          = options.delete(:locals) || locals         || {}\n      views           = options.delete(:views)  || settings.views || './views'\n      layout          = options[:layout]\n      layout          = false if layout.nil? && options.include?(:layout)\n      eat_errors      = layout.nil?\n      layout          = engine_options[:layout] if layout.nil? || (layout == true && engine_options[:layout] != false)\n      layout          = @default_layout         if layout.nil? || (layout == true)\n      layout_options  = options.delete(:layout_options) || {}\n      content_type    = options.delete(:default_content_type)\n      content_type    = options.delete(:content_type)   || content_type\n      layout_engine   = options.delete(:layout_engine)  || engine\n      scope           = options.delete(:scope)          || self\n      exclude_outvar  = options.delete(:exclude_outvar)\n      options.delete(:layout)\n\n      # set some defaults\n      options[:outvar] ||= '@_out_buf' unless exclude_outvar\n      options[:default_encoding] ||= settings.default_encoding\n\n      # compile and render template\n      begin\n        layout_was      = @default_layout\n        @default_layout = false\n        template        = compile_template(engine, data, options, views)\n        output          = template.render(scope, locals, &block)\n      ensure\n        @default_layout = layout_was\n      end\n\n      # render layout\n      if layout\n        extra_options = { views: views, layout: false, eat_errors: eat_errors, scope: scope }\n        options = options.merge(extra_options).merge!(layout_options)\n\n        catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } }\n      end\n\n      if content_type\n        # sass-embedded returns a frozen string\n        output = +output\n        output.extend(ContentTyped).content_type = content_type\n      end\n      output\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 895,
    "raw_source": "def compile_template(engine, data, options, views)\n      eat_errors = options.delete :eat_errors\n      template = Tilt[engine]\n      raise \"Template engine not found: #{engine}\" if template.nil?\n\n      case data\n      when Symbol\n        template_cache.fetch engine, data, options, views do\n          body, path, line = settings.templates[data]\n          if body\n            body = body.call if body.respond_to?(:call)\n            template.new(path, line.to_i, options) { body }\n          else\n            found = false\n            @preferred_extension = engine.to_s\n            find_template(views, data, template) do |file|\n              path ||= file # keep the initial path rather than the last one\n              found = File.exist?(file)\n              if found\n                path = file\n                break\n              end\n            end\n            throw :layout_missing if eat_errors && !found\n            template.new(path, 1, options)\n          end\n        end\n      when Proc\n        compile_block_template(template, options, &data)\n      when String\n        template_cache.fetch engine, data, options, views do\n          compile_block_template(template, options) { data }\n        end\n      else\n        raise ArgumentError, \"Sorry, don't know how to render #{data.inspect}.\"\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 933,
    "raw_source": "def compile_block_template(template, options, &body)\n      first_location = caller_locations.first\n      path = first_location.path\n      line = first_location.lineno\n      path = options[:path] || path\n      line = options[:line] || line\n      template.new(path, line.to_i, options, &body)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 952,
    "raw_source": "def initialize\n      @cache = {}\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 960,
    "raw_source": "def fetch(*key)\n      @cache.fetch(key) do\n        @cache[key] = yield\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 967,
    "raw_source": "def clear\n      @cache = {}\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 983,
    "raw_source": "def initialize(app = nil, **_kwargs)\n      super()\n      @app = app\n      @template_cache = TemplateCache.new\n      @pinned_response = nil # whether a before! filter pinned the content-type\n      yield self if block_given?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 992,
    "raw_source": "def call(env)\n      dup.call!(env)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 996,
    "raw_source": "def call!(env) # :nodoc:\n      @env      = env\n      @params   = IndifferentHash.new\n      @request  = Request.new(env)\n      @response = Response.new\n      @pinned_response = nil\n      template_cache.clear if settings.reload_templates\n\n      invoke { dispatch! }\n      invoke { error_block!(response.status) } unless @env['sinatra.error']\n\n      unless @response['content-type']\n        if Array === body && body[0].respond_to?(:content_type)\n          content_type body[0].content_type\n        elsif (default = settings.default_content_type)\n          content_type default\n        end\n      end\n\n      @response.finish\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1019,
    "raw_source": "def self.settings\n      self\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1024,
    "raw_source": "def settings\n      self.class.settings\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1030,
    "raw_source": "def halt(*response)\n      response = response.first if response.length == 1\n      throw :halt, response\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1038,
    "raw_source": "def pass(&block)\n      throw :pass, block\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1043,
    "raw_source": "def forward\n      raise 'downstream app not set' unless @app.respond_to? :call\n\n      status, headers, body = @app.call env\n      @response.status = status\n      @response.body = body\n      @response.headers.merge! headers\n      nil\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1057,
    "raw_source": "def filter!(type, base = settings, &block)\n      filter!(type, base.superclass, &block) if base.superclass.respond_to?(:filters)\n      base.filters[type].each do |args|\n        result = process_route(*args)\n        block.call(result) if block_given?\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1066,
    "raw_source": "def route!(base = settings, pass_block = nil)\n      routes = base.routes[@request.request_method]\n\n      routes&.each do |pattern, conditions, block|\n        response.delete_header('content-type') unless @pinned_response\n\n        returned_pass_block = process_route(pattern, conditions) do |*args|\n          env['sinatra.route'] = \"#{@request.request_method} #{pattern}\"\n          route_eval { block[*args] }\n        end\n\n        # don't wipe out pass_block in superclass\n        pass_block = returned_pass_block if returned_pass_block\n      end\n\n      # Run routes defined in superclass.\n      if base.superclass.respond_to?(:routes)\n        return route!(base.superclass, pass_block)\n      end\n\n      route_eval(&pass_block) if pass_block\n      route_missing\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1091,
    "raw_source": "def route_eval\n      throw :halt, yield\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1100,
    "raw_source": "def process_route(pattern, conditions, block = nil, values = [])\n      route = @request.path_info\n      route = '/' if route.empty? && !settings.empty_path_info?\n      route = route[0..-2] if !settings.strict_paths? && route != '/' && route.end_with?('/')\n\n      params = pattern.params(route)\n      return unless params\n\n      params.delete('ignore') # TODO: better params handling, maybe turn it into \"smart\" object or detect changes\n      force_encoding(params)\n      @params = @params.merge(params) { |_k, v1, v2| v2 || v1 } if params.any?\n\n      regexp_exists = pattern.is_a?(Mustermann::Regular) || (pattern.respond_to?(:patterns) && pattern.patterns.any? { |subpattern| subpattern.is_a?(Mustermann::Regular) })\n      if regexp_exists\n        captures           = pattern.match(route).captures.map { |c| URI_INSTANCE.unescape(c) if c }\n        values            += captures\n        @params[:captures] = force_encoding(captures) unless captures.nil? || captures.empty?\n      else\n        values += params.values.flatten\n      end\n\n      catch(:pass) do\n        conditions.each { |c| throw :pass if c.bind(self).call == false }\n        block ? block[self, values] : yield(self, values)\n      end\n    rescue StandardError\n      @env['sinatra.error.params'] = @params\n      raise\n    ensure\n      params ||= {}\n      params.each { |k, _| @params.delete(k) } unless @env['sinatra.error.params']\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1138,
    "raw_source": "def route_missing\n      raise NotFound unless @app\n\n      forward\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1147,
    "raw_source": "def static!(options = {})\n      return if (public_dir = settings.public_folder).nil?\n\n      path = \"#{public_dir}#{URI_INSTANCE.unescape(request.path_info)}\"\n      return unless valid_path?(path)\n\n      path = File.expand_path(path)\n      return unless path.start_with?(\"#{File.expand_path(public_dir)}/\")\n\n      return unless File.file?(path)\n\n      env['sinatra.static_file'] = path\n      cache_control(*settings.static_cache_control) if settings.static_cache_control?\n\n      headers(settings.static_headers) if settings.static_headers?\n\n      send_file path, options.merge(disposition: nil)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1167,
    "raw_source": "def invoke(&block)\n      res = catch(:halt, &block)\n\n      res = [res] if (Integer === res) || (String === res)\n      if (Array === res) && (Integer === res.first)\n        res = res.dup\n        status(res.shift)\n        body(res.pop)\n        headers(*res)\n      elsif res.respond_to? :each\n        body res\n      end\n      nil # avoid double setting the same response tuple twice\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1183,
    "raw_source": "def dispatch!\n      # Avoid passing frozen string in force_encoding\n      @params.merge!(@request.params).each do |key, val|\n        next unless val.respond_to?(:force_encoding)\n\n        val = val.dup if val.frozen?\n        @params[key] = force_encoding(val)\n      end\n\n      invoke do\n        static! if settings.static? && (request.get? || request.head?)\n        filter! :before do\n          @pinned_response = !response['content-type'].nil?\n        end\n        route!\n      end\n    rescue ::Exception => e\n      invoke { handle_exception!(e) }\n    ensure\n      begin\n        filter! :after unless env['sinatra.static_file']\n      rescue ::Exception => e\n        invoke { handle_exception!(e) } unless @env['sinatra.error']\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1210,
    "raw_source": "def handle_exception!(boom)\n      error_params = @env['sinatra.error.params']\n\n      @params = @params.merge(error_params) if error_params\n\n      @env['sinatra.error'] = boom\n\n      http_status = if boom.is_a? Sinatra::Error\n                      if boom.respond_to? :http_status\n                        boom.http_status\n                      elsif settings.use_code? && boom.respond_to?(:code)\n                        boom.code\n                      end\n                    end\n\n      http_status = 500 unless http_status&.between?(400, 599)\n      status(http_status)\n\n      if server_error?\n        dump_errors! boom if settings.dump_errors?\n        raise boom if settings.show_exceptions? && (settings.show_exceptions != :after_handler)\n      elsif not_found?\n        headers['X-Cascade'] = 'pass' if settings.x_cascade?\n      end\n\n      if (res = error_block!(boom.class, boom) || error_block!(status, boom))\n        return res\n      end\n\n      if not_found? || bad_request?\n        if boom.message && boom.message != boom.class.name\n          body Rack::Utils.escape_html(boom.message)\n        else\n          content_type 'text/html'\n          body \"<h1>#{not_found? ? 'Not Found' : 'Bad Request'}</h1>\"\n        end\n      end\n\n      return unless server_error?\n\n      raise boom if settings.raise_errors? || settings.show_exceptions?\n\n      error_block! Exception, boom\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1256,
    "raw_source": "def error_block!(key, *block_params)\n      base = settings\n      while base.respond_to?(:errors)\n        args_array = base.errors[key]\n\n        next base = base.superclass unless args_array\n\n        args_array.reverse_each do |args|\n          first = args == args_array.first\n          args += [block_params]\n          resp = process_route(*args)\n          return resp unless resp.nil? && !first\n        end\n      end\n      return false unless key.respond_to?(:superclass) && (key.superclass < Exception)\n\n      error_block!(key.superclass, *block_params)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1275,
    "raw_source": "def dump_errors!(boom)\n      if boom.respond_to?(:detailed_message)\n        msg = boom.detailed_message(highlight: false)\n        if msg =~ /\\A(.*?)(?: \\(#{ Regexp.quote(boom.class.to_s) }\\))?\\n/\n          msg = $1\n          additional_msg = $'.lines(chomp: true)\n        else\n          additional_msg = []\n        end\n      else\n        msg = boom.message\n        additional_msg = []\n      end\n      msg = [\"#{Time.now.strftime('%Y-%m-%d %H:%M:%S')} - #{boom.class} - #{msg}:\", *additional_msg, *boom.backtrace].join(\"\\n\\t\")\n      @env['rack.errors'].puts(msg)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1307,
    "raw_source": "def callers_to_ignore\n        CALLERS_TO_IGNORE\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1313,
    "raw_source": "def reset!\n        @conditions     = []\n        @routes         = {}\n        @filters        = { before: [], after: [] }\n        @errors         = {}\n        @middleware     = []\n        @prototype      = nil\n        @extensions     = []\n\n        @templates = if superclass.respond_to?(:templates)\n                       Hash.new { |_hash, key| superclass.templates[key] }\n                     else\n                       {}\n                     end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1330,
    "raw_source": "def extensions\n        if superclass.respond_to?(:extensions)\n          (@extensions + superclass.extensions).uniq\n        else\n          @extensions\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1339,
    "raw_source": "def middleware\n        if superclass.respond_to?(:middleware)\n          superclass.middleware + @middleware\n        else\n          @middleware\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1349,
    "raw_source": "def set(option, value = (not_set = true), ignore_setter = false, &block)\n        raise ArgumentError if block && !not_set\n\n        if block\n          value = block\n          not_set = false\n        end\n\n        if not_set\n          raise ArgumentError unless option.respond_to?(:each)\n\n          option.each { |k, v| set(k, v) }\n          return self\n        end\n\n        if respond_to?(\"#{option}=\") && !ignore_setter\n          return __send__(\"#{option}=\", value)\n        end\n\n        setter = proc { |val| set option, val, true }\n        getter = proc { value }\n\n        case value\n        when Proc\n          getter = value\n        when Symbol, Integer, FalseClass, TrueClass, NilClass\n          getter = value.inspect\n        when Hash\n          setter = proc do |val|\n            val = value.merge val if Hash === val\n            set option, val, true\n          end\n        end\n\n        define_singleton(\"#{option}=\", setter)\n        define_singleton(option, getter)\n        define_singleton(\"#{option}?\", \"!!#{option}\") unless method_defined? \"#{option}?\"\n        self\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1390,
    "raw_source": "def enable(*opts)\n        opts.each { |key| set(key, true) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1395,
    "raw_source": "def disable(*opts)\n        opts.each { |key| set(key, false) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1402,
    "raw_source": "def error(*codes, &block)\n        args  = compile! 'ERROR', /.*/, block\n        codes = codes.flat_map(&method(:Array))\n        codes << Exception if codes.empty?\n        codes << Sinatra::NotFound if codes.include?(404)\n        codes.each { |c| (@errors[c] ||= []) << args }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1411,
    "raw_source": "def not_found(&block)\n        error(404, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1416,
    "raw_source": "def template(name, &block)\n        filename, line = caller_locations.first\n        templates[name] = [block, filename, line.to_i]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1422,
    "raw_source": "def layout(name = :layout, &block)\n        template name, &block\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1428,
    "raw_source": "def inline_templates=(file = nil)\n        file = (caller_files.first || File.expand_path($0)) if file.nil? || file == true\n\n        begin\n          io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file)\n          app, data = io.gsub(\"\\r\\n\", \"\\n\").split(/^__END__$/, 2)\n        rescue Errno::ENOENT\n          app, data = nil\n        end\n\n        return unless data\n\n        encoding = if app && app =~ /([^\\n]*\\n)?#[^\\n]*coding: *(\\S+)/m\n                     $2\n                   else\n                     settings.default_encoding\n                   end\n\n        lines = app.count(\"\\n\") + 1\n        template = nil\n        force_encoding data, encoding\n        data.each_line do |line|\n          lines += 1\n          if line =~ /^@@\\s*(.*\\S)\\s*$/\n            template = force_encoding(String.new, encoding)\n            templates[$1.to_sym] = [template, file, lines]\n          elsif template\n            template << line\n          end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1461,
    "raw_source": "def mime_type(type, value = nil)\n        return type      if type.nil?\n        return type.to_s if type.to_s.include?('/')\n\n        type = \".#{type}\" unless type.to_s[0] == '.'\n        return Rack::Mime.mime_type(type, nil) unless value\n\n        Rack::Mime::MIME_TYPES[type] = value\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1474,
    "raw_source": "def mime_types(type)\n        type = mime_type type\n        if type =~ %r{^application/(xml|javascript)$}\n          [type, \"text/#{$1}\"]\n        elsif type =~ %r{^text/(xml|javascript)$}\n          [type, \"application/#{$1}\"]\n        else\n          [type]\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1488,
    "raw_source": "def before(path = /.*/, **options, &block)\n        add_filter(:before, path, **options, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1495,
    "raw_source": "def after(path = /.*/, **options, &block)\n        add_filter(:after, path, **options, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1500,
    "raw_source": "def add_filter(type, path = /.*/, **options, &block)\n        filters[type] << compile!(type, path, block, **options)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1504,
    "raw_source": "def on_start(&on_start_callback)\n        @on_start_callback = on_start_callback\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1508,
    "raw_source": "def on_stop(&on_stop_callback)\n        @on_stop_callback = on_stop_callback\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1514,
    "raw_source": "def condition(name = \"#{caller.first[/`.*'/]} condition\", &block)\n        @conditions << generate_method(name, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1518,
    "raw_source": "def public=(value)\n        warn_for_deprecation ':public is no longer used to avoid overloading Module#public, use :public_folder or :public_dir instead'\n        set(:public_folder, value)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1523,
    "raw_source": "def public_dir=(value)\n        self.public_folder = value\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1527,
    "raw_source": "def public_dir\n        public_folder\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1533,
    "raw_source": "def get(path, opts = {}, &block)\n        conditions = @conditions.dup\n        route('GET', path, opts, &block)\n\n        @conditions = conditions\n        route('HEAD', path, opts, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1541,
    "raw_source": "def put(path, opts = {}, &block)     route 'PUT',     path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1543,
    "raw_source": "def post(path, opts = {}, &block)    route 'POST',    path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1545,
    "raw_source": "def delete(path, opts = {}, &block)  route 'DELETE',  path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1547,
    "raw_source": "def head(path, opts = {}, &block)    route 'HEAD',    path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1549,
    "raw_source": "def options(path, opts = {}, &block) route 'OPTIONS', path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1551,
    "raw_source": "def patch(path, opts = {}, &block)   route 'PATCH',   path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1553,
    "raw_source": "def link(path, opts = {}, &block)    route 'LINK',    path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1555,
    "raw_source": "def unlink(path, opts = {}, &block)  route 'UNLINK',  path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1559,
    "raw_source": "def helpers(*extensions, &block)\n        class_eval(&block)   if block_given?\n        include(*extensions) if extensions.any?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1566,
    "raw_source": "def register(*extensions, &block)\n        extensions << Module.new(&block) if block_given?\n        @extensions += extensions\n        extensions.each do |extension|\n          extend extension\n          extension.registered(self) if extension.respond_to?(:registered)\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1575,
    "raw_source": "def development?; environment == :development end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1576,
    "raw_source": "def production?;  environment == :production  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1577,
    "raw_source": "def test?;        environment == :test        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1581,
    "raw_source": "def configure(*envs)\n        yield self if envs.empty? || envs.include?(environment.to_sym)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1586,
    "raw_source": "def use(middleware, *args, &block)\n        @prototype = nil\n        @middleware << [middleware, args, block]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1593,
    "raw_source": "def quit!\n        return unless running?\n\n        # Use Thin's hard #stop! if available, otherwise just #stop.\n        running_server.respond_to?(:stop!) ? running_server.stop! : running_server.stop\n        warn '== Sinatra has ended his set (crowd applauds)' unless suppress_messages?\n        set :running_server, nil\n        set :handler_name, nil\n\n        on_stop_callback.call unless on_stop_callback.nil?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1610,
    "raw_source": "def run!(options = {}, &block)\n        unless defined?(Rackup::Handler)\n          rackup_warning = <<~MISSING_RACKUP\n            Sinatra could not start, the required gems weren't found!\n\n            Add them to your bundle with:\n\n                bundle add rackup puma\n\n            or install them with:\n\n                gem install rackup puma\n\n          MISSING_RACKUP\n          warn rackup_warning\n          exit 1\n        end\n\n        return if running?\n\n        set options\n        handler         = Rackup::Handler.pick(server)\n        handler_name    = handler.name.gsub(/.*::/, '')\n        server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {}\n        server_settings.merge!(Port: port, Host: bind)\n\n        begin\n          start_server(handler, server_settings, handler_name, &block)\n        rescue Errno::EADDRINUSE\n          warn \"== Someone is already performing on port #{port}!\"\n          raise\n        ensure\n          quit!\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1649,
    "raw_source": "def running?\n        running_server?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1654,
    "raw_source": "def prototype\n        @prototype ||= new\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1664,
    "raw_source": "def new(*args, &block)\n        instance = new!(*args, &block)\n        Wrapper.new(build(instance).to_app, instance)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1672,
    "raw_source": "def build(app)\n        builder = Rack::Builder.new\n        setup_default_middleware builder\n        setup_middleware builder\n        builder.run app\n        builder\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1680,
    "raw_source": "def call(env)\n        synchronize { prototype.call(env) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1686,
    "raw_source": "def caller_files\n        cleaned_caller(1).flatten\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1693,
    "raw_source": "def start_server(handler, server_settings, handler_name)\n        # Ensure we initialize middleware before startup, to match standard Rack\n        # behavior, by ensuring an instance exists:\n        prototype\n        # Run the instance we created:\n        handler.run(self, **server_settings) do |server|\n          unless suppress_messages?\n            warn \"== Sinatra (v#{Sinatra::VERSION}) has taken the stage on #{port} for #{environment} with backup from #{handler_name}\"\n          end\n\n          setup_traps\n          set :running_server, server\n          set :handler_name,   handler_name\n          server.threaded = settings.threaded if server.respond_to? :threaded=\n          on_start_callback.call unless on_start_callback.nil?\n          yield server if block_given?\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1712,
    "raw_source": "def suppress_messages?\n        handler_name =~ /cgi/i || quiet\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1716,
    "raw_source": "def setup_traps\n        return unless traps?\n\n        at_exit { quit! }\n\n        %i[INT TERM].each do |signal|\n          old_handler = trap(signal) do\n            quit!\n            old_handler.call if old_handler.respond_to?(:call)\n          end\n        end\n\n        set :traps, false\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1732,
    "raw_source": "def define_singleton(name, content = Proc.new)\n        singleton_class.class_eval do\n          undef_method(name) if method_defined? name\n          String === content ? class_eval(\"def #{name}() #{content}; end\") : define_method(name, &content)\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1740,
    "raw_source": "def host_name(pattern)\n        condition { pattern === request.host }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1746,
    "raw_source": "def user_agent(pattern)\n        condition do\n          if request.user_agent.to_s =~ pattern\n            @params[:agent] = $~[1..-1]\n            true\n          else\n            false\n          end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1759,
    "raw_source": "def provides(*types)\n        types.map! { |t| mime_types(t) }\n        types.flatten!\n        condition do\n          response_content_type = response['content-type']\n          preferred_type = request.preferred_type(types)\n\n          if response_content_type\n            types.include?(response_content_type) || types.include?(response_content_type[/^[^;]+/])\n          elsif preferred_type\n            params = (preferred_type.respond_to?(:params) ? preferred_type.params : {})\n            content_type(preferred_type, params)\n            true\n          else\n            false\n          end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1778,
    "raw_source": "def route(verb, path, options = {}, &block)\n        enable :empty_path_info if path == '' && empty_path_info.nil?\n        signature = compile!(verb, path, block, **options)\n        (@routes[verb] ||= []) << signature\n        invoke_hook(:route_added, verb, path, block)\n        signature\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1786,
    "raw_source": "def invoke_hook(name, *args)\n        extensions.each { |e| e.send(name, *args) if e.respond_to?(name) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1790,
    "raw_source": "def generate_method(method_name, &block)\n        define_method(method_name, &block)\n        method = instance_method method_name\n        remove_method method_name\n        method\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1797,
    "raw_source": "def compile!(verb, path, block, **options)\n        # Because of self.options.host\n        host_name(options.delete(:host)) if options.key?(:host)\n        # Pass Mustermann opts to compile()\n        route_mustermann_opts = options.key?(:mustermann_opts) ? options.delete(:mustermann_opts) : {}.freeze\n\n        options.each_pair { |option, args| send(option, *args) }\n\n        pattern                 = compile(path, route_mustermann_opts)\n        method_name             = \"#{verb} #{path}\"\n        unbound_method          = generate_method(method_name, &block)\n        conditions = @conditions\n        @conditions = []\n        wrapper = block.arity.zero? ?\n          proc { |a, _p| unbound_method.bind(a).call } :\n          proc { |a, p| unbound_method.bind(a).call(*p) }\n\n        [pattern, conditions, wrapper]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1817,
    "raw_source": "def compile(path, route_mustermann_opts = {})\n        Mustermann.new(path, **mustermann_opts.merge(route_mustermann_opts))\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1821,
    "raw_source": "def setup_default_middleware(builder)\n        builder.use ExtendedRack\n        builder.use ShowExceptions       if show_exceptions?\n        builder.use Rack::MethodOverride if method_override?\n        builder.use Rack::Head\n        setup_logging    builder\n        setup_sessions   builder\n        setup_protection builder\n        setup_host_authorization builder\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1832,
    "raw_source": "def setup_middleware(builder)\n        middleware.each { |c, a, b| builder.use(c, *a, &b) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1836,
    "raw_source": "def setup_logging(builder)\n        if logging?\n          setup_common_logger(builder)\n          setup_custom_logger(builder)\n        elsif logging == false\n          setup_null_logger(builder)\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1845,
    "raw_source": "def setup_null_logger(builder)\n        builder.use Sinatra::Middleware::Logger, ::Logger::FATAL\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1849,
    "raw_source": "def setup_common_logger(builder)\n        builder.use Sinatra::CommonLogger\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1853,
    "raw_source": "def setup_custom_logger(builder)\n        if logging.respond_to? :to_int\n          builder.use Sinatra::Middleware::Logger, logging\n        else\n          builder.use Sinatra::Middleware::Logger\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1861,
    "raw_source": "def setup_protection(builder)\n        return unless protection?\n\n        options = Hash === protection ? protection.dup : {}\n        options = {\n          img_src: \"'self' data:\",\n          font_src: \"'self'\"\n        }.merge options\n\n        protect_session = options.fetch(:session) { sessions? }\n        options[:without_session] = !protect_session\n\n        options[:reaction] ||= :drop_session\n\n        builder.use Rack::Protection, options\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1878,
    "raw_source": "def setup_host_authorization(builder)\n        builder.use Rack::Protection::HostAuthorization, host_authorization\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1882,
    "raw_source": "def setup_sessions(builder)\n        return unless sessions?\n\n        options = {}\n        options[:secret] = session_secret if session_secret?\n        options.merge! sessions.to_hash if sessions.respond_to? :to_hash\n        builder.use session_store, options\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1891,
    "raw_source": "def inherited(subclass)\n        subclass.reset!\n        subclass.set :app_file, caller_files.first unless subclass.app_file?\n        super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1898,
    "raw_source": "def synchronize(&block)\n        if lock?\n          @@mutex.synchronize(&block)\n        else\n          yield\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1907,
    "raw_source": "def warn_for_deprecation(message)\n        warn message + \"\\n\\tfrom #{cleaned_caller.first.join(':')}\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1912,
    "raw_source": "def cleaned_caller(keep = 3)\n        caller(1)\n          .map! { |line| line.split(/:(?=\\d|in )/, 3)[0, keep] }\n          .reject { |file, *_| callers_to_ignore.any? { |pattern| file =~ pattern } }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1921,
    "raw_source": "def self.force_encoding(data, encoding = default_encoding)\n      return if data == settings || data.is_a?(Tempfile)\n\n      if data.respond_to? :force_encoding\n        data.force_encoding(encoding).encode!\n      elsif data.respond_to? :each_value\n        data.each_value { |v| force_encoding(v, encoding) }\n      elsif data.respond_to? :each\n        data.each { |v| force_encoding(v, encoding) }\n      end\n      data\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1934,
    "raw_source": "def force_encoding(*args)\n      settings.force_encoding(*args)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2093,
    "raw_source": "def self.register(*extensions, &block) # :nodoc:\n      added_methods = extensions.flat_map(&:public_instance_methods)\n      Delegator.delegate(*added_methods)\n      super(*extensions, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2104,
    "raw_source": "def self.delegate(*methods)\n      methods.each do |method_name|\n        define_method(method_name) do |*args, &block|\n          return super(*args, &block) if respond_to? method_name\n\n          Delegator.target.send(method_name, *args, &block)\n        end\n        # ensure keyword argument passing is compatible with ruby >= 2.7\n        ruby2_keywords(method_name) if respond_to?(:ruby2_keywords, true)\n        private method_name\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2130,
    "raw_source": "def initialize(stack, instance)\n      @stack = stack\n      @instance = instance\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2135,
    "raw_source": "def settings\n      @instance.settings\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2139,
    "raw_source": "def helpers\n      @instance\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2143,
    "raw_source": "def call(env)\n      @stack.call(env)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2147,
    "raw_source": "def inspect\n      \"#<#{@instance.class} app_file=#{settings.app_file.inspect}>\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2153,
    "raw_source": "def self.new(base = Base, &block)\n    base = Class.new(base)\n    base.class_eval(&block) if block_given?\n    base\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2160,
    "raw_source": "def self.register(*extensions, &block)\n    Delegator.target.register(*extensions, &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2165,
    "raw_source": "def self.helpers(*extensions, &block)\n    Delegator.target.helpers(*extensions, &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2170,
    "raw_source": "def self.use(*args, &block)\n    Delegator.target.use(*args, &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 42,
    "raw_source": "def self.[](*args)\n      new.merge!(Hash[*args])\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 46,
    "raw_source": "def default(*args)\n      args.map!(&method(:convert_key))\n\n      super(*args)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 52,
    "raw_source": "def default=(value)\n      super(convert_value(value))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 56,
    "raw_source": "def assoc(key)\n      super(convert_key(key))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 60,
    "raw_source": "def rassoc(value)\n      super(convert_value(value))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 64,
    "raw_source": "def fetch(key, *args)\n      args.map!(&method(:convert_value))\n\n      super(convert_key(key), *args)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 70,
    "raw_source": "def [](key)\n      super(convert_key(key))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 74,
    "raw_source": "def []=(key, value)\n      super(convert_key(key), convert_value(value))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 80,
    "raw_source": "def key(value)\n      super(convert_value(value))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 84,
    "raw_source": "def key?(key)\n      super(convert_key(key))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 92,
    "raw_source": "def value?(value)\n      super(convert_value(value))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 98,
    "raw_source": "def delete(key)\n      super(convert_key(key))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 103,
    "raw_source": "def dig(key, *other_keys)\n      super(convert_key(key), *other_keys)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 107,
    "raw_source": "def fetch_values(*keys)\n      keys.map!(&method(:convert_key))\n\n      super(*keys)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 113,
    "raw_source": "def slice(*keys)\n      keys.map!(&method(:convert_key))\n\n      self.class[super(*keys)]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 119,
    "raw_source": "def values_at(*keys)\n      keys.map!(&method(:convert_key))\n\n      super(*keys)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 125,
    "raw_source": "def merge!(*other_hashes)\n      other_hashes.each do |other_hash|\n        if other_hash.is_a?(self.class)\n          super(other_hash)\n        else\n          other_hash.each_pair do |key, value|\n            key = convert_key(key)\n            value = yield(key, self[key], value) if block_given? && key?(key)\n            self[key] = convert_value(value)\n          end\n        end\n      end\n\n      self\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 143,
    "raw_source": "def merge(*other_hashes, &block)\n      dup.merge!(*other_hashes, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 147,
    "raw_source": "def replace(other_hash)\n      super(other_hash.is_a?(self.class) ? other_hash : self.class[other_hash])\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 151,
    "raw_source": "def transform_values(&block)\n      dup.transform_values!(&block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 155,
    "raw_source": "def transform_values!\n      super\n      super(&method(:convert_value))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 160,
    "raw_source": "def transform_keys(&block)\n      dup.transform_keys!(&block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 164,
    "raw_source": "def transform_keys!\n      super\n      super(&method(:convert_key))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 169,
    "raw_source": "def select(*args, &block)\n      return to_enum(:select) unless block_given?\n\n      dup.tap { |hash| hash.select!(*args, &block) }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 175,
    "raw_source": "def reject(*args, &block)\n      return to_enum(:reject) unless block_given?\n\n      dup.tap { |hash| hash.reject!(*args, &block) }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 181,
    "raw_source": "def compact\n      dup.tap(&:compact!)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 185,
    "raw_source": "def except(*keys)\n      keys.map!(&method(:convert_key))\n\n      self.class[super(*keys)]\n    end if Gem::Version.new(RUBY_VERSION) >= Gem::Version.new(\"3.0\")"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 193,
    "raw_source": "def convert_key(key)\n      key.is_a?(Symbol) ? key.to_s : key\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 197,
    "raw_source": "def convert_value(value)\n      case value\n      when Hash\n        value.is_a?(self.class) ? value : self.class[value]\n      when Array\n        value.map(&method(:convert_value))\n      else\n        value\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/middleware/logger.rb",
    "start_line": 8,
    "raw_source": "def initialize(app, level = ::Logger::INFO)\n        @app, @level = app, level\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/middleware/logger.rb",
    "start_line": 12,
    "raw_source": "def call(env)\n        logger = ::Logger.new(env[Rack::RACK_ERRORS])\n        logger.level = @level\n\n        env[Rack::RACK_LOGGER] = logger\n        @app.call(env)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 14,
    "raw_source": "def @@eats_errors.flush(*) end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 16,
    "raw_source": "def @@eats_errors.puts(*) end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 18,
    "raw_source": "def initialize(app)\n      @app = app\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 22,
    "raw_source": "def call(env)\n      @app.call(env)\n    rescue Exception => e\n      errors = env['rack.errors']\n      env['rack.errors'] = @@eats_errors\n\n      if prefers_plain_text?(env)\n        content_type = 'text/plain'\n        body = dump_exception(e)\n      else\n        content_type = 'text/html'\n        body = pretty(env, e)\n      end\n\n      env['rack.errors'] = errors\n\n      [\n        500,\n        {\n          'content-type' => content_type,\n          'content-length' => body.bytesize.to_s\n        },\n        [body]\n      ]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 48,
    "raw_source": "def template\n      TEMPLATE\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 54,
    "raw_source": "def bad_request?(exception)\n      Sinatra::BadRequest === exception\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 58,
    "raw_source": "def prefers_plain_text?(env)\n      Request.new(env).preferred_type('text/plain', 'text/html') != 'text/html' &&\n        [/curl/].index { |item| item =~ env['HTTP_USER_AGENT'] }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 63,
    "raw_source": "def frame_class(frame)\n      if frame.filename =~ %r{lib/sinatra.*\\.rb}\n        'framework'\n      elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) ||\n            frame.filename =~ %r{/bin/(\\w+)\\z}\n        'system'\n      else\n        'app'\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection.rb",
    "start_line": 27,
    "raw_source": "def self.new(app, options = {})\n      except = Array options[:except]\n      use_these = Array options[:use]\n\n      if options.fetch(:without_session, false)\n        except += %i[remote_token]\n      end\n\n      Rack::Builder.new do\n        # Off by default, unless added\n        use ::Rack::Protection::AuthenticityToken,     options if use_these.include? :authenticity_token\n        use ::Rack::Protection::ContentSecurityPolicy, options if use_these.include? :content_security_policy\n        use ::Rack::Protection::CookieTossing,         options if use_these.include? :cookie_tossing\n        use ::Rack::Protection::EscapedParams,         options if use_these.include? :escaped_params\n        use ::Rack::Protection::FormToken,             options if use_these.include? :form_token\n        use ::Rack::Protection::ReferrerPolicy,        options if use_these.include? :referrer_policy\n        use ::Rack::Protection::RemoteReferrer,        options if use_these.include? :remote_referrer\n        use ::Rack::Protection::SessionHijacking,      options if use_these.include? :session_hijacking\n        use ::Rack::Protection::StrictTransport,       options if use_these.include? :strict_transport\n\n        # On by default, unless skipped\n        use ::Rack::Protection::FrameOptions,          options unless except.include? :frame_options\n        use ::Rack::Protection::HttpOrigin,            options unless except.include? :http_origin\n        use ::Rack::Protection::IPSpoofing,            options unless except.include? :ip_spoofing\n        use ::Rack::Protection::JsonCsrf,              options unless except.include? :json_csrf\n        use ::Rack::Protection::PathTraversal,         options unless except.include? :path_traversal\n        use ::Rack::Protection::RemoteToken,           options unless except.include? :remote_token\n        use ::Rack::Protection::XSSHeader,             options unless except.include? :xss_header\n        run app\n      end.to_app\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 105,
    "raw_source": "def self.token(session, path: nil, method: :post)\n        new(nil).mask_authenticity_token(session, path: path, method: method)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 109,
    "raw_source": "def self.random_token\n        SecureRandom.urlsafe_base64(TOKEN_LENGTH, padding: false)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 113,
    "raw_source": "def accepts?(env)\n        session = session(env)\n        set_token(session)\n\n        safe?(env) ||\n          valid_token?(env, env['HTTP_X_CSRF_TOKEN']) ||\n          valid_token?(env, Request.new(env).params[options[:authenticity_param]]) ||\n          options[:allow_if]&.call(env)\n      rescue StandardError\n        false\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 125,
    "raw_source": "def mask_authenticity_token(session, path: nil, method: :post)\n        set_token(session)\n\n        token = if path && method\n                  per_form_token(session, path, method)\n                else\n                  global_token(session)\n                end\n\n        mask_token(token)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 142,
    "raw_source": "def set_token(session)\n        session[options[:key]] ||= self.class.random_token\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 148,
    "raw_source": "def valid_token?(env, token)\n        return false if token.nil? || !token.is_a?(String) || token.empty?\n\n        session = session(env)\n\n        begin\n          token = decode_token(token)\n        rescue ArgumentError # encoded_masked_token is invalid Base64\n          return false\n        end\n\n        # See if it's actually a masked token or not. We should be able\n        # to handle any unmasked tokens that we've issued without error.\n\n        if unmasked_token?(token)\n          compare_with_real_token(token, session)\n        elsif masked_token?(token)\n          token = unmask_token(token)\n\n          compare_with_global_token(token, session) ||\n            compare_with_real_token(token, session) ||\n            compare_with_per_form_token(token, session, Request.new(env))\n        else\n          false # Token is malformed\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 178,
    "raw_source": "def mask_token(token)\n        one_time_pad = SecureRandom.random_bytes(token.length)\n        encrypted_token = xor_byte_strings(one_time_pad, token)\n        masked_token = one_time_pad + encrypted_token\n        encode_token(masked_token)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 186,
    "raw_source": "def unmask_token(masked_token)\n        # Split the token into the one-time pad and the encrypted\n        # value and decrypt it\n        token_length = masked_token.length / 2\n        one_time_pad = masked_token[0...token_length]\n        encrypted_token = masked_token[token_length..]\n        xor_byte_strings(one_time_pad, encrypted_token)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 195,
    "raw_source": "def unmasked_token?(token)\n        token.length == TOKEN_LENGTH\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 199,
    "raw_source": "def masked_token?(token)\n        token.length == TOKEN_LENGTH * 2\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 203,
    "raw_source": "def compare_with_real_token(token, session)\n        secure_compare(token, real_token(session))\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 207,
    "raw_source": "def compare_with_global_token(token, session)\n        secure_compare(token, global_token(session))\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 211,
    "raw_source": "def compare_with_per_form_token(token, session, request)\n        secure_compare(token,\n                       per_form_token(session, request.path.chomp('/'), request.request_method))\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 216,
    "raw_source": "def real_token(session)\n        decode_token(session[options[:key]])\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 220,
    "raw_source": "def global_token(session)\n        token_hmac(session, GLOBAL_TOKEN_IDENTIFIER)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 224,
    "raw_source": "def per_form_token(session, path, method)\n        token_hmac(session, \"#{path}##{method.downcase}\")\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 228,
    "raw_source": "def encode_token(token)\n        Base64.urlsafe_encode64(token)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 232,
    "raw_source": "def decode_token(token)\n        Base64.urlsafe_decode64(token)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 236,
    "raw_source": "def token_hmac(session, identifier)\n        OpenSSL::HMAC.digest(\n          OpenSSL::Digest.new('SHA256'),\n          real_token(session),\n          identifier\n        )\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 244,
    "raw_source": "def xor_byte_strings(s1, s2)\n        s2 = s2.dup\n        size = s1.bytesize\n        i = 0\n        while i < size\n          s2.setbyte(i, s1.getbyte(i) ^ s2.getbyte(i))\n          i += 1\n        end\n        s2\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 23,
    "raw_source": "def self.default_options(options)\n        define_method(:default_options) { super().merge(options) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 27,
    "raw_source": "def self.default_reaction(reaction)\n        alias_method(:default_reaction, reaction)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 31,
    "raw_source": "def default_options\n        DEFAULT_OPTIONS\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 35,
    "raw_source": "def initialize(app, options = {})\n        @app = app\n        @options = default_options.merge(options)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 40,
    "raw_source": "def safe?(env)\n        %w[GET HEAD OPTIONS TRACE].include? env['REQUEST_METHOD']\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 44,
    "raw_source": "def accepts?(env)\n        raise NotImplementedError, \"#{self.class} implementation pending\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 48,
    "raw_source": "def call(env)\n        unless accepts? env\n          instrument env\n          result = react env\n        end\n        result or app.call(env)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 56,
    "raw_source": "def react(env)\n        result = send(options[:reaction], env)\n        result if (Array === result) && (result.size == 3)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 61,
    "raw_source": "def debug(env, message)\n        return unless options[:logging]\n\n        l = options[:logger] || env['rack.logger'] || ::Logger.new(env['rack.errors'])\n        l.debug(message)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 68,
    "raw_source": "def warn(env, message)\n        return unless options[:logging]\n\n        l = options[:logger] || env['rack.logger'] || ::Logger.new(env['rack.errors'])\n        l.warn(message)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 75,
    "raw_source": "def instrument(env)\n        return unless (i = options[:instrumenter])\n\n        env['rack.protection.attack'] = self.class.name.split('::').last.downcase\n        i.instrument('rack.protection', env)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 82,
    "raw_source": "def deny(env)\n        warn env, \"attack prevented by #{self.class}\"\n        [options[:status], { 'content-type' => 'text/plain' }, [options[:message]]]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 87,
    "raw_source": "def report(env)\n        warn env, \"attack reported by #{self.class}\"\n        env[options[:report_key]] = true\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 92,
    "raw_source": "def session?(env)\n        env.include? options[:session_key]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 96,
    "raw_source": "def session(env)\n        return env[options[:session_key]] if session? env\n\n        raise \"you need to set up a session middleware *before* #{self.class}\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 102,
    "raw_source": "def drop_session(env)\n        return unless session? env\n\n        session(env).clear\n\n        return if [\"1\", \"true\"].include?(ENV[\"RACK_PROTECTION_SILENCE_DROP_SESSION_WARNING\"])\n\n        warn env, \"session dropped by #{self.class}\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 112,
    "raw_source": "def referrer(env)\n        ref = env['HTTP_REFERER'].to_s\n        return if !options[:allow_empty_referrer] && ref.empty?\n\n        URI.parse(ref).host || Request.new(env).host\n      rescue URI::InvalidURIError\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 120,
    "raw_source": "def origin(env)\n        env['HTTP_ORIGIN'] || env['HTTP_X_ORIGIN']\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 124,
    "raw_source": "def random_string(secure = defined? SecureRandom)\n        secure ? SecureRandom.hex(16) : '%032x' % rand((2**128) - 1)\n      rescue NotImplementedError\n        random_string false\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 130,
    "raw_source": "def encrypt(value)\n        options[:encryptor].hexdigest value.to_s\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 134,
    "raw_source": "def secure_compare(a, b)\n        Rack::Utils.secure_compare(a.to_s, b.to_s)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 140,
    "raw_source": "def html?(headers)\n        return false unless (header = headers.detect { |k, _v| k.downcase == 'content-type' })\n\n        options[:html_types].include? header.last[%r{^\\w+/\\w+}]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/content_security_policy.rb",
    "start_line": 53,
    "raw_source": "def csp_policy\n        directives = []\n\n        DIRECTIVES.each do |d|\n          if options.key?(d)\n            directives << \"#{d.to_s.sub(/_/, '-')} #{options[d]}\"\n          end\n        end\n\n        # Set these key values to boolean 'true' to include in policy\n        NO_ARG_DIRECTIVES.each do |d|\n          if options.key?(d) && options[d].is_a?(TrueClass)\n            directives << d.to_s.tr('_', '-')\n          end\n        end\n\n        directives.compact.sort.join('; ')\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/content_security_policy.rb",
    "start_line": 72,
    "raw_source": "def call(env)\n        status, headers, body = @app.call(env)\n        header = options[:report_only] ? 'content-security-policy-report-only' : 'content-security-policy'\n        headers[header] ||= csp_policy if html? headers\n        [status, headers, body]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 22,
    "raw_source": "def call(env)\n        status, headers, body = super\n        response = Rack::Response.new(body, status, headers)\n        request = Rack::Request.new(env)\n        remove_bad_cookies(request, response)\n        response.finish\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 30,
    "raw_source": "def accepts?(env)\n        cookie_header = env['HTTP_COOKIE']\n        cookies = Rack::Utils.parse_query(cookie_header, ';,') { |s| s }\n        cookies.each do |k, v|\n          if (k == session_key && Array(v).size > 1) ||\n             (k != session_key && Rack::Utils.unescape(k) == session_key)\n            bad_cookies << k\n          end\n        end\n        bad_cookies.empty?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 42,
    "raw_source": "def remove_bad_cookies(request, response)\n        return if bad_cookies.empty?\n\n        paths = cookie_paths(request.path)\n        bad_cookies.each do |name|\n          paths.each { |path| response.set_cookie name, empty_cookie(request.host, path) }\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 51,
    "raw_source": "def redirect(env)\n        request = Request.new(env)\n        warn env, \"attack prevented by #{self.class}\"\n        [302, { 'content-type' => 'text/html', 'location' => request.path }, []]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 57,
    "raw_source": "def bad_cookies\n        @bad_cookies ||= []\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 61,
    "raw_source": "def cookie_paths(path)\n        path = '/' if path.to_s.empty?\n        paths = []\n        Pathname.new(path).descend { |p| paths << p.to_s }\n        paths\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 68,
    "raw_source": "def empty_cookie(host, path)\n        { value: '', domain: host, path: path, expires: Time.at(0) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 72,
    "raw_source": "def session_key\n        @session_key ||= options[:session_key]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/escaped_params.rb",
    "start_line": 36,
    "raw_source": "def initialize(*)\n        super\n\n        modes       = Array options[:escape]\n        @escaper    = options[:escaper]\n        @html       = modes.include? :html\n        @javascript = modes.include? :javascript\n        @url        = modes.include? :url\n\n        return unless @javascript && (!@escaper.respond_to? :escape_javascript)\n\n        raise('Use EscapeUtils for JavaScript escaping.')\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/escaped_params.rb",
    "start_line": 50,
    "raw_source": "def call(env)\n        request  = Request.new(env)\n        get_was  = handle(request.GET)\n        post_was = begin\n          handle(request.POST)\n        rescue StandardError\n          nil\n        end\n        app.call env\n      ensure\n        request.GET.replace  get_was  if get_was\n        request.POST.replace post_was if post_was\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/escaped_params.rb",
    "start_line": 64,
    "raw_source": "def handle(hash)\n        was = hash.dup\n        hash.replace escape(hash)\n        was\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/escaped_params.rb",
    "start_line": 70,
    "raw_source": "def escape(object)\n        case object\n        when Hash   then escape_hash(object)\n        when Array  then object.map { |o| escape(o) }\n        when String then escape_string(object)\n        when Tempfile then object\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/escaped_params.rb",
    "start_line": 79,
    "raw_source": "def escape_hash(hash)\n        hash = hash.dup\n        hash.each { |k, v| hash[k] = escape(v) }\n        hash\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/escaped_params.rb",
    "start_line": 85,
    "raw_source": "def escape_string(str)\n        str = @escaper.escape_url(str)        if @url\n        str = @escaper.escape_html(str)       if @html\n        str = @escaper.escape_javascript(str) if @javascript\n        str\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/form_token.rb",
    "start_line": 20,
    "raw_source": "def accepts?(env)\n        env['HTTP_X_REQUESTED_WITH'] == 'XMLHttpRequest' or super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/frame_options.rb",
    "start_line": 24,
    "raw_source": "def frame_options\n        @frame_options ||= begin\n          frame_options = options[:frame_options]\n          frame_options = options[:frame_options].to_s.upcase unless frame_options.respond_to? :to_str\n          frame_options.to_str\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/frame_options.rb",
    "start_line": 32,
    "raw_source": "def call(env)\n        status, headers, body        = @app.call(env)\n        headers['x-frame-options'] ||= frame_options if html? headers\n        [status, headers, body]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/host_authorization.rb",
    "start_line": 33,
    "raw_source": "def initialize(*)\n        super\n        @permitted_hosts = []\n        @domain_hosts = []\n        @ip_hosts = []\n        @all_permitted_hosts = Array(options[:permitted_hosts])\n\n        @all_permitted_hosts.each do |host|\n          case host\n          when String\n            if host.start_with?(DOT)\n              domain = host[1..-1]\n              @permitted_hosts << domain.downcase\n              @domain_hosts << /\\A#{SUBDOMAINS}#{Regexp.escape(domain)}\\z/i\n            else\n              @permitted_hosts << host.downcase\n            end\n          when IPAddr then @ip_hosts << host\n          end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/host_authorization.rb",
    "start_line": 55,
    "raw_source": "def accepts?(env)\n        return true if options[:allow_if]&.call(env)\n        return true if @all_permitted_hosts.empty?\n\n        request = Request.new(env)\n        origin_host = extract_host(request.host_authority)\n        forwarded_host = extract_host(request.forwarded_authority)\n\n        debug env, \"#{self.class} \" \\\n                   \"@all_permitted_hosts=#{@all_permitted_hosts.inspect} \" \\\n                   \"@permitted_hosts=#{@permitted_hosts.inspect} \" \\\n                   \"@domain_hosts=#{@domain_hosts.inspect} \" \\\n                   \"@ip_hosts=#{@ip_hosts.inspect} \" \\\n                   \"origin_host=#{origin_host.inspect} \" \\\n                   \"forwarded_host=#{forwarded_host.inspect}\"\n\n        if host_permitted?(origin_host)\n          if forwarded_host.nil?\n            true\n          else\n            host_permitted?(forwarded_host)\n          end\n        else\n          false\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/host_authorization.rb",
    "start_line": 84,
    "raw_source": "def extract_host(authority)\n        authority.to_s.split(PORT_REGEXP).first&.downcase\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/host_authorization.rb",
    "start_line": 88,
    "raw_source": "def host_permitted?(host)\n        exact_match?(host) || domain_match?(host) || ip_match?(host)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/host_authorization.rb",
    "start_line": 92,
    "raw_source": "def exact_match?(host)\n        @permitted_hosts.include?(host)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/host_authorization.rb",
    "start_line": 96,
    "raw_source": "def domain_match?(host)\n        return false if host.nil?\n        return false if host.start_with?(DOT)\n\n        @domain_hosts.any? { |domain_host| host.match?(domain_host) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/host_authorization.rb",
    "start_line": 103,
    "raw_source": "def ip_match?(host)\n        @ip_hosts.any? { |ip_host| ip_host.include?(host) }\n      rescue IPAddr::InvalidAddressError\n        false\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/http_origin.rb",
    "start_line": 26,
    "raw_source": "def base_url(env)\n        request = Rack::Request.new(env)\n        port = \":#{request.port}\" unless request.port == DEFAULT_PORTS[request.scheme]\n        \"#{request.scheme}://#{request.host}#{port}\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/http_origin.rb",
    "start_line": 32,
    "raw_source": "def accepts?(env)\n        return true if safe? env\n        return true unless (origin = env['HTTP_ORIGIN'])\n        return true if base_url(env) == origin\n        return true if options[:allow_if]&.call(env)\n\n        permitted_origins = options[:permitted_origins]\n        Array(permitted_origins).include? origin\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/ip_spoofing.rb",
    "start_line": 16,
    "raw_source": "def accepts?(env)\n        return true unless env.include? 'HTTP_X_FORWARDED_FOR'\n\n        ips = env['HTTP_X_FORWARDED_FOR'].split(',').map(&:strip)\n        return false if env.include?('HTTP_CLIENT_IP') && (!ips.include? env['HTTP_CLIENT_IP'])\n        return false if env.include?('HTTP_X_REAL_IP') && (!ips.include? env['HTTP_X_REAL_IP'])\n\n        true\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/json_csrf.rb",
    "start_line": 26,
    "raw_source": "def call(env)\n        request               = Request.new(env)\n        status, headers, body = app.call(env)\n\n        if has_vector?(request, headers)\n          warn env, \"attack prevented by #{self.class}\"\n\n          react_and_close(env, body) or [status, headers, body]\n        else\n          [status, headers, body]\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/json_csrf.rb",
    "start_line": 39,
    "raw_source": "def has_vector?(request, headers)\n        return false if request.xhr?\n        return false if options[:allow_if]&.call(request.env)\n        return false unless headers['content-type'].to_s.split(';', 2).first =~ %r{^\\s*application/json\\s*$}\n\n        origin(request.env).nil? and referrer(request.env) != request.host\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/json_csrf.rb",
    "start_line": 47,
    "raw_source": "def react_and_close(env, body)\n        reaction = react(env)\n\n        close_body(body) if reaction\n\n        reaction\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/json_csrf.rb",
    "start_line": 55,
    "raw_source": "def close_body(body)\n        body.close if body.respond_to?(:close)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/path_traversal.rb",
    "start_line": 15,
    "raw_source": "def call(env)\n        path_was         = env['PATH_INFO']\n        env['PATH_INFO'] = cleanup path_was if path_was && !path_was.empty?\n        app.call env\n      ensure\n        env['PATH_INFO'] = path_was\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/path_traversal.rb",
    "start_line": 23,
    "raw_source": "def cleanup(path)\n        encoding = path.encoding\n        dot   = '.'.encode(encoding)\n        slash = '/'.encode(encoding)\n        backslash = '\\\\'.encode(encoding)\n\n        parts     = []\n        unescaped = path.gsub(/%2e/i, dot).gsub(/%2f/i, slash).gsub(/%5c/i, backslash)\n        unescaped = unescaped.gsub(backslash, slash)\n\n        unescaped.split(slash).each do |part|\n          next if part.empty? || (part == dot)\n\n          part == '..' ? parts.pop : parts << part\n        end\n\n        cleaned = slash + parts.join(slash)\n        cleaned << slash if parts.any? && unescaped =~ (%r{/\\.{0,2}$})\n        cleaned\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/referrer_policy.rb",
    "start_line": 20,
    "raw_source": "def call(env)\n        status, headers, body = @app.call(env)\n        headers['referrer-policy'] ||= options[:referrer_policy]\n        [status, headers, body]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/remote_referrer.rb",
    "start_line": 17,
    "raw_source": "def accepts?(env)\n        safe?(env) or referrer(env) == Request.new(env).host\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/remote_token.rb",
    "start_line": 19,
    "raw_source": "def accepts?(env)\n        super or referrer(env) == Request.new(env).host\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/session_hijacking.rb",
    "start_line": 21,
    "raw_source": "def accepts?(env)\n        session = session env\n        key     = options[:tracking_key]\n        if session.include? key\n          session[key].all? { |k, v| v == encode(env[k]) }\n        else\n          session[key] = {}\n          options[:track].each { |k| session[key][k] = encode(env[k]) }\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/session_hijacking.rb",
    "start_line": 32,
    "raw_source": "def encode(value)\n        value.to_s.downcase\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/strict_transport.rb",
    "start_line": 25,
    "raw_source": "def strict_transport\n        @strict_transport ||= begin\n          strict_transport = \"max-age=#{options[:max_age]}\"\n          strict_transport += '; includeSubDomains' if options[:include_subdomains]\n          strict_transport += '; preload' if options[:preload]\n          strict_transport.to_str\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/strict_transport.rb",
    "start_line": 34,
    "raw_source": "def call(env)\n        status, headers, body = @app.call(env)\n        headers['strict-transport-security'] ||= strict_transport\n        [status, headers, body]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/xss_header.rb",
    "start_line": 19,
    "raw_source": "def call(env)\n        status, headers, body = @app.call(env)\n        headers['x-xss-protection']       ||= \"1; mode=#{options[:xss_mode]}\" if html? headers\n        headers['x-content-type-options'] ||= 'nosniff'                       if options[:nosniff]\n        [status, headers, body]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/lib/rack/protection/host_authorization_spec.rb",
    "start_line": 8,
    "raw_source": "def assert_response(outcome:, headers:, last_response:)\n    fail_message = \"Expected outcome '#{outcome}' for headers '#{headers}' \" \\\n                   \"last_response.status '#{last_response.status}'\"\n\n    case outcome\n    when :allowed\n      expect(last_response).to be_ok, fail_message\n    when :stopped\n      expect(last_response.status).to eq(403), fail_message\n      expect(last_response.body).to eq('Host not permitted'), fail_message\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/lib/rack/protection/json_csrf_spec.rb",
    "start_line": 8,
    "raw_source": "def close\n        @closed = true\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/lib/rack/protection/json_csrf_spec.rb",
    "start_line": 12,
    "raw_source": "def closed?\n        @closed\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/lib/rack/protection/json_csrf_spec.rb",
    "start_line": 17,
    "raw_source": "def self.body\n      @body ||= begin\n        body = ['ok']\n        body.extend(Closeable)\n        body\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/lib/rack/protection/json_csrf_spec.rb",
    "start_line": 25,
    "raw_source": "def self.call(env)\n      Thread.current[:last_env] = env\n      [200, { 'content-type' => 'application/json' }, body]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/dummy_app.rb",
    "start_line": 4,
    "raw_source": "def self.call(env)\n    Thread.current[:last_env] = env\n    body = (env['REQUEST_METHOD'] == 'HEAD' ? '' : 'ok')\n    [200, { 'content-type' => env['wants'] || 'text/plain' }, [body]]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/not_implemented_as_pending.rb",
    "start_line": 5,
    "raw_source": "def self.included(base)\n    base.class_eval do\n      alias_method :__finish__, :finish\n      remove_method :finish\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/not_implemented_as_pending.rb",
    "start_line": 12,
    "raw_source": "def finish(reporter)\n    if @exception.is_a?(NotImplementedError)\n      from = @exception.backtrace[0]\n      message = \"#{@exception.message} (from #{from})\"\n      @pending_declared_in_example = message\n      metadata[:pending] = true\n      @exception = nil\n    end\n\n    __finish__(reporter)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/shared_examples.rb",
    "start_line": 16,
    "raw_source": "def call(env)\n        was = env.dup\n        res = app.call(env)\n        was.each do |k, v|\n          next if env[k] == v\n\n          raise \"env[#{k.inspect}] changed from #{v.inspect} to #{env[k].inspect}\"\n        end\n        res\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/shared_examples.rb",
    "start_line": 42,
    "raw_source": "def call(env)\n        env['foo.bar'] = 42\n        app.call(env)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/shared_examples.rb",
    "start_line": 48,
    "raw_source": "def call(env)\n        app.call(env)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/spec_helpers.rb",
    "start_line": 11,
    "raw_source": "def app\n    @app ||= nil\n    @app || mock_app(DummyApp)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/spec_helpers.rb",
    "start_line": 16,
    "raw_source": "def mock_app(app = nil, lint: true, &block)\n    app = block if app.nil? && (block.arity == 1)\n    if app\n      klass = described_class\n      mock_app do\n        use Rack::Head\n        use(Rack::Config) { |e| e['rack.session'] ||= {} }\n        use klass\n        run app\n      end\n    elsif lint\n      @app = Rack::Lint.new Rack::Builder.new(&block).to_app\n    else\n      @app = Rack::Builder.new(&block).to_app\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/spec_helpers.rb",
    "start_line": 33,
    "raw_source": "def with_headers(headers)\n    proc { [200, { 'content-type' => 'text/plain' }.merge(headers), ['ok']] }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/spec_helpers.rb",
    "start_line": 37,
    "raw_source": "def env\n    Thread.current[:last_env]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/capture.rb",
    "start_line": 87,
    "raw_source": "def capture(*args, &block)\n      return block[*args] if ruby?\n\n      if haml? && Tilt[:haml] == Tilt::HamlTemplate && defined?(Haml::Buffer)\n        buffer = Haml::Buffer.new(nil, Haml::Options.new.for_buffer)\n        with_haml_buffer(buffer) { capture_haml(*args, &block) }\n      else\n        buf_was = @_out_buf\n        @_out_buf = +''\n        begin\n          raw = block[*args]\n          captured = block.binding.eval('@_out_buf')\n          captured.empty? ? raw : captured\n        ensure\n          @_out_buf = buf_was\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/capture.rb",
    "start_line": 106,
    "raw_source": "def capture_later(&block)\n      engine = current_engine\n      proc { |*a| with_engine(engine) { @capture = capture(*a, &block) } }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/config_file.rb",
    "start_line": 111,
    "raw_source": "def self.registered(base)\n      base.set :environments, %w[test production development]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/config_file.rb",
    "start_line": 118,
    "raw_source": "def config_file(*paths)\n      Dir.chdir(root || '.') do\n        paths.each do |pattern|\n          Dir.glob(pattern) do |file|\n            raise UnsupportedConfigType unless ['.yml', '.yaml', '.erb'].include?(File.extname(file))\n\n            logger.info \"loading config file '#{file}'\" if logging? && respond_to?(:logger)\n            document = ERB.new(File.read(file)).result\n            yaml = YAML.respond_to?(:unsafe_load) ? YAML.unsafe_load(document) : YAML.load(document)\n            config = config_for_env(yaml)\n            config.each_pair { |key, value| set(key, value) }\n          end\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/config_file.rb",
    "start_line": 135,
    "raw_source": "def message\n        'Invalid config file type, use .yml, .yaml or .erb'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/config_file.rb",
    "start_line": 145,
    "raw_source": "def config_for_env(hash)\n      return from_environment_key(hash) if environment_keys?(hash)\n\n      hash.each_with_object(IndifferentHash[]) do |(k, v), acc|\n        if environment_keys?(v)\n          acc.merge!(k => v[environment.to_s]) if v.key?(environment.to_s)\n        else\n          acc.merge!(k => v)\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/config_file.rb",
    "start_line": 159,
    "raw_source": "def from_environment_key(hash)\n      hash[environment.to_s] || hash[environment.to_sym] || {}\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/config_file.rb",
    "start_line": 165,
    "raw_source": "def environment_keys?(hash)\n      hash.is_a?(Hash) && hash.any? { |k, _| environments.include?(k.to_s) }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/content_for.rb",
    "start_line": 132,
    "raw_source": "def content_for(key, value = nil, options = {}, &block)\n      block ||= proc { |*| value }\n      clear_content_for(key) if options[:flush]\n      content_blocks[key.to_sym] << capture_later(&block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/content_for.rb",
    "start_line": 148,
    "raw_source": "def content_for?(key)\n      content_blocks[key.to_sym].any?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/content_for.rb",
    "start_line": 155,
    "raw_source": "def clear_content_for(key)\n      content_blocks.delete(key.to_sym) if content_for?(key)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/content_for.rb",
    "start_line": 176,
    "raw_source": "def yield_content(key, *args, &block)\n      if block_given? && !content_for?(key)\n        haml? && Tilt[:haml] == Tilt::HamlTemplate && respond_to?(:capture_haml) ? capture_haml(*args, &block) : yield(*args)\n      else\n        content = content_blocks[key.to_sym].map { |b| capture(*args, &b) }\n        content.join.tap do |c|\n          if block_given? && (erb? || erubi?)\n            @_out_buf << c\n          end\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/content_for.rb",
    "start_line": 191,
    "raw_source": "def content_blocks\n      @content_blocks ||= Hash.new { |h, k| h[k] = [] }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/contrib/setup.rb",
    "start_line": 9,
    "raw_source": "def extensions\n        @extensions ||= { helpers: [], register: [] }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/contrib/setup.rb",
    "start_line": 13,
    "raw_source": "def register(name, path)\n        autoload name, path, :register\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/contrib/setup.rb",
    "start_line": 17,
    "raw_source": "def helpers(name, path)\n        autoload name, path, :helpers\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/contrib/setup.rb",
    "start_line": 21,
    "raw_source": "def autoload(name, path, method = nil)\n        extensions[method] << name if method\n        Sinatra.autoload(name, path)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/contrib/setup.rb",
    "start_line": 26,
    "raw_source": "def registered(base)\n        @extensions.each do |method, list|\n          list = list.map { |name| Sinatra.const_get name }\n          base.send(method, *list) unless base == ::Sinatra::Application\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/contrib/setup.rb",
    "start_line": 43,
    "raw_source": "def self.registered(base)\n        base.register Common, Custom\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/contrib/setup.rb",
    "start_line": 49,
    "raw_source": "def self.registered(base)\n      base.register Common, Custom\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 62,
    "raw_source": "def initialize(app)\n        @response_array  = nil\n        @response_hash   = {}\n        @response        = app.response\n        @request         = app.request\n        @deleted         = []\n\n        @options = {\n          path: @request.script_name.to_s.empty? ? '/' : @request.script_name,\n          domain: @request.host == 'localhost' ? nil : @request.host,\n          secure: @request.secure?,\n          httponly: true\n        }\n\n        return unless app.settings.respond_to? :cookie_options\n\n        @options.merge! app.settings.cookie_options\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 81,
    "raw_source": "def ==(other)\n        other.respond_to? :to_hash and to_hash == other.to_hash\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 85,
    "raw_source": "def [](key)\n        response_cookies[key.to_s] || request_cookies[key.to_s]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 89,
    "raw_source": "def []=(key, value)\n        set(key, value: value)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 94,
    "raw_source": "def assoc(key)\n          to_hash.assoc(key.to_s)\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 99,
    "raw_source": "def clear\n        each_key { |k| delete(k) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 103,
    "raw_source": "def compare_by_identity?\n        false\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 107,
    "raw_source": "def default\n        nil\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 113,
    "raw_source": "def delete(key)\n        result = self[key]\n        @response.delete_cookie(key.to_s, @options)\n        result\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 119,
    "raw_source": "def delete_if\n        return enum_for(__method__) unless block_given?\n\n        each { |k, v| delete(k) if yield(k, v) }\n        self\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 126,
    "raw_source": "def each(&block)\n        return enum_for(__method__) unless block_given?\n\n        to_hash.each(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 132,
    "raw_source": "def each_key(&block)\n        return enum_for(__method__) unless block_given?\n\n        to_hash.each_key(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 140,
    "raw_source": "def each_value(&block)\n        return enum_for(__method__) unless block_given?\n\n        to_hash.each_value(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 146,
    "raw_source": "def empty?\n        to_hash.empty?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 150,
    "raw_source": "def fetch(key, &block)\n        response_cookies.fetch(key.to_s) do\n          request_cookies.fetch(key.to_s, &block)\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 157,
    "raw_source": "def flatten\n          to_hash.flatten\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 162,
    "raw_source": "def has_key?(key)\n        response_cookies.key? key.to_s or request_cookies.key? key.to_s\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 166,
    "raw_source": "def has_value?(value)\n        response_cookies.value? value or request_cookies.value? value\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 170,
    "raw_source": "def hash\n        to_hash.hash\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 177,
    "raw_source": "def inspect\n        \"<##{self.class}: #{to_hash.inspect[1..-2]}>\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 182,
    "raw_source": "def invert\n          to_hash.invert\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 187,
    "raw_source": "def keep_if\n        return enum_for(__method__) unless block_given?\n\n        delete_if { |*a| !yield(*a) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 193,
    "raw_source": "def key(value)\n        to_hash.key(value)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 199,
    "raw_source": "def keys\n        to_hash.keys\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 203,
    "raw_source": "def length\n        to_hash.length\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 207,
    "raw_source": "def merge(other, &block)\n        to_hash.merge(other, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 211,
    "raw_source": "def merge!(other)\n        other.each_pair do |key, value|\n          self[key] = if block_given? && include?(key)\n                        yield(key.to_s, self[key], value)\n                      else\n                        value\n                      end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 221,
    "raw_source": "def rassoc(value)\n        to_hash.rassoc(value)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 225,
    "raw_source": "def rehash\n        response_cookies.rehash\n        request_cookies.rehash\n        self\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 231,
    "raw_source": "def reject(&block)\n        return enum_for(__method__) unless block_given?\n\n        to_hash.reject(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 239,
    "raw_source": "def replace(other)\n        select! { |k, _v| other.include?(k) or other.include?(k.to_s) }\n        merge! other\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 244,
    "raw_source": "def select(&block)\n        return enum_for(__method__) unless block_given?\n\n        to_hash.select(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 252,
    "raw_source": "def set(key, options = {})\n        @response.set_cookie key.to_s, @options.merge(options)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 256,
    "raw_source": "def shift\n        key, value = to_hash.shift\n        delete(key)\n        [key, value]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 265,
    "raw_source": "def sort(&block)\n          to_hash.sort(&block)\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 272,
    "raw_source": "def to_hash\n        request_cookies.merge(response_cookies)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 276,
    "raw_source": "def to_a\n        to_hash.to_a\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 280,
    "raw_source": "def to_s\n        to_hash.to_s\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 287,
    "raw_source": "def values\n        to_hash.values\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 291,
    "raw_source": "def values_at(*list)\n        list.map { |k| self[k] }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 297,
    "raw_source": "def warn(message)\n        super \"#{caller.first[/^[^:]:\\d+:/]} warning: #{message}\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 301,
    "raw_source": "def deleted\n        parse_response\n        @deleted\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 306,
    "raw_source": "def response_cookies\n        parse_response\n        @response_hash\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 311,
    "raw_source": "def parse_response\n        cookies_from_response = Array(@response['Set-Cookie'])\n        return if @response_array == cookies_from_response\n\n        hash = {}\n\n        cookies_from_response.each do |line|\n          key, value = line.split(';', 2).first.to_s.split('=', 2)\n          next if key.nil?\n\n          key = Rack::Utils.unescape(key)\n          if line =~ /expires=Thu, 01[-\\s]Jan[-\\s]1970/\n            @deleted << key\n          else\n            @deleted.delete key\n            hash[key] = value\n          end\n        end\n\n        @response_hash.replace hash\n        @response_array = cookies_from_response\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 334,
    "raw_source": "def request_cookies\n        @request.cookies.reject { |key, _value| deleted.include? key }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 339,
    "raw_source": "def cookies\n      @cookies ||= Jar.new(self)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/custom_logger.rb",
    "start_line": 51,
    "raw_source": "def logger\n      if settings.respond_to?(:logger)\n        settings.logger\n      else\n        request.logger\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 12,
    "raw_source": "def erb?\n      @current_engine == :erb\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 20,
    "raw_source": "def erubi?\n      @current_engine == :erubi or\n        (erb? && Tilt[:erb] == Tilt::ErubiTemplate)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 26,
    "raw_source": "def haml?\n      @current_engine == :haml\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 31,
    "raw_source": "def sass?\n      @current_engine == :sass\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 36,
    "raw_source": "def scss?\n      @current_engine == :scss\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 41,
    "raw_source": "def builder?\n      @current_engine == :builder\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 46,
    "raw_source": "def liquid?\n      @current_engine == :liquid\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 51,
    "raw_source": "def markdown?\n      @current_engine == :markdown\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 56,
    "raw_source": "def rdoc?\n      @current_engine == :rdoc\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 61,
    "raw_source": "def markaby?\n      @current_engine == :markaby\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 66,
    "raw_source": "def nokogiri?\n      @current_engine == :nokogiri\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 71,
    "raw_source": "def slim?\n      @current_engine == :slim\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 76,
    "raw_source": "def ruby?\n      @current_engine == :ruby\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 80,
    "raw_source": "def initialize(*)\n      @current_engine = :ruby\n      super\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 86,
    "raw_source": "def with_engine(engine)\n      engine_was = @current_engine\n      @current_engine = engine.to_sym\n      yield\n    ensure\n      @current_engine = engine_was\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 96,
    "raw_source": "def render(engine, *)\n      with_engine(engine) { super }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 51,
    "raw_source": "def self.new(&block)\n      ext = Module.new.extend(self)\n      ext.class_eval(&block)\n      ext\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 57,
    "raw_source": "def settings\n      self\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 61,
    "raw_source": "def configure(*args, &block)\n      record(:configure, *args) { |c| c.instance_exec(c, &block) }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 65,
    "raw_source": "def registered(base = nil, &block)\n      base ? replay(base) : record(:class_eval, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 71,
    "raw_source": "def record(method, *args, &block)\n      recorded_methods << [method, args, block]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 75,
    "raw_source": "def replay(object)\n      recorded_methods.each { |m, a, b| object.send(m, *a, &b) }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 79,
    "raw_source": "def recorded_methods\n      @recorded_methods ||= []\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 83,
    "raw_source": "def method_missing(method, *args, &block)\n      return super unless Sinatra::Base.respond_to? method\n\n      record(method, *args, &block)\n      DontCall.new(method)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 91,
    "raw_source": "def initialize(method) @method = method end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 92,
    "raw_source": "def method_missing(*) raise \"not supposed to use result of #{@method}!\" end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 93,
    "raw_source": "def inspect; \"#<#{self.class}: #{@method}>\" end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/haml_helpers.rb",
    "start_line": 32,
    "raw_source": "def surround(front, back = front, &block)\n      \"#{front}#{_capture_haml(&block).chomp}#{back}\\n\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/haml_helpers.rb",
    "start_line": 36,
    "raw_source": "def precede(str, &block)\n      \"#{str}#{_capture_haml(&block).chomp}\\n\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/haml_helpers.rb",
    "start_line": 40,
    "raw_source": "def succeed(str, &block)\n      \"#{_capture_haml(&block).chomp}#{str}\\n\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/haml_helpers.rb",
    "start_line": 44,
    "raw_source": "def _capture_haml(*args, &block)\n      capture(*args, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/json.rb",
    "start_line": 92,
    "raw_source": "def encode(object)\n        ::MultiJson.dump(object)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/json.rb",
    "start_line": 97,
    "raw_source": "def json(object, options = {})\n      content_type resolve_content_type(options)\n      resolve_encoder_action object, resolve_encoder(options)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/json.rb",
    "start_line": 104,
    "raw_source": "def resolve_content_type(options = {})\n      options[:content_type] || settings.json_content_type\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/json.rb",
    "start_line": 108,
    "raw_source": "def resolve_encoder(options = {})\n      options[:json_encoder] || settings.json_encoder\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/json.rb",
    "start_line": 112,
    "raw_source": "def resolve_encoder_action(object, encoder)\n      %i[encode generate].each do |method|\n        return encoder.send(method, object) if encoder.respond_to? method\n      end\n      raise \"#{encoder} does not respond to #generate nor #encode\" unless encoder.is_a? Symbol\n\n      object.__send__(encoder)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/link_header.rb",
    "start_line": 58,
    "raw_source": "def prefetch(*urls)\n      link(:prefetch, *urls)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/link_header.rb",
    "start_line": 64,
    "raw_source": "def stylesheet(*urls)\n      urls << {} unless urls.last.respond_to? :to_hash\n      urls.last[:type] ||= mime_type(:css)\n      link(:stylesheet, *urls)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/link_header.rb",
    "start_line": 83,
    "raw_source": "def link(*urls)\n      opts          = urls.last.respond_to?(:to_hash) ? urls.pop : {}\n      opts[:rel]    = urls.shift unless urls.first.respond_to? :to_str\n      options       = opts.map { |k, v| \" #{k}=#{v.to_s.inspect}\" }\n      html_pattern  = \"<link href=\\\"%s\\\"#{options.join} />\"\n      http_pattern  = ['<%s>', *options].join ';'\n      link          = (response['Link'] ||= '')\n\n      link = response['Link'] = +link\n\n      urls.map do |url|\n        link << \",\" unless link.empty?\n        link << (http_pattern % url)\n        html_pattern % url\n      end.join\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/link_header.rb",
    "start_line": 118,
    "raw_source": "def link_headers\n      yield if block_given?\n      return '' unless response.include? 'Link'\n\n      response['Link'].split(\",\").map do |line|\n        url, *opts = line.split(';').map(&:strip)\n        \"<link href=\\\"#{url[1..-2]}\\\" #{opts.join ' '} />\"\n      end.join\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/link_header.rb",
    "start_line": 128,
    "raw_source": "def self.registered(_base)\n      puts \"WARNING: #{self} is a helpers module, not an extension.\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 61,
    "raw_source": "def head(*args, &block)     super(*route_args(args), &block)  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 62,
    "raw_source": "def delete(*args, &block)   super(*route_args(args), &block)  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 63,
    "raw_source": "def get(*args, &block)      super(*route_args(args), &block)  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 64,
    "raw_source": "def options(*args, &block)  super(*route_args(args), &block)  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 65,
    "raw_source": "def patch(*args, &block)    super(*route_args(args), &block)  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 66,
    "raw_source": "def post(*args, &block)     super(*route_args(args), &block)  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 67,
    "raw_source": "def put(*args, &block)      super(*route_args(args), &block)  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 69,
    "raw_source": "def route(*args, &block)\n      options = Hash === args.last ? args.pop : {}\n      routes = [*args.pop]\n      args.each do |verb|\n        verb = verb.to_s.upcase if Symbol === verb\n        routes.each do |route|\n          super(verb, route, options, &block)\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 82,
    "raw_source": "def route_args(args)\n      options = Hash === args.last ? args.pop : {}\n      [args, options]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 189,
    "raw_source": "def self.new(base, pattern, conditions = {}, &block)\n      Module.new do\n        # quelch uninitialized variable warnings, since these get used by compile method.\n        @pattern = nil\n        @conditions = nil\n        extend NamespacedMethods\n        include InstanceMethods\n        @base = base\n        @extensions = []\n        @errors = {}\n        @pattern, @conditions = compile(pattern, conditions)\n        @templates            = Hash.new { |_h, k| @base.templates[k] }\n        namespace = self\n        before { extend(@namespace = namespace) }\n        class_eval(&block)\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 208,
    "raw_source": "def settings\n        @namespace\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 212,
    "raw_source": "def template_cache\n        super.fetch(:nested, @namespace) { TemplateCache.new }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 216,
    "raw_source": "def redirect_to(uri, *args)\n        redirect(\"#{@namespace.pattern}#{uri}\", *args)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 222,
    "raw_source": "def namespace(pattern, conditions = {}, &block)\n        Sinatra::Namespace.new(self, pattern, conditions, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 237,
    "raw_source": "def self.prefixed(*names)\n        names.each { |n| define_method(n) { |*a, &b| prefixed(n, *a, &b) } }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 243,
    "raw_source": "def helpers(*extensions, &block)\n        class_eval(&block) if block_given?\n        include(*extensions) if extensions.any?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 248,
    "raw_source": "def register(*extensions, &block)\n        extensions << Module.new(&block) if block_given?\n        @extensions += extensions\n        extensions.each do |extension|\n          extend extension\n          extension.registered(self) if extension.respond_to?(:registered)\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 257,
    "raw_source": "def invoke_hook(name, *args)\n        @extensions.each { |e| e.send(name, *args) if e.respond_to?(name) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 261,
    "raw_source": "def not_found(&block)\n        error(Sinatra::NotFound, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 265,
    "raw_source": "def errors\n        base.errors.merge(namespace_errors)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 269,
    "raw_source": "def namespace_errors\n        @errors\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 273,
    "raw_source": "def error(*codes, &block)\n        args  = Sinatra::Base.send(:compile!, 'ERROR', /.*/, block)\n        codes = codes.map { |c| Array(c) }.flatten\n        codes << Exception if codes.empty?\n        codes << Sinatra::NotFound if codes.include?(404)\n\n        codes.each do |c|\n          errors = @errors[c] ||= []\n          errors << args\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 285,
    "raw_source": "def respond_to(*args)\n        return @conditions[:provides] || base.respond_to if args.empty?\n\n        @conditions[:provides] = args\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 291,
    "raw_source": "def set(key, value = self, &block)\n        return key.each { |k, v| set(k, v) } if key.respond_to?(:each) && block.nil? && (value == self)\n        raise ArgumentError, \"may not set #{key}\" unless ([:views] + ALLOWED_ENGINES).include?(key)\n\n        block ||= proc { value }\n        singleton_class.send(:define_method, key, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 299,
    "raw_source": "def enable(*opts)\n        opts.each { |key| set(key, true) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 303,
    "raw_source": "def disable(*opts)\n        opts.each { |key| set(key, false) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 307,
    "raw_source": "def template(name, &block)\n        first_location = caller_locations.first\n        filename = first_location.path\n        line = first_location.lineno\n        templates[name] = [block, filename, line]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 314,
    "raw_source": "def layout(name = :layout, &block)\n        template name, &block\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 318,
    "raw_source": "def pattern\n        @pattern\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 324,
    "raw_source": "def app\n        base.respond_to?(:base) ? base.base : base\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 328,
    "raw_source": "def compile(pattern, conditions, default_pattern = nil)\n        if pattern.respond_to? :to_hash\n          conditions = conditions.merge pattern.to_hash\n          pattern = nil\n        end\n        base_pattern = @pattern\n        base_conditions = @conditions\n        pattern ||= default_pattern\n        [prefixed_path(base_pattern, pattern),\n         (base_conditions || {}).merge(conditions)]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 340,
    "raw_source": "def prefixed_path(a, b)\n        return a || b || /.*/ unless a && b\n        return Mustermann.new(b) if a == /.*/\n\n        Mustermann.new(a) + Mustermann.new(b)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 347,
    "raw_source": "def prefixed(method, pattern = nil, conditions = {}, &block)\n        default = %r{(?:/.*)?} if (method == :before) || (method == :after)\n        pattern, conditions = compile pattern, conditions, default\n        result = base.send(method, pattern, **conditions, &block)\n        invoke_hook :route_added, method.to_s.upcase, pattern, block\n        result\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 355,
    "raw_source": "def method_missing(method, *args, &block)\n        base.send(method, *args, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 359,
    "raw_source": "def respond_to?(method, include_private = false)\n        super || base.respond_to?(method, include_private)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 368,
    "raw_source": "def self.extended(base)\n      base.extend BaseMethods\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/quiet_logger.rb",
    "start_line": 37,
    "raw_source": "def self.registered(app)\n      quiet_logger_prefixes = begin\n        app.settings.quiet_logger_prefixes.join('|')\n      rescue StandardError\n        ''\n      end\n      return warn('You need to specify the paths you wish to exclude from logging via `set :quiet_logger_prefixes, %w(images css fonts)`') if quiet_logger_prefixes.empty?\n\n      const_set('QUIET_LOGGER_REGEX', %r(\\A/{0,2}(?:#{quiet_logger_prefixes})))\n      ::Rack::CommonLogger.prepend(\n        ::Module.new do\n          def log(env, *)\n            super unless env['PATH_INFO'] =~ QUIET_LOGGER_REGEX\n          end\n        end\n      )\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/quiet_logger.rb",
    "start_line": 48,
    "raw_source": "def log(env, *)\n            super unless env['PATH_INFO'] =~ QUIET_LOGGER_REGEX\n          end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 128,
    "raw_source": "def self.for(app)\n          @app_list_map[app]\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 133,
    "raw_source": "def initialize\n          @path_watcher_map = Hash.new do |hash, key|\n            hash[key] = Watcher.new(key)\n          end\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 142,
    "raw_source": "def watch(path, element)\n          watcher_for(path).elements << element\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 149,
    "raw_source": "def ignore(path)\n          watcher_for(path).ignore\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 155,
    "raw_source": "def watcher_for(path)\n          @path_watcher_map[File.expand_path(path)]\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 161,
    "raw_source": "def watchers\n          @path_watcher_map.values\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 167,
    "raw_source": "def updated\n          watchers.find_all(&:updated?)\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 175,
    "raw_source": "def initialize(path)\n        @ignore = nil\n        @path = path\n        @elements = []\n        update\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 183,
    "raw_source": "def updated?\n        !ignore? && !removed? && mtime != File.mtime(path)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 188,
    "raw_source": "def update\n        @mtime = File.mtime(path)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 194,
    "raw_source": "def inline_templates?\n        elements.any? { |element| element.type == :inline_templates }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 200,
    "raw_source": "def ignore\n        @ignore = true\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 206,
    "raw_source": "def ignore?\n        !!@ignore\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 211,
    "raw_source": "def removed?\n        !File.exist?(path)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 220,
    "raw_source": "def after_reload(&block)\n      @@after_reload << block\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 227,
    "raw_source": "def self.registered(klass)\n      @reloader_loaded_in ||= {}\n      return if @reloader_loaded_in[klass]\n\n      @reloader_loaded_in[klass] = true\n\n      klass.extend BaseMethods\n      klass.extend ExtensionMethods\n      klass.set(:reloader) { klass.development? }\n      klass.set(:reload_templates) { klass.reloader? }\n      klass.before do\n        if klass.reloader?\n          MUTEX_FOR_PERFORM.synchronize { Reloader.perform(klass) }\n        end\n      end\n      klass.set(:inline_templates, klass.app_file) if klass == Sinatra::Application\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 247,
    "raw_source": "def self.perform(klass)\n      reloaded_paths = []\n      Watcher::List.for(klass).updated.each do |watcher|\n        klass.set(:inline_templates, watcher.path) if watcher.inline_templates?\n        watcher.elements.each { |element| klass.deactivate(element) }\n        # Deletes all old elements.\n        watcher.elements.delete_if { true }\n        $LOADED_FEATURES.delete(watcher.path)\n        require watcher.path\n        watcher.update\n        reloaded_paths << watcher.path\n      end\n      return if reloaded_paths.empty?\n\n      @@after_reload.each do |block|\n        block.arity.zero? ? block.call : block.call(reloaded_paths)\n      end\n      # Prevents after_reload from increasing each time it's reloaded.\n      @@after_reload.delete_if do |blk|\n        path, = blk.source_location\n        path && reloaded_paths.include?(path)\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 274,
    "raw_source": "def run!(*args)\n        if settings.reloader?\n          super unless running?\n        else\n          super\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 288,
    "raw_source": "def compile!(verb, path, block, **options)\n        source_location = block.respond_to?(:source_location) ?\n          block.source_location.first : caller_files[1]\n        signature = super\n        watch_element(\n          source_location, :route, { verb: verb, signature: signature }\n        )\n        signature\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 302,
    "raw_source": "def inline_templates=(file = nil)\n        file = (caller_files[1] || File.expand_path($0)) if file.nil? || file == true\n        watch_element(file, :inline_templates)\n        super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 311,
    "raw_source": "def use(middleware, *args, &block)\n        path = caller_files[1] || File.expand_path($0)\n        watch_element(path, :middleware, [middleware, args, block])\n        super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 320,
    "raw_source": "def add_filter(type, path = nil, **options, &block)\n        source_location = block.respond_to?(:source_location) ?\n          block.source_location.first : caller_files[1]\n        result = super\n        watch_element(source_location, :\"#{type}_filter\", filters[type].last)\n        result\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 331,
    "raw_source": "def error(*codes, &block)\n        path = caller_files[1] || File.expand_path($0)\n        result = super\n        codes.each do |c|\n          watch_element(path, :error, code: c, handler: @errors[c])\n        end\n        result\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 343,
    "raw_source": "def register(*extensions, &block)\n        start_registering_extension\n        result = super\n        stop_registering_extension\n        result\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 352,
    "raw_source": "def inherited(subclass)\n        result = super\n        subclass.register Sinatra::Reloader\n        result\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 362,
    "raw_source": "def deactivate(element)\n        case element.type\n        when :route\n          verb      = element.representation[:verb]\n          signature = element.representation[:signature]\n          (routes[verb] ||= []).delete(signature)\n        when :middleware\n          @middleware.delete(element.representation)\n        when :before_filter\n          filters[:before].delete(element.representation)\n        when :after_filter\n          filters[:after].delete(element.representation)\n        when :error\n          code    = element.representation[:code]\n          handler = element.representation[:handler]\n          @errors.delete(code) if @errors[code] == handler\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 383,
    "raw_source": "def also_reload(*glob)\n        Dir[*glob].each { |path| Watcher::List.for(self).watch_file(path) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 389,
    "raw_source": "def dont_reload(*glob)\n        Dir[*glob].each { |path| Watcher::List.for(self).ignore(path) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 396,
    "raw_source": "def register_path; @register_path ||= nil; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 399,
    "raw_source": "def start_registering_extension\n        @register_path = caller_files[2]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 404,
    "raw_source": "def stop_registering_extension\n        @register_path = nil\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 409,
    "raw_source": "def registering_extension?\n        !register_path.nil?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 421,
    "raw_source": "def watch_element(path, type, representation = nil)\n        list = Watcher::List.for(self)\n        element = Watcher::Element.new(type, representation)\n        list.watch(path, element)\n        list.watch(register_path, element) if registering_extension?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/required_params.rb",
    "start_line": 49,
    "raw_source": "def required_params(*keys)\n      _required_params(params, *keys)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/required_params.rb",
    "start_line": 55,
    "raw_source": "def _required_params(p, *keys)\n      keys.each do |key|\n        if key.is_a?(Hash)\n          _required_params(p, *key.keys)\n          key.each do |k, v|\n            _required_params(p[k.to_s], v)\n          end\n        elsif key.is_a?(Array)\n          _required_params(p, *key)\n        else\n          halt 400 unless p.respond_to?(:key?) && p&.key?(key.to_s)\n        end\n      end\n      true\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 92,
    "raw_source": "def initialize(app)\n        @app = app\n        @map = {}\n        @generic = {}\n        @default = nil\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 99,
    "raw_source": "def on(type, &block)\n        @app.settings.mime_types(type).each do |mime|\n          case mime\n          when '*/*'            then @default     = block\n          when %r{^([^/]+)/\\*$} then @generic[$1] = block\n          else                       @map[mime]   = block\n          end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 109,
    "raw_source": "def finish\n        yield self if block_given?\n        mime_type = @app.content_type ||\n                    @app.request.preferred_type(@map.keys)  ||\n                    @app.request.preferred_type             ||\n                    'text/html'\n        type = mime_type.split(/\\s*;\\s*/, 2).first\n        handlers = [@map[type], @generic[type[%r{^[^/]+}]], @default].compact\n        handlers.each do |block|\n          if (result = block.call(type))\n            @app.content_type mime_type\n            @app.halt result\n          end\n        end\n        @app.halt 500, 'Unknown template engine'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 126,
    "raw_source": "def method_missing(method, *args, &block)\n        return super if args.any? || block.nil? || !@app.mime_type(method)\n\n        on(method, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 136,
    "raw_source": "def respond_with(template, object = nil, &block)\n        unless Symbol === template\n          object = template\n          template = nil\n        end\n        format = Format.new(self)\n        format.on '*/*' do |type|\n          exts = settings.ext_map[type]\n          exts << :xml if type.end_with? '+xml'\n          if template\n            args = template_cache.fetch(type, template) { template_for(template, exts) }\n            if args.any?\n              locals = { object: object }\n              locals.merge! object.to_hash if object.respond_to? :to_hash\n\n              renderer = args.first\n              options = args[1..] + [{ locals: locals }]\n\n              halt send(renderer, *options)\n            end\n          end\n          if object\n            exts.each do |ext|\n              halt json(object) if ext == :json\n              next unless object.respond_to? method = \"to_#{ext}\"\n\n              halt(*object.send(method))\n            end\n          end\n          false\n        end\n        format.finish(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 170,
    "raw_source": "def respond_to(&block)\n        Format.new(self).finish(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 176,
    "raw_source": "def template_for(name, exts)\n        # in production this is cached, so don't worry too much about runtime\n        possible = []\n        settings.template_engines[:all].each do |engine|\n          exts.each { |ext| possible << [engine, \"#{name}.#{ext}\"] }\n        end\n\n        exts.each do |ext|\n          settings.template_engines[ext].each { |e| possible << [e, name] }\n        end\n\n        possible.each do |engine, template|\n          klass = Tilt.default_mapping.template_map[engine.to_s] ||\n                  Tilt.lazy_map[engine.to_s].fetch(0, [])[0]\n\n          find_template(settings.views, template, klass) do |file|\n            next unless File.exist? file\n\n            return settings.rendering_method(engine) << template.to_sym\n          end\n        end\n        [] # nil or false would not be cached\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 201,
    "raw_source": "def remap_extensions\n      ext_map.clear\n      Rack::Mime::MIME_TYPES.each { |e, t| ext_map[t] << e[1..].to_sym }\n      ext_map['text/javascript'] << 'js'\n      ext_map['text/xml'] << 'xml'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 208,
    "raw_source": "def mime_type(*)\n      result = super\n      remap_extensions\n      result\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 214,
    "raw_source": "def respond_to(*formats)\n      @respond_to ||= nil\n\n      if formats.any?\n        @respond_to ||= []\n        @respond_to.concat formats\n      elsif @respond_to.nil? && superclass.respond_to?(:respond_to)\n        superclass.respond_to\n      else\n        @respond_to\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 227,
    "raw_source": "def rendering_method(engine)\n      return [engine] if Sinatra::Templates.method_defined? engine\n      return [:mab] if engine.to_sym == :markaby\n\n      %i[render engine]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 236,
    "raw_source": "def compile!(verb, path, block, **options)\n      options[:provides] ||= respond_to if respond_to\n      super\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 241,
    "raw_source": "def self.jrubyify(engs)\n      not_supported = [:markdown]\n      engs.each_key do |key|\n        engs[key].collect! { |eng| eng == :yajl ? :json_pure : eng }\n        engs[key].delete_if { |eng| not_supported.include?(eng) }\n      end\n      engs\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 250,
    "raw_source": "def self.engines\n      engines = {\n        css: %i[sass scss],\n        xml: %i[builder nokogiri],\n        html: %i[erb erubi haml hamlit slim liquid\n                 mab markdown rdoc],\n        all: (Sinatra::Templates.instance_methods.map(&:to_sym) +\n          [:mab] - %i[find_template markaby]),\n        json: [:yajl]\n      }\n      engines.default = []\n      defined?(JRUBY_VERSION) ? jrubyify(engines) : engines\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 264,
    "raw_source": "def self.registered(base)\n      base.set :ext_map, Hash.new { |h, k| h[k] = [] }\n      base.set :template_engines, engines\n      base.remap_extensions\n      base.helpers Helpers\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 53,
    "raw_source": "def app_file\n      File.expand_path('server.rb', __dir__)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 57,
    "raw_source": "def run\n      @pipe     = start\n      @started  = Time.now\n      warn \"#{server} up and running on port #{port}\" if ping\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 63,
    "raw_source": "def kill\n      return unless pipe\n\n      Process.kill('KILL', pipe.pid)\n    rescue NotImplementedError\n      system \"kill -9 #{pipe.pid}\"\n    rescue Errno::ESRCH\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 72,
    "raw_source": "def get(url)\n      Timeout.timeout(1) { get_url(\"#{protocol}://127.0.0.1:#{port}#{url}\") }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 76,
    "raw_source": "def get_stream(url = '/stream', &block)\n      Net::HTTP.start '127.0.0.1', port do |http|\n        request = Net::HTTP::Get.new url\n        http.request request do |response|\n          response.read_body(&block)\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 85,
    "raw_source": "def get_response(url)\n      Net::HTTP.start '127.0.0.1', port do |http|\n        request = Net::HTTP::Get.new url\n        http.request request do |response|\n          response\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 94,
    "raw_source": "def log\n      @log ||= +''\n      loop { @log << pipe.read_nonblock(1) }\n    rescue Exception\n      @log\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 105,
    "raw_source": "def start\n      IO.popen(command)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 110,
    "raw_source": "def command\n      \"bundle exec ruby #{app_file} -p #{port} -e production\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 114,
    "raw_source": "def ping(timeout = 30)\n      loop do\n        return if alive?\n\n        if Time.now - @started > timeout\n          warn command, log\n          raise \"timeout starting server with command '#{command}'\"\n        else\n          sleep 0.1\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 127,
    "raw_source": "def alive?\n      3.times { get(ping_path) }\n      true\n    rescue EOFError, SystemCallError, OpenURI::HTTPError, Timeout::Error\n      false\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 135,
    "raw_source": "def ping_path\n      '/ping'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 140,
    "raw_source": "def port\n      4567\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 144,
    "raw_source": "def protocol\n      'http'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 148,
    "raw_source": "def get_url(url)\n      uri = URI.parse(url)\n\n      return uri.read unless protocol == 'https'\n\n      get_https_url(uri)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 156,
    "raw_source": "def get_https_url(uri)\n      http = Net::HTTP.new(uri.host, uri.port)\n      http.use_ssl      = true\n      http.verify_mode  = OpenSSL::SSL::VERIFY_NONE\n      request = Net::HTTP::Get.new(uri.request_uri)\n      http.request(request).body\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 79,
    "raw_source": "def stream(*)\n      stream = super\n      stream.extend Stream\n      stream.app = self\n      env['async.close'].callback { stream.close } if env.key? 'async.close'\n      stream\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 92,
    "raw_source": "def self.extended(obj)\n        obj.closed = false\n        obj.lineno = 0\n        obj.pos = 0\n        obj.callback { obj.closed = true }\n        obj.errback  { obj.closed = true }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 100,
    "raw_source": "def <<(data)\n        raise IOError, 'not opened for writing' if closed?\n\n        @transformer ||= nil\n        data = data.to_s\n        data = @transformer[data] if @transformer\n        @pos += data.bytesize\n        super(data)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 110,
    "raw_source": "def each\n        # that way body.each.map { ... } works\n        return self unless block_given?\n\n        super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 117,
    "raw_source": "def map(&block)\n        # dup would not copy the mixin\n        clone.map!(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 122,
    "raw_source": "def map!(&block)\n        @transformer ||= nil\n\n        if @transformer\n          inner = @transformer\n          outer = block\n          block = proc { |value| outer[inner[value]] }\n        end\n        @transformer = block\n        self\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 134,
    "raw_source": "def write(data)\n        self << data\n        data.to_s.bytesize\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 142,
    "raw_source": "def print(*args)\n        args.each { |arg| self << arg }\n        nil\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 147,
    "raw_source": "def printf(format, *args)\n        print(format.to_s % args)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 151,
    "raw_source": "def putc(c)\n        print c.chr\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 155,
    "raw_source": "def puts(*args)\n        args.each { |arg| self << \"#{arg}\\n\" }\n        nil\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 160,
    "raw_source": "def close_read\n        raise IOError, 'closing non-duplex IO for reading'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 164,
    "raw_source": "def closed_read?\n        true\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 168,
    "raw_source": "def closed_write?\n        closed?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 172,
    "raw_source": "def external_encoding\n        Encoding.find settings.default_encoding\n      rescue NameError\n        settings.default_encoding\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 178,
    "raw_source": "def settings\n        app.settings\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 182,
    "raw_source": "def rewind\n        @pos = @lineno = 0\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 186,
    "raw_source": "def not_open_for_reading(*)\n        raise IOError, 'not opened for reading'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 208,
    "raw_source": "def enum_not_open_for_reading(*)\n        not_open_for_reading if block_given?\n        enum_for(:not_open_for_reading)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 220,
    "raw_source": "def dummy(*) end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 227,
    "raw_source": "def seek(*)\n        0\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 233,
    "raw_source": "def sync\n        true\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 237,
    "raw_source": "def tty?\n        false\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 123,
    "raw_source": "def mock_app(base = Sinatra::Base, &block)\n      inner = nil\n      @app  = Sinatra.new(base) do\n        inner = self\n        class_eval(&block)\n      end\n      @settings = inner\n      app\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 136,
    "raw_source": "def app=(base)\n      @app = base\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 151,
    "raw_source": "def app\n      @app ||= Class.new Sinatra::Base\n      Rack::Lint.new @app\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 162,
    "raw_source": "def options(uri, params = {}, env = {}, &block)\n        env = env_for(uri, env.merge(method: 'OPTIONS', params: params))\n        current_session.send(:process_request, uri, env, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 174,
    "raw_source": "def patch(uri, params = {}, env = {}, &block)\n        env = env_for(uri, env.merge(method: 'PATCH', params: params))\n        current_session.send(:process_request, uri, env, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 181,
    "raw_source": "def last_request?\n      last_request\n      true\n    rescue Rack::Test::Error\n      false\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 190,
    "raw_source": "def session\n      return {} unless last_request?\n      raise Rack::Test::Error, 'session not enabled for app' unless last_env['rack.session'] || app.session?\n\n      last_request.session\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 198,
    "raw_source": "def last_env\n      last_request.env\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 34,
    "raw_source": "def self.registered(_)\n      Sinatra::Request.include WebDAV::Request\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 39,
    "raw_source": "def self.included(base)\n        base.class_eval do\n          alias_method :_safe?, :safe?\n          alias_method :_idempotent?, :idempotent?\n\n          def safe?\n            _safe? or propfind?\n          end\n\n          def idempotent?\n            _idempotent? or propfind? or move? or unlock? # or lock?\n          end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 44,
    "raw_source": "def safe?\n            _safe? or propfind?\n          end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 48,
    "raw_source": "def idempotent?\n            _idempotent? or propfind? or move? or unlock? # or lock?\n          end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 54,
    "raw_source": "def propfind?\n        request_method == 'PROPFIND'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 58,
    "raw_source": "def proppatch?\n        request_method == 'PROPPATCH'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 62,
    "raw_source": "def mkcol?\n        request_method == 'MKCOL'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 66,
    "raw_source": "def copy?\n        request_method == 'COPY'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 70,
    "raw_source": "def move?\n        request_method == 'MOVE'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 78,
    "raw_source": "def unlock?\n        request_method == 'UNLOCK'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 83,
    "raw_source": "def propfind(path, opts = {}, &bk)  route 'PROPFIND',  path, opts, &bk end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 84,
    "raw_source": "def proppatch(path, opts = {}, &bk) route 'PROPPATCH', path, opts, &bk end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 85,
    "raw_source": "def mkcol(path, opts = {}, &bk)     route 'MKCOL',     path, opts, &bk end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 86,
    "raw_source": "def copy(path, opts = {}, &bk)      route 'COPY',      path, opts, &bk end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 87,
    "raw_source": "def move(path, opts = {}, &bk)      route 'MOVE',      path, opts, &bk end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 89,
    "raw_source": "def unlock(path, opts = {}, &bk)    route 'UNLOCK',    path, opts, &bk end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/capture_spec.rb",
    "start_line": 17,
    "raw_source": "def render(engine, template)\n    subject.send(:render, engine, template.to_sym).strip.gsub(/\\s+/, ' ')\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/config_file_spec.rb",
    "start_line": 4,
    "raw_source": "def config_file(*args, &block)\n    mock_app do\n      register Sinatra::ConfigFile\n      set :root, File.expand_path('config_file', __dir__)\n      instance_eval(&block) if block\n      config_file(*args)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/content_for_spec.rb",
    "start_line": 17,
    "raw_source": "def render(engine, template)\n    subject.send(:render, engine, template, :layout => false).gsub(/\\s/, '')\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/content_for_spec.rb",
    "start_line": 202,
    "raw_source": "def body\n            last_response.body.gsub(/\\s/, '')\n          end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/cookies_spec.rb",
    "start_line": 4,
    "raw_source": "def cookie_route(*cookies, headers: {}, &block)\n    result = nil\n    set_cookie(cookies)\n    @cookie_app.get('/') do\n      result = instance_eval(&block)\n      \"ok\"\n    end\n    get '/', {}, headers || {}\n    expect(last_response).to be_ok\n    expect(body).to eq(\"ok\")\n    result\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/cookies_spec.rb",
    "start_line": 17,
    "raw_source": "def cookies(*set_cookies)\n    cookie_route(*set_cookies) { cookies }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/json_spec.rb",
    "start_line": 33,
    "raw_source": "def mock_app(&block)\n    super do\n      class_eval(&block)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/json_spec.rb",
    "start_line": 39,
    "raw_source": "def results_in(obj)\n    expect(OkJson.decode(get('/').body)).to eq(obj)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/json_spec.rb",
    "start_line": 68,
    "raw_source": "def enc.generate(obj) obj.inspect end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/json_spec.rb",
    "start_line": 75,
    "raw_source": "def enc.encode(obj) obj.inspect end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/json_spec.rb",
    "start_line": 87,
    "raw_source": "def enc.generate(obj) obj.inspect end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/json_spec.rb",
    "start_line": 97,
    "raw_source": "def enc.encode(obj) obj.inspect end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 6,
    "raw_source": "def mock_app(&block)\n    super do\n      register Sinatra::Namespace\n      class_eval(&block)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 13,
    "raw_source": "def namespace(*args, &block)\n    mock_app { namespace(*args, &block) }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 142,
    "raw_source": "def foo\n                  'foo'\n                end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 336,
    "raw_source": "def magic\n                42\n              end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 352,
    "raw_source": "def magic\n              42\n            end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 367,
    "raw_source": "def magic\n              42\n            end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 386,
    "raw_source": "def magic\n                42\n              end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 405,
    "raw_source": "def magic\n              42\n            end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 429,
    "raw_source": "def magic\n                42\n              end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 448,
    "raw_source": "def magic\n                42\n              end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 454,
    "raw_source": "def magic\n                super - 19\n              end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 497,
    "raw_source": "def magic\n                42\n              end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 516,
    "raw_source": "def magic\n                42\n              end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 844,
    "raw_source": "def dump_args(*args)\n            args.inspect\n          end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 851,
    "raw_source": "def dump_args(*args)\n              super(:foo, *args)\n            end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 860,
    "raw_source": "def dump_args(*args)\n              super(:foo_bar, *args)\n            end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 40,
    "raw_source": "def decode(s)\n    ts = lex(s)\n    v, ts = textparse(ts)\n    if ts.length > 0\n      raise Error, 'trailing garbage'\n    end\n    v\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 54,
    "raw_source": "def textparse(ts)\n    if ts.length < 0\n      raise Error, 'empty'\n    end\n\n    typ, _, val = ts[0]\n    case typ\n    when '{' then objparse(ts)\n    when '[' then arrparse(ts)\n    else\n      raise Error, \"unexpected #{val.inspect}\"\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 71,
    "raw_source": "def valparse(ts)\n    if ts.length < 0\n      raise Error, 'empty'\n    end\n\n    typ, _, val = ts[0]\n    case typ\n    when '{' then objparse(ts)\n    when '[' then arrparse(ts)\n    when :val,:str then [val, ts[1..-1]]\n    else\n      raise Error, \"unexpected #{val.inspect}\"\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 89,
    "raw_source": "def objparse(ts)\n    ts = eat('{', ts)\n    obj = {}\n\n    if ts[0][0] == '}'\n      return obj, ts[1..-1]\n    end\n\n    k, v, ts = pairparse(ts)\n    obj[k] = v\n\n    if ts[0][0] == '}'\n      return obj, ts[1..-1]\n    end\n\n    loop do\n      ts = eat(',', ts)\n\n      k, v, ts = pairparse(ts)\n      obj[k] = v\n\n      if ts[0][0] == '}'\n        return obj, ts[1..-1]\n      end\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 119,
    "raw_source": "def pairparse(ts)\n    (typ, _, k), ts = ts[0], ts[1..-1]\n    if typ != :str\n      raise Error, \"unexpected #{k.inspect}\"\n    end\n    ts = eat(':', ts)\n    v, ts = valparse(ts)\n    [k, v, ts]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 132,
    "raw_source": "def arrparse(ts)\n    ts = eat('[', ts)\n    arr = []\n\n    if ts[0][0] == ']'\n      return arr, ts[1..-1]\n    end\n\n    v, ts = valparse(ts)\n    arr << v\n\n    if ts[0][0] == ']'\n      return arr, ts[1..-1]\n    end\n\n    loop do\n      ts = eat(',', ts)\n\n      v, ts = valparse(ts)\n      arr << v\n\n      if ts[0][0] == ']'\n        return arr, ts[1..-1]\n      end\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 160,
    "raw_source": "def eat(typ, ts)\n    if ts[0][0] != typ\n      raise Error, \"expected #{typ} (got #{ts[0].inspect})\"\n    end\n    ts[1..-1]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 170,
    "raw_source": "def lex(s)\n    ts = []\n    while s.length > 0\n      typ, lexeme, val = tok(s)\n      if typ == nil\n        raise Error, \"invalid character at #{s[0,10].inspect}\"\n      end\n      if typ != :space\n        ts << [typ, lexeme, val]\n      end\n      s = s[lexeme.length..-1]\n    end\n    ts\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 199,
    "raw_source": "def tok(s)\n    case s[0]\n    when ?{  then ['{', s[0,1], s[0,1]]\n    when ?}  then ['}', s[0,1], s[0,1]]\n    when ?:  then [':', s[0,1], s[0,1]]\n    when ?,  then [',', s[0,1], s[0,1]]\n    when ?[  then ['[', s[0,1], s[0,1]]\n    when ?]  then [']', s[0,1], s[0,1]]\n    when ?n  then nulltok(s)\n    when ?t  then truetok(s)\n    when ?f  then falsetok(s)\n    when ?\"  then strtok(s)\n    when Spc then [:space, s[0,1], s[0,1]]\n    when ?\\t then [:space, s[0,1], s[0,1]]\n    when ?\\n then [:space, s[0,1], s[0,1]]\n    when ?\\r then [:space, s[0,1], s[0,1]]\n    else          numtok(s)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 220,
    "raw_source": "def nulltok(s);  s[0,4] == 'null'  && [:val, 'null',  nil]   end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 221,
    "raw_source": "def truetok(s);  s[0,4] == 'true'  && [:val, 'true',  true]  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 222,
    "raw_source": "def falsetok(s); s[0,5] == 'false' && [:val, 'false', false] end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 225,
    "raw_source": "def numtok(s)\n    m = /-?([1-9][0-9]+|[0-9])([.][0-9]+)?([eE][+-]?[0-9]+)?/.match(s)\n    if m && m.begin(0) == 0\n      if m[3] && !m[2]\n        [:val, m[0], Integer(m[1])*(10**Integer(m[3][1..-1]))]\n      elsif m[2]\n        [:val, m[0], Float(m[0])]\n      else\n        [:val, m[0], Integer(m[0])]\n      end\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 239,
    "raw_source": "def strtok(s)\n    m = /\"([^\"\\\\]|\\\\[\"\\/\\\\bfnrt]|\\\\u[0-9a-fA-F]{4})*\"/.match(s)\n    if ! m\n      raise Error, \"invalid string literal at #{abbrev(s)}\"\n    end\n    [:str, m[0], unquote(m[0])]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 248,
    "raw_source": "def abbrev(s)\n    t = s[0,10]\n    p = t['`']\n    t = t[0,p] if p\n    t = t + '...' if t.length < s.length\n    '`' + t + '`'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 260,
    "raw_source": "def unquote(q)\n    q = q[1...-1]\n    a = q.dup # allocate a big enough string\n    r, w = 0, 0\n    while r < q.length\n      c = q[r]\n      case true\n      when c == ?\\\\\n        r += 1\n        if r >= q.length\n          raise Error, \"string literal ends with a \\\"\\\\\\\": \\\"#{q}\\\"\"\n        end\n\n        case q[r]\n        when ?\",?\\\\,?/,?'\n          a[w] = q[r]\n          r += 1\n          w += 1\n        when ?b,?f,?n,?r,?t\n          a[w] = Unesc[q[r]]\n          r += 1\n          w += 1\n        when ?u\n          r += 1\n          uchar = begin\n            hexdec4(q[r,4])\n          rescue RuntimeError => e\n            raise Error, \"invalid escape sequence \\\\u#{q[r,4]}: #{e}\"\n          end\n          r += 4\n          if surrogate? uchar\n            if q.length >= r+6\n              uchar1 = hexdec4(q[r+2,4])\n              uchar = subst(uchar, uchar1)\n              if uchar != Ucharerr\n                # A valid pair; consume.\n                r += 6\n              end\n            end\n          end\n          w += ucharenc(a, w, uchar)\n        else\n          raise Error, \"invalid escape char #{q[r]} in \\\"#{q}\\\"\"\n        end\n      when c == ?\", c < Spc\n        raise Error, \"invalid character in string literal \\\"#{q}\\\"\"\n      else\n        # Copy anything else byte-for-byte.\n        # Valid UTF-8 will remain valid UTF-8.\n        # Invalid UTF-8 will remain invalid UTF-8.\n        a[w] = c\n        r += 1\n        w += 1\n      end\n    end\n    a[0,w]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 322,
    "raw_source": "def ucharenc(a, i, u)\n    case true\n    when u <= Uchar1max\n      a[i] = (u & 0xff).chr\n      1\n    when u <= Uchar2max\n      a[i+0] = (Utag2 | ((u>>6)&0xff)).chr\n      a[i+1] = (Utagx | (u&Umaskx)).chr\n      2\n    when u <= Uchar3max\n      a[i+0] = (Utag3 | ((u>>12)&0xff)).chr\n      a[i+1] = (Utagx | ((u>>6)&Umaskx)).chr\n      a[i+2] = (Utagx | (u&Umaskx)).chr\n      3\n    else\n      a[i+0] = (Utag4 | ((u>>18)&0xff)).chr\n      a[i+1] = (Utagx | ((u>>12)&Umaskx)).chr\n      a[i+2] = (Utagx | ((u>>6)&Umaskx)).chr\n      a[i+3] = (Utagx | (u&Umaskx)).chr\n      4\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 346,
    "raw_source": "def hexdec4(s)\n    if s.length != 4\n      raise Error, 'short'\n    end\n    (nibble(s[0])<<12) | (nibble(s[1])<<8) | (nibble(s[2])<<4) | nibble(s[3])\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 354,
    "raw_source": "def subst(u1, u2)\n    if Usurr1 <= u1 && u1 < Usurr2 && Usurr2 <= u2 && u2 < Usurr3\n      return ((u1-Usurr1)<<10) | (u2-Usurr2) + Usurrself\n    end\n    return Ucharerr\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 362,
    "raw_source": "def unsubst(u)\n    if u < Usurrself || u > Umax || surrogate?(u)\n      return Ucharerr, Ucharerr\n    end\n    u -= Usurrself\n    [Usurr1 + ((u>>10)&0x3ff), Usurr2 + (u&0x3ff)]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 371,
    "raw_source": "def surrogate?(u)\n    Usurr1 <= u && u < Usurr3\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 376,
    "raw_source": "def nibble(c)\n    case true\n    when ?0 <= c && c <= ?9 then c.ord - ?0.ord\n    when ?a <= c && c <= ?z then c.ord - ?a.ord + 10\n    when ?A <= c && c <= ?Z then c.ord - ?A.ord + 10\n    else\n      raise Error, \"invalid hex code #{c}\"\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 396,
    "raw_source": "def encode(x)\n    case x\n    when Hash    then objenc(x)\n    when Array   then arrenc(x)\n    else\n      raise Error, 'root value must be an Array or a Hash'\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 406,
    "raw_source": "def valenc(x)\n    case x\n    when Hash    then objenc(x)\n    when Array   then arrenc(x)\n    when String  then strenc(x)\n    when Numeric then numenc(x)\n    when true    then \"true\"\n    when false   then \"false\"\n    when nil     then \"null\"\n    else\n      raise Error, \"cannot encode #{x.class}: #{x.inspect}\"\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 421,
    "raw_source": "def objenc(x)\n    '{' + x.map{|k,v| keyenc(k) + ':' + valenc(v)}.join(',') + '}'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 426,
    "raw_source": "def arrenc(a)\n    '[' + a.map{|x| valenc(x)}.join(',') + ']'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 431,
    "raw_source": "def keyenc(k)\n    case k\n    when String then strenc(k)\n    else\n      raise Error, \"Hash key is not a string: #{k.inspect}\"\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 440,
    "raw_source": "def strenc(s)\n    t = StringIO.new\n    t.putc(?\")\n    r = 0\n    while r < s.length\n      case s[r]\n      when ?\"  then t.print('\\\\\"')\n      when ?\\\\ then t.print('\\\\\\\\')\n      when ?\\b then t.print('\\\\b')\n      when ?\\f then t.print('\\\\f')\n      when ?\\n then t.print('\\\\n')\n      when ?\\r then t.print('\\\\r')\n      when ?\\t then t.print('\\\\t')\n      else\n        c = s[r]\n        case true\n        when Spc <= c && c <= ?~\n          t.putc(c)\n        when true\n          u, size = uchardec(s, r)\n          r += size - 1 # we add one more at the bottom of the loop\n          if u < 0x10000\n            t.print('\\\\u')\n            hexenc4(t, u)\n          else\n            u1, u2 = unsubst(u)\n            t.print('\\\\u')\n            hexenc4(t, u1)\n            t.print('\\\\u')\n            hexenc4(t, u2)\n          end\n        else\n          # invalid byte; skip it\n        end\n      end\n      r += 1\n    end\n    t.putc(?\")\n    t.string\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 482,
    "raw_source": "def hexenc4(t, u)\n    t.putc(Hex[(u>>12)&0xf])\n    t.putc(Hex[(u>>8)&0xf])\n    t.putc(Hex[(u>>4)&0xf])\n    t.putc(Hex[u&0xf])\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 490,
    "raw_source": "def numenc(x)\n    if x.nan? || x.infinite?\n      return 'null'\n    end rescue nil\n    \"#{x}\"\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 501,
    "raw_source": "def uchardec(s, i)\n    n = s.length - i\n    return [Ucharerr, 1] if n < 1\n\n    c0 = s[i].ord\n\n    # 1-byte, 7-bit sequence?\n    if c0 < Utagx\n      return [c0, 1]\n    end\n\n    # unexpected continuation byte?\n    return [Ucharerr, 1] if c0 < Utag2\n\n    # need continuation byte\n    return [Ucharerr, 1] if n < 2\n    c1 = s[i+1].ord\n    return [Ucharerr, 1] if c1 < Utagx || Utag2 <= c1\n\n    # 2-byte, 11-bit sequence?\n    if c0 < Utag3\n      u = (c0&Umask2)<<6 | (c1&Umaskx)\n      return [Ucharerr, 1] if u <= Uchar1max\n      return [u, 2]\n    end\n\n    # need second continuation byte\n    return [Ucharerr, 1] if n < 3\n    c2 = s[i+2].ord\n    return [Ucharerr, 1] if c2 < Utagx || Utag2 <= c2\n\n    # 3-byte, 16-bit sequence?\n    if c0 < Utag4\n      u = (c0&Umask3)<<12 | (c1&Umaskx)<<6 | (c2&Umaskx)\n      return [Ucharerr, 1] if u <= Uchar2max\n      return [u, 3]\n    end\n\n    # need third continuation byte\n    return [Ucharerr, 1] if n < 4\n    c3 = s[i+3].ord\n    return [Ucharerr, 1] if c3 < Utagx || Utag2 <= c3\n\n    # 4-byte, 21-bit sequence?\n    if c0 < Utag5\n      u = (c0&Umask4)<<18 | (c1&Umaskx)<<12 | (c2&Umaskx)<<6 | (c3&Umaskx)\n      return [Ucharerr, 1] if u <= Uchar3max\n      return [u, 4]\n    end\n\n    return [Ucharerr, 1]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 6,
    "raw_source": "def tmp_dir\n    File.expand_path('../tmp', __dir__)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 12,
    "raw_source": "def app_file_path\n    File.join(tmp_dir, \"example_app_#{$example_app_counter}.rb\")\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 19,
    "raw_source": "def app_name\n    \"ExampleApp#{$example_app_counter}\"\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 25,
    "raw_source": "def app_const\n    Module.const_get(app_name)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 39,
    "raw_source": "def write_app_file(options={})\n    options[:routes] ||= ['get(\"/foo\") { erb :foo }']\n    options[:inline_templates] ||= nil\n    options[:extensions] ||= []\n    options[:middlewares] ||= []\n    options[:filters] ||= []\n    options[:errors] ||= {}\n    options[:name] ||= app_name\n    options[:enable_reloader] = true unless options[:enable_reloader] === false\n    options[:parent] ||= 'Sinatra::Base'\n\n    update_file(app_file_path) do |f|\n      template_path = File.expand_path('reloader/app.rb.erb', __dir__)\n      template = Tilt.new(template_path, nil, :trim => '<>')\n      f.write template.render(Object.new, options)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 61,
    "raw_source": "def update_file(path, &block)\n    original_mtime = File.exist?(path) ? File.mtime(path) : Time.at(0)\n    new_time = original_mtime + 1\n    File.open(path, 'w', &block)\n    File.utime(new_time, new_time, path)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 71,
    "raw_source": "def setup_example_app(options={})\n    $example_app_counter ||= 0\n    $example_app_counter += 1\n\n    FileUtils.mkdir_p(tmp_dir)\n    write_app_file(options)\n    $LOADED_FEATURES.delete app_file_path\n    require app_file_path\n    self.app = app_const\n    app_const.enable :reloader\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 261,
    "raw_source": "def self.registered(klass)\n          klass.get('/bar') { 'bar' }\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 282,
    "raw_source": "def self.registered(klass)\n          klass.use Rack::Head\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 303,
    "raw_source": "def self.registered(klass)\n          klass.before { @hi = 'hi' }\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 324,
    "raw_source": "def self.registered(klass)\n          klass.after { @bye = 'bye' }\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/respond_with_spec.rb",
    "start_line": 7,
    "raw_source": "def respond_app(&block)\n    mock_app do\n      set :app_file, __FILE__\n      set :views, root + '/respond_with'\n      register Sinatra::RespondWith\n      class_eval(&block)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/respond_with_spec.rb",
    "start_line": 16,
    "raw_source": "def respond_to(*args, &block)\n    respond_app { get('/') { respond_to(*args, &block) } }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/respond_with_spec.rb",
    "start_line": 20,
    "raw_source": "def respond_with(*args, &block)\n    respond_app { get('/') { respond_with(*args, &block) } }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/respond_with_spec.rb",
    "start_line": 24,
    "raw_source": "def req(*types)\n    path = types.shift if types.first.is_a?(String) && types.first.start_with?('/')\n    accept = types.map { |t| Sinatra::Base.mime_type(t).to_s }.join ','\n    get (path || '/'), {}, 'HTTP_ACCEPT' => accept\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/respond_with_spec.rb",
    "start_line": 221,
    "raw_source": "def object.to_pdf; \"hi\" end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 4,
    "raw_source": "def stream(&block)\n    rack_middleware = @use\n    out = nil\n    mock_app do\n      rack_middleware.each { |args| use(*args) }\n      helpers Sinatra::Streaming\n      get('/') { out = stream(&block) }\n    end\n    get('/')\n    out\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 16,
    "raw_source": "def use(*args)\n    @use << args\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 147,
    "raw_source": "def initialize(app) @app = app end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 148,
    "raw_source": "def call(env)\n          status, headers, body = @app.call(env)\n          body.map! { |s| s.upcase }\n          [status, headers, body]\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 172,
    "raw_source": "def initialize(app) @app = app end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 173,
    "raw_source": "def call(env)\n          status, headers, body = @app.call(env)\n          [status, headers, body.map(&:upcase)]\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 186,
    "raw_source": "def initialize(app) @app = app end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 187,
    "raw_source": "def call(env)\n          status, headers, body = @app.call(env)\n          [status, headers, body.map(&:upcase).map(&:reverse)]\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 200,
    "raw_source": "def initialize(app) @app = app end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 201,
    "raw_source": "def call(env)\n          status, headers, body = @app.call(env)\n          [status, headers, body.each.map(&:upcase)]\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/asciidoctor_test.rb",
    "start_line": 7,
    "raw_source": "def asciidoc_app(&block)\n      mock_app do\n        set :views, __dir__ + '/views'\n        get('/', &block)\n      end\n      get '/'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/base_test.rb",
    "start_line": 10,
    "raw_source": "def initialize(argument:)\n        @argument = argument\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/base_test.rb",
    "start_line": 109,
    "raw_source": "def route_missing\n        env['sinatra.route-missing'] = '1'\n        super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/builder_test.rb",
    "start_line": 7,
    "raw_source": "def builder_app(options = {}, &block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      set options\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/compile_test.rb",
    "start_line": 4,
    "raw_source": "def self.parses pattern, example, expected_params, mtype = :sinatra, mopts = {}\n    it \"parses #{example} with #{pattern} into params #{expected_params}\" do\n      compiled = mock_app { set :mustermann_opts, :type => mtype }.send(:compile, pattern, mopts)\n      params = compiled.params(example)\n      fail %Q{\"#{example}\" does not parse on pattern \"#{pattern}\".} unless params\n\n      assert_equal expected_params, params, \"Pattern #{pattern} does not match path #{example}.\"\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/compile_test.rb",
    "start_line": 14,
    "raw_source": "def self.fails pattern, example, mtype = :sinatra, mopts = {}\n    it \"does not parse #{example} with #{pattern}\" do\n      compiled = mock_app { set :mustermann_opts, :type => mtype }.send(:compile, pattern, mopts)\n      match = compiled.match(example)\n      fail %Q{\"#{pattern}\" does parse \"#{example}\" but it should fail} if match\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/compile_test.rb",
    "start_line": 22,
    "raw_source": "def self.raises pattern, mtype = :sinatra, mopts = {}\n    it \"does not compile #{pattern}\" do\n      assert_raises(Mustermann::CompileError, %Q{Pattern \"#{pattern}\" compiles but it should not}) do\n        mock_app { set :mustermann_opts, :type => mtype }.send(:compile, pattern, mopts)\n      end\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 29,
    "raw_source": "def self.setup(&block)     setup_blocks    << block  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 30,
    "raw_source": "def self.teardown(&block)  teardown_blocks << block  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 31,
    "raw_source": "def self.setup_blocks()    @setup_blocks    ||= []   end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 32,
    "raw_source": "def self.teardown_blocks() @teardown_blocks ||= []   end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 34,
    "raw_source": "def setup_blocks(base = self.class)\n    setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks\n    base.setup_blocks.each do |block|\n      instance_eval(&block)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 41,
    "raw_source": "def teardown_blocks(base = self.class)\n    teardown_blocks base.superclass if base.superclass.respond_to? :teardown_blocks\n    base.teardown_blocks.each do |block|\n      instance_eval(&block)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 51,
    "raw_source": "def self.context(*name, &block)\n    subclass = Class.new(self)\n    remove_tests(subclass)\n    subclass.class_eval(&block) if block_given?\n    const_set(context_name(name.join(\" \")), subclass)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 58,
    "raw_source": "def self.test(name, &block)\n    define_method(test_name(name), &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 69,
    "raw_source": "def self.context_name(name)\n    # \"Test#{sanitize_name(name).gsub(/(^| )(\\w)/) { $2.upcase }}\".to_sym\n    name = \"Test#{sanitize_name(name).gsub(/(^| )(\\w)/) { $2.upcase }}\"\n    name.tr(\" \", \"_\").to_sym\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 75,
    "raw_source": "def self.test_name(name)\n    name = \"test_#{sanitize_name(name).gsub(/\\s+/,'_')}_0\"\n    name = name.succ while method_defined? name\n    name.to_sym\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 81,
    "raw_source": "def self.sanitize_name(name)\n    # name.gsub(/\\W+/, ' ').strip\n    name.gsub(/\\W+/, ' ')\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 86,
    "raw_source": "def self.remove_tests(subclass)\n    subclass.public_instance_methods.grep(/^test_/).each do |meth|\n      subclass.send(:undef_method, meth.to_sym)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 6,
    "raw_source": "def method_missing(*a, &b)\n      @last_call = [*a.map(&:to_s)]\n      @last_call << b if b\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 12,
    "raw_source": "def self.delegates(name)\n    it \"delegates #{name}\" do\n      m = mirror { send name }\n      assert_equal [name.to_s], m.last_call\n    end\n\n    it \"delegates #{name} with arguments\" do\n      m = mirror { send name, \"foo\", \"bar\" }\n      assert_equal [name.to_s, \"foo\", \"bar\"], m.last_call\n    end\n\n    it \"delegates #{name} with block\" do\n      block = proc { }\n      m = mirror { send(name, &block) }\n      assert_equal [name.to_s, block], m.last_call\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 34,
    "raw_source": "def teardown\n    Sinatra::Delegator.target = @target_was\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 38,
    "raw_source": "def delegation_app(&block)\n    mock_app { Sinatra::Delegator.target = self }\n    delegate(&block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 43,
    "raw_source": "def mirror(&block)\n    mirror = Mirror.new\n    Sinatra::Delegator.target = mirror\n    delegate(&block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 49,
    "raw_source": "def delegate(&block)\n    assert Sinatra::Delegator.target != Sinatra::Application\n    Object.new.extend(Sinatra::Delegator).instance_eval(&block) if block\n    Sinatra::Delegator.target\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 55,
    "raw_source": "def target\n    Sinatra::Delegator.target\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 122,
    "raw_source": "def respond_to?(method, *)\n        method.to_sym == :options or super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 126,
    "raw_source": "def method_missing(method, *args, &block)\n        return super unless method.to_sym == :options\n        {:some => :option}\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/erb_test.rb",
    "start_line": 4,
    "raw_source": "def engine\n    Tilt::ERBTemplate\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/erb_test.rb",
    "start_line": 8,
    "raw_source": "def setup\n    Tilt.prefer engine, :erb\n    super\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/erb_test.rb",
    "start_line": 13,
    "raw_source": "def erb_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/erb_test.rb",
    "start_line": 64,
    "raw_source": "def container\n        @_out_buf << \"THIS.\"\n        yield\n        @_out_buf << \"SPARTA!\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/erb_test.rb",
    "start_line": 69,
    "raw_source": "def is; \"IS.\" end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/erb_test.rb",
    "start_line": 111,
    "raw_source": "def engine; Tilt::ErubiTemplate end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 5,
    "raw_source": "def foo\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 9,
    "raw_source": "def im_hiding_in_ur_foos\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 14,
    "raw_source": "def bar\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 19,
    "raw_source": "def baz\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 24,
    "raw_source": "def quux\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 29,
    "raw_source": "def foo=(name); end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 30,
    "raw_source": "def bar?(name); end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 31,
    "raw_source": "def fizz!(name); end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 45,
    "raw_source": "Sinatra::Base.register { def im_in_ur_anonymous_module; end }"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 79,
    "raw_source": "def bizzle\n      bizzle_option\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 83,
    "raw_source": "def self.registered(base)\n      fail \"base should be BizzleApp\" unless base == BizzleApp\n      fail \"base should have already extended BizzleExtension\" unless base.respond_to?(:bizzle)\n      base.set :bizzle_option, 'bizzle!'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/haml_test.rb",
    "start_line": 7,
    "raw_source": "def haml_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 6,
    "raw_source": "def test_default\n    assert true\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 10,
    "raw_source": "def status_app(code, &block)\n    code += 2 if [204, 304].include? code\n    block ||= proc { }\n    mock_app do\n      get('/') do\n        status code\n        instance_eval(&block).inspect\n      end\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 761,
    "raw_source": "def attachment_app(filename=nil)\n      mock_app do\n        get('/attachment') do\n          attachment filename\n          response.write(\"<sinatra></sinatra>\")\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 818,
    "raw_source": "def teardown\n      File.unlink @file\n      @file = nil\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 823,
    "raw_source": "def send_file_app(opts={})\n      path = @file\n      mock_app {\n        get '/file.txt' do\n          send_file path, opts\n        end\n      }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 1012,
    "raw_source": "def obj.method_missing(*a, &b) 60.send(*a, &b) end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 1013,
    "raw_source": "def obj.is_a?(thing) 60.is_a?(thing) end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 1944,
    "raw_source": "module ::HelperOne; def one; '1'; end; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 1945,
    "raw_source": "module ::HelperTwo; def two; '2'; end; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 1967,
    "raw_source": "def foo\n            'foo'\n          end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 1998,
    "raw_source": "def one; nil end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 1999,
    "raw_source": "def two; nil end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 2003,
    "raw_source": "def two; '2' end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 2018,
    "raw_source": "def my_test\n        'BaseHelper#test'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 2031,
    "raw_source": "def my_test\n          'InlineHelper#test'\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 2045,
    "raw_source": "def self.included(base)\n        base.extend(ClassMethods)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 2050,
    "raw_source": "def nickname(name)\n          # do something.\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 10,
    "raw_source": "def test_flattened_constructor\n    hash = Sinatra::IndifferentHash[:a, 1, ?b, 2]\n    assert_equal 1, hash[?a]\n    assert_equal 2, hash[?b]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 16,
    "raw_source": "def test_pairs_constructor\n    hash = Sinatra::IndifferentHash[[[:a, 1], [?b, 2]]]\n    assert_equal 1, hash[?a]\n    assert_equal 2, hash[?b]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 22,
    "raw_source": "def test_default_block\n    hash = Sinatra::IndifferentHash.new { |h, k| h[k] = k.upcase }\n    assert_nil hash.default\n    assert_equal ?A, hash.default(:a)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 28,
    "raw_source": "def test_default_object\n    hash = Sinatra::IndifferentHash.new({:a=>1, ?b=>2})\n    assert_equal({ :a=>1, ?b=>2 }, hash.default)\n    assert_equal({ :a=>1, ?b=>2 }, hash[:a])\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 34,
    "raw_source": "def test_default_assignment\n    hash = Sinatra::IndifferentHash.new\n    hash.default = { :a=>1, ?b=>2 }\n    assert_equal({ ?a=>1, ?b=>2 }, hash.default)\n    assert_equal({ ?a=>1, ?b=>2 }, hash[:a])\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 41,
    "raw_source": "def test_assignment\n    hash = Sinatra::IndifferentHash.new\n    hash[:a] = :a\n    hash[?b] = :b\n    hash[3] = 3\n    hash[:simple_nested] = { :a=>:a, ?b=>:b }\n\n    assert_equal :a, hash[?a]\n    assert_equal :b, hash[?b]\n    assert_equal 3, hash[3]\n    assert_equal({ ?a=>:a, ?b=>:b }, hash['simple_nested'])\n    assert_nil hash[?d]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 55,
    "raw_source": "def test_merge!\n    # merge! is already mostly tested by the different constructors, so we\n    # really just need to test the block form here\n    hash = Sinatra::IndifferentHash[:a=>'a', ?b=>'b', 3=>3]\n    hash.merge!(?a=>'A', :b=>'B', :d=>'D') do |key, oldval, newval|\n      \"#{oldval}*#{key}*#{newval}\"\n    end\n\n    assert_equal({ ?a=>'a*a*A', ?b=>'b*b*B', 3=>3, ?d=>'D' }, hash)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 68,
    "raw_source": "def setup\n    @hash = Sinatra::IndifferentHash[:a=>:a, ?b=>:b, 3=>3,\n      :simple_nested=>{ :a=>:a, ?b=>:b },\n      :nested=>{ :a=>[{ :a=>:a, ?b=>:b }, :c, 4], ?f=>:f, 7=>7 }\n    ]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 75,
    "raw_source": "def test_hash_constructor\n    assert_equal :a, @hash[?a]\n    assert_equal :b, @hash[?b]\n    assert_equal 3, @hash[3]\n    assert_equal({ ?a=>:a, ?b=>:b }, @hash['nested'][?a][0])\n    assert_equal :c, @hash['nested'][?a][1]\n    assert_equal 4, @hash['nested'][?a][2]\n    assert_equal :f, @hash['nested'][?f]\n    assert_equal 7, @hash['nested'][7]\n    assert_equal :a, @hash['simple_nested'][?a]\n    assert_equal :b, @hash['simple_nested'][?b]\n    assert_nil @hash[?d]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 89,
    "raw_source": "def test_assoc\n    assert_nil @hash.assoc(:d)\n    assert_equal [?a, :a], @hash.assoc(:a)\n    assert_equal [?b, :b], @hash.assoc(:b)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 95,
    "raw_source": "def test_rassoc\n    assert_nil @hash.rassoc(:d)\n    assert_equal [?a, :a], @hash.rassoc(:a)\n    assert_equal [?b, :b], @hash.rassoc(:b)\n    assert_equal ['simple_nested', { ?a=>:a, ?b=>:b }], @hash.rassoc(:a=>:a, ?b=>:b)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 102,
    "raw_source": "def test_fetch\n    assert_raises(KeyError) { @hash.fetch(:d) }\n    assert_equal 1, @hash.fetch(:d, 1)\n    assert_equal 2, @hash.fetch(:d) { 2 }\n    assert_equal ?d, @hash.fetch(:d) { |k| k }\n    assert_equal :a, @hash.fetch(:a, 1)\n    assert_equal :a, @hash.fetch(:a) { 2 }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 111,
    "raw_source": "def test_symbolic_retrieval\n    assert_equal :a, @hash[:a]\n    assert_equal :b, @hash[:b]\n    assert_equal({ ?a=>:a, ?b=>:b }, @hash[:nested][:a][0])\n    assert_equal :c, @hash[:nested][:a][1]\n    assert_equal 4, @hash[:nested][:a][2]\n    assert_equal :f, @hash[:nested][:f]\n    assert_equal 7, @hash[:nested][7]\n    assert_equal :a, @hash[:simple_nested][:a]\n    assert_equal :b, @hash[:simple_nested][:b]\n    assert_nil @hash[:d]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 124,
    "raw_source": "def test_key\n    assert_nil @hash.key(:d)\n    assert_equal ?a, @hash.key(:a)\n    assert_equal 'simple_nested', @hash.key(:a=>:a, ?b=>:b)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 130,
    "raw_source": "def test_key?\n    assert_operator @hash, :key?, :a\n    assert_operator @hash, :key?, ?b\n    assert_operator @hash, :key?, 3\n    refute_operator @hash, :key?, :d\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 137,
    "raw_source": "def test_value?\n    assert_operator @hash, :value?, :a\n    assert_operator @hash, :value?, :b\n    assert_operator @hash, :value?, 3\n    assert_operator @hash, :value?, { :a=>:a, ?b=>:b }\n    refute_operator @hash, :value?, :d\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 145,
    "raw_source": "def test_delete\n    @hash.delete(:a)\n    @hash.delete(?b)\n    assert_nil @hash[:a]\n    assert_nil @hash[?b]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 152,
    "raw_source": "def test_dig\n    assert_equal :a, @hash.dig(:a)\n    assert_equal :b, @hash.dig(?b)\n    assert_nil @hash.dig(:d)\n\n    assert_equal :a, @hash.dig(:simple_nested, :a)\n    assert_equal :b, @hash.dig('simple_nested', ?b)\n    assert_nil @hash.dig('simple_nested', :d)\n\n    assert_equal :a, @hash.dig(:nested, :a, 0, :a)\n    assert_equal :b, @hash.dig('nested', ?a, 0, ?b)\n    assert_nil @hash.dig('nested', ?a, 0, :d)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 166,
    "raw_source": "def test_slice\n    assert_equal Sinatra::IndifferentHash[a: :a], @hash.slice(:a)\n    assert_equal Sinatra::IndifferentHash[b: :b], @hash.slice(?b)\n    assert_equal Sinatra::IndifferentHash[3 => 3], @hash.slice(3)\n    assert_equal Sinatra::IndifferentHash.new, @hash.slice(:d)\n    assert_equal Sinatra::IndifferentHash[a: :a, b: :b, 3 => 3], @hash.slice(:a, :b, 3)\n    assert_equal Sinatra::IndifferentHash[simple_nested: { a: :a, ?b => :b }], @hash.slice(:simple_nested)\n    assert_equal Sinatra::IndifferentHash[nested: { a: [{ a: :a, ?b => :b }, :c, 4], ?f => :f, 7 => 7 }], @hash.slice(:nested)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 176,
    "raw_source": "def test_fetch_values\n    assert_raises(KeyError) { @hash.fetch_values(3, :d) }\n    assert_equal [:a, :b, 3, ?D], @hash.fetch_values(:a, ?b, 3, :d) { |k| k.upcase }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 181,
    "raw_source": "def test_values_at\n    assert_equal [:a, :b, 3, nil], @hash.values_at(:a, ?b, 3, :d)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 185,
    "raw_source": "def test_merge\n    # merge just calls merge!, which is already thoroughly tested\n    hash2 = @hash.merge(?a=>1, :q=>2) { |key, oldval, newval| \"#{oldval}*#{key}*#{newval}\" }\n\n    refute_equal @hash, hash2\n    assert_equal 'a*a*1', hash2[:a]\n    assert_equal 2, hash2[?q]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 194,
    "raw_source": "def test_merge_with_multiple_argument\n    hash = Sinatra::IndifferentHash.new.merge({a: 1}, {b: 2}, {c: 3})\n    assert_equal 1, hash[?a]\n    assert_equal 2, hash[?b]\n    assert_equal 3, hash[?c]\n\n    hash2 = Sinatra::IndifferentHash[d: 4]\n    hash3 = {e: 5}\n    hash.merge!(hash2, hash3)\n\n    assert_equal 4, hash[?d]\n    assert_equal 5, hash[?e]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 208,
    "raw_source": "def test_replace\n    @hash.replace(?a=>1, :q=>2)\n    assert_equal({ ?a=>1, ?q=>2 }, @hash)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 213,
    "raw_source": "def test_transform_values!\n    @hash.transform_values! { |v| v.is_a?(Hash) ? Hash[v.to_a] : v }\n\n    assert_instance_of Sinatra::IndifferentHash, @hash[:simple_nested]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 219,
    "raw_source": "def test_transform_values\n    hash2 = @hash.transform_values { |v| v.respond_to?(:upcase) ? v.upcase : v }\n\n    refute_equal @hash, hash2\n    assert_equal :A, hash2[:a]\n    assert_equal :A, hash2[?a]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 227,
    "raw_source": "def test_transform_keys!\n    @hash.transform_keys! { |k| k.respond_to?(:to_sym) ? k.to_sym : k }\n\n    assert_equal :a, @hash[:a]\n    assert_equal :a, @hash[?a]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 234,
    "raw_source": "def test_transform_keys\n    hash2 = @hash.transform_keys { |k| k.respond_to?(:upcase) ? k.upcase : k }\n\n    refute_equal @hash, hash2\n    refute_operator hash2, :key?, :a\n    refute_operator hash2, :key?, ?a\n    assert_equal :a, hash2[:A]\n    assert_equal :a, hash2[?A]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 244,
    "raw_source": "def test_select\n    hash = @hash.select { |k, v| v == :a }\n    assert_equal Sinatra::IndifferentHash[a: :a], hash\n    assert_instance_of Sinatra::IndifferentHash, hash\n\n    hash2 = @hash.select { |k, v| true }\n    assert_equal @hash, hash2\n    assert_instance_of Sinatra::IndifferentHash, hash2\n\n    enum = @hash.select\n    assert_instance_of Enumerator, enum\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 257,
    "raw_source": "def test_select!\n    @hash.select! { |k, v| v == :a }\n    assert_equal Sinatra::IndifferentHash[a: :a], @hash\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 262,
    "raw_source": "def test_reject\n    hash = @hash.reject { |k, v| v != :a }\n    assert_equal Sinatra::IndifferentHash[a: :a], hash\n    assert_instance_of Sinatra::IndifferentHash, hash\n\n    hash2 = @hash.reject { |k, v| false }\n    assert_equal @hash, hash2\n    assert_instance_of Sinatra::IndifferentHash, hash2\n\n    enum = @hash.reject\n    assert_instance_of Enumerator, enum\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 275,
    "raw_source": "def test_reject!\n    @hash.reject! { |k, v| v != :a }\n    assert_equal Sinatra::IndifferentHash[a: :a], @hash\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 280,
    "raw_source": "def test_compact\n    hash_with_nil_values = @hash.merge({?z => nil})\n    compacted_hash = hash_with_nil_values.compact\n    assert_equal @hash, compacted_hash\n    assert_instance_of Sinatra::IndifferentHash, compacted_hash\n\n    empty_hash = Sinatra::IndifferentHash.new\n    compacted_hash = empty_hash.compact\n    assert_equal empty_hash, compacted_hash\n\n    non_empty_hash = Sinatra::IndifferentHash[a: :a]\n    compacted_hash = non_empty_hash.compact\n    assert_equal non_empty_hash, compacted_hash\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 295,
    "raw_source": "def test_except\n    hash = @hash.except(?b, 3, :simple_nested, 'nested')\n    assert_equal Sinatra::IndifferentHash[a: :a], hash\n    assert_instance_of Sinatra::IndifferentHash, hash\n  end if Gem::Version.new(RUBY_VERSION) >= Gem::Version.new(\"3.0\")"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_async_helper.rb",
    "start_line": 6,
    "raw_source": "def it(message, &block)\n    Server.all_async.each do |server|\n      next unless server.installed?\n      super(\"with #{server.name}: #{message}\") { server.run_test(self, &block) }\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_async_helper.rb",
    "start_line": 13,
    "raw_source": "def self.extend_object(obj)\n    super\n\n    base_port = 5100 + Process.pid % 100\n    servers = %w(puma)\n\n    servers.each_with_index do |server, index|\n      Server.run(server, base_port+index, async: true)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 12,
    "raw_source": "def self.all\n      @all ||= []\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 16,
    "raw_source": "def self.all_async\n      @all_async ||= []\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 20,
    "raw_source": "def self.each(&block)\n      all.each(&block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 24,
    "raw_source": "def self.run(server, port, async: false)\n      new(server, port, async).run\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 28,
    "raw_source": "def app_file\n      File.expand_path('integration/app.rb', __dir__)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 32,
    "raw_source": "def environment\n      \"development\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 36,
    "raw_source": "def initialize(server, port, async)\n      @installed, @pipe, @server, @port = nil, nil, server, port\n      ENV['PUMA_MIN_THREADS'] = '1' if server == 'puma'\n      if async\n        Server.all_async << self\n      else\n        Server.all << self\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 46,
    "raw_source": "def run\n      return unless installed?\n      kill\n      @log     = +\"\"\n      super\n      at_exit { kill }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 54,
    "raw_source": "def installed?\n      return @installed unless @installed.nil?\n      s = server == 'HTTP' ? 'net/http/server' : server\n      require s\n      @installed = true\n    rescue LoadError\n      warn \"#{server} is not installed, skipping integration tests\"\n      @installed = false\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 64,
    "raw_source": "def command\n      @command ||= begin\n        cmd = [\"APP_ENV=#{environment}\", \"exec\"]\n        if RbConfig.respond_to? :ruby\n          cmd << RbConfig.ruby.inspect\n        else\n          file, dir = RbConfig::CONFIG.values_at('ruby_install_name', 'bindir')\n          cmd << File.expand_path(file, dir).inspect\n        end\n        cmd << \"-w\" unless net_http_server?\n        cmd << \"-I\" << File.expand_path('../lib', __dir__).inspect\n        cmd << app_file.inspect << '-s' << server << '-o' << '127.0.0.1' << '-p' << port\n        cmd << \"-e\" << environment.to_s << '2>&1'\n        cmd.join \" \"\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 81,
    "raw_source": "def webrick?\n      name.to_s == \"webrick\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 85,
    "raw_source": "def puma?\n      name.to_s == \"puma\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 89,
    "raw_source": "def falcon?\n      name.to_s == \"falcon\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 93,
    "raw_source": "def trinidad?\n      name.to_s == \"trinidad\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 97,
    "raw_source": "def net_http_server?\n      name.to_s == 'HTTP'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 101,
    "raw_source": "def warnings\n      log.scan(%r[(?:\\(eval|lib/sinatra).*warning:.*$])\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 105,
    "raw_source": "def run_test(target, &block)\n      retries ||= 3\n      target.server = self\n      run unless alive?\n      target.instance_eval(&block)\n    rescue Exception => error\n      retries -= 1\n      kill\n      retries < 0 ? retry : raise(error)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 119,
    "raw_source": "def it(message, &block)\n    Server.each do |server|\n      next unless server.installed?\n      super(\"with #{server.name}: #{message}\") { server.run_test(self, &block) }\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 126,
    "raw_source": "def self.extend_object(obj)\n    super\n\n    base_port = 5000 + Process.pid % 100\n    servers = Sinatra::Base.server.dup\n\n    # TruffleRuby doesn't support `Fiber.set_scheduler` yet\n    unsupported_truffleruby = RUBY_ENGINE == \"truffleruby\" && !Fiber.respond_to?(:set_scheduler)\n    # Ruby 2.7 uses falcon 0.42.3 which isn't working with rackup 2.2.0+\n    too_old_ruby = RUBY_VERSION <= \"3.0.0\"\n\n    if unsupported_truffleruby || too_old_ruby\n      warn \"skip falcon server\"\n      servers.delete('falcon')\n    end\n\n    servers.each_with_index do |server, index|\n      Server.run(server, base_port+index)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_helper.rb",
    "start_line": 6,
    "raw_source": "def command_for(app_file)\n    [\n      \"ruby\",\n      app_file,\n      \"-p\",\n      \"0\", # any free port\n      \"-s\",\n      \"puma\",\n    ]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_helper.rb",
    "start_line": 17,
    "raw_source": "def with_process(command:, env: {}, debug: false)\n    process = ChildProcess.build(*command)\n    process.leader = true # ensure entire process tree dies\n    process.environment.merge!(env)\n    read_io, write_io = IO.pipe\n    process.io.stdout = write_io\n    process.io.stderr = write_io\n    process.start\n    # Close parent's copy of the write end of the pipe so when the (forked) child\n    # process closes its write end of the pipe the parent receives EOF when\n    # attempting to read from it. If the parent leaves its write end open, it\n    # will not detect EOF.\n    write_io.close\n\n    echo_output(read_io) if debug || debug_all?\n\n    yield process, read_io\n  ensure\n    read_io.close\n    process.stop\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_helper.rb",
    "start_line": 39,
    "raw_source": "def echo_output(read_io)\n    Thread.new do\n      begin\n        loop { print read_io.readpartial(8192) }\n      rescue EOFError\n      end\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_helper.rb",
    "start_line": 48,
    "raw_source": "def debug_all?\n    ENV.key?(\"DEBUG_START_PROCESS\")\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_helper.rb",
    "start_line": 52,
    "raw_source": "def wait_timeout\n    case RUBY_ENGINE\n    when \"jruby\", \"truffleruby\"\n      # takes some time to start the JVM\n      10.0\n    else\n      3.0\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_helper.rb",
    "start_line": 62,
    "raw_source": "def wait_for_output(read_io, matcher, timeout = wait_timeout)\n    return true if read_io.expect(matcher, timeout).to_a.any?\n\n    raise \"Waited for #{timeout} seconds, but received no output matching: \" \\\n          \"#{matcher.source}\"\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_test.rb",
    "start_line": 6,
    "raw_source": "def test_app_start_without_rackup\n    # Why we skip head versions: The Gemfile used here would have to support\n    # the ENVs and we would need to bundle before starting the app\n    #\n    # Example from locally playing with this:\n    #\n    #   root@df8b1e7cb106:/app# rack_session=head BUNDLE_GEMFILE=./test/integration/gemfile_without_rackup.rb ruby ./test/integration/simple_app.rb -p 0 -s puma\n    #   The git source https://github.com/rack/rack-session.git is not yet checked out. Please run `bundle install` before trying to start your application\n    #\n    # Using bundler/inline is an idea, but it would add to the startup time\n    skip \"So much work to run with rack head branch\" if ENV['rack'] == 'head'\n    skip \"So much work to run with rack-session head branch\" if ENV['rack_session'] == 'head'\n\n    app_file = File.join(__dir__, \"integration\", \"simple_app.rb\")\n    gem_file = File.join(__dir__, \"integration\", \"gemfile_without_rackup.rb\")\n    command = command_for(app_file)\n    env = { \"BUNDLE_GEMFILE\" => gem_file }\n\n    with_process(command: command, env: env) do |process, read_io|\n      assert wait_for_output(read_io, /Sinatra could not start, the required gems weren't found/)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_test.rb",
    "start_line": 29,
    "raw_source": "def test_classic_app_start\n    app_file = File.join(__dir__, \"integration\", \"simple_app.rb\")\n    command = command_for(app_file)\n    with_process(command: command) do |process, read_io|\n      assert wait_for_output(read_io, /Sinatra \\(v.+\\) has taken the stage/)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_test.rb",
    "start_line": 37,
    "raw_source": "def test_classic_app_with_zeitwerk\n    app_file = File.join(__dir__, \"integration\", \"zeitwerk_app.rb\")\n    command = command_for(app_file)\n    with_process(command: command) do |process, read_io|\n      assert wait_for_output(read_io, /Sinatra \\(v.+\\) has taken the stage/)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/liquid_test.rb",
    "start_line": 7,
    "raw_source": "def liquid_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/mapped_error_test.rb",
    "start_line": 10,
    "raw_source": "def http_status; 501 end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/mapped_error_test.rb",
    "start_line": 14,
    "raw_source": "def code; 4000 end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/mapped_error_test.rb",
    "start_line": 18,
    "raw_source": "def code; 419 end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/mapped_error_test.rb",
    "start_line": 25,
    "raw_source": "def test_default\n    assert true\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/markaby_test.rb",
    "start_line": 7,
    "raw_source": "def markaby_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/markdown_test.rb",
    "start_line": 4,
    "raw_source": "def markdown_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/markdown_test.rb",
    "start_line": 12,
    "raw_source": "def setup\n    Tilt.prefer engine, 'markdown', 'mkd', 'md'\n    super\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/middleware_test.rb",
    "start_line": 16,
    "raw_source": "def call(env)\n      (env['test.ran'] ||= []) << self.class.to_s\n      app.call(env)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/middleware_test.rb",
    "start_line": 23,
    "raw_source": "def call(env)\n      env['PATH_INFO'] = env['PATH_INFO'].upcase\n      super\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/middleware_test.rb",
    "start_line": 37,
    "raw_source": "def call(env)\n      env['PATH_INFO'] = env['PATH_INFO'].downcase\n      super\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/middleware_test.rb",
    "start_line": 70,
    "raw_source": "def call(env)\n      req = Rack::Request.new(env)\n      req.update_param('bar', 'baz'.freeze)\n      super\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/middleware_test.rb",
    "start_line": 83,
    "raw_source": "def call(env)\n      req = Rack::Request.new(env)\n      req.update_param('s', :s)\n      req.update_param('i', 1)\n      req.update_param('c', 3.to_c)\n      req.update_param('t', true)\n      req.update_param('f', false)\n      req.update_param('n', nil)\n      super\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/middleware_test.rb",
    "start_line": 101,
    "raw_source": "def initialize(app, **)\n      super app\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/nokogiri_test.rb",
    "start_line": 7,
    "raw_source": "def nokogiri_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/rabl_test.rb",
    "start_line": 11,
    "raw_source": "def rabl_app(&block)\n    mock_app {\n      set :views, __dir__ + '/views'\n      get '/', &block\n    }\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/rack_test.rb",
    "start_line": 10,
    "raw_source": "def build(*middleware)\n    endpoint = middleware.pop\n    @app = Rack::Builder.app do\n      middleware.each { |m| use m }\n      run endpoint\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/rack_test.rb",
    "start_line": 18,
    "raw_source": "def check(*middleware)\n    build(*middleware)\n    assert get('/foo').ok?\n    assert_body 'foo'\n    assert get('/bar').ok?\n    assert_body 'bar'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/rdoc_test.rb",
    "start_line": 8,
    "raw_source": "def rdoc_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/response_test.rb",
    "start_line": 6,
    "raw_source": "def assert_same_body(a, b)\n    assert_equal a.to_enum(:each).to_a, b.to_enum(:each).to_a\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/response_test.rb",
    "start_line": 58,
    "raw_source": "def object.inject(*) fail 'called' end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/response_test.rb",
    "start_line": 59,
    "raw_source": "def object.to_ary(*) fail 'called' end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/response_test.rb",
    "start_line": 60,
    "raw_source": "def object.each(*) end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/result_test.rb",
    "start_line": 4,
    "raw_source": "def http_status; 400 end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/result_test.rb",
    "start_line": 28,
    "raw_source": "def res.each ; yield call ; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/route_added_hook_test.rb",
    "start_line": 5,
    "raw_source": "def self.routes ; @routes ; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/route_added_hook_test.rb",
    "start_line": 6,
    "raw_source": "def self.procs ; @procs ; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/route_added_hook_test.rb",
    "start_line": 7,
    "raw_source": "def self.route_added(verb, path, proc)\n    @routes << [verb, path]\n    @procs << proc\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/routing_test.rb",
    "start_line": 4,
    "raw_source": "def route_def(pattern)\n  mock_app { get(pattern) { } }\nend"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/routing_test.rb",
    "start_line": 9,
    "raw_source": "def to_pattern(*)\n    self\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/routing_test.rb",
    "start_line": 13,
    "raw_source": "def params(input)\n    { \"one\" => +\"this\", \"two\" => +\"is\", \"three\" => +\"a\", \"four\" => +\"test\" }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/routing_test.rb",
    "start_line": 1510,
    "raw_source": "def protect(*args)\n        condition {\n          unless authorize(params[\"user\"], params[\"password\"])\n            halt 403, \"go away\"\n          end\n        }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/routing_test.rb",
    "start_line": 1523,
    "raw_source": "def authorize(username, password)\n          username == \"foo\" && password == \"bar\"\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/sass_test.rb",
    "start_line": 7,
    "raw_source": "def sass_app(options = {}, &block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      set options\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/scss_test.rb",
    "start_line": 7,
    "raw_source": "def scss_app(options = {}, &block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      set options\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 8,
    "raw_source": "def self.assertions\n      @assertions ||= 0\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 12,
    "raw_source": "def self.assertions= assertions\n      @assertions = assertions\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 16,
    "raw_source": "def self.run(app, options={})\n      assert(app < Sinatra::Base)\n      assert_equal 9001, options[:Port]\n      assert_equal 'foo.local', options[:Host]\n      yield new\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 23,
    "raw_source": "def stop\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 40,
    "raw_source": "def teardown\n    $stderr = STDERR\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 50,
    "raw_source": "def self.start_hook; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 51,
    "raw_source": "def self.stop_hook; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 96,
    "raw_source": "def initialize(app)\n        @@initialized = true\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 99,
    "raw_source": "def self.initialized\n        @@initialized\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 102,
    "raw_source": "def call(env)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/settings_test.rb",
    "start_line": 106,
    "raw_source": "def foo\n        @foo\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/settings_test.rb",
    "start_line": 109,
    "raw_source": "def foo=(value)\n        @foo = 'oops'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/settings_test.rb",
    "start_line": 458,
    "raw_source": "def priv; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/settings_test.rb",
    "start_line": 460,
    "raw_source": "def pub; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/settings_test.rb",
    "start_line": 580,
    "raw_source": "def self.track\n        Rack.send :remove_const, :Builder\n        Rack.const_set :Builder, MiddlewareTracker\n        MiddlewareTracker.used.clear\n        yield\n      ensure\n        Rack.send :remove_const, :Builder\n        Rack.const_set :Builder, MiddlewareTracker.superclass\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/settings_test.rb",
    "start_line": 590,
    "raw_source": "def self.used\n        @used ||= []\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/settings_test.rb",
    "start_line": 594,
    "raw_source": "def use(middleware, *)\n        MiddlewareTracker.used << middleware\n        super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/slim_test.rb",
    "start_line": 7,
    "raw_source": "def slim_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/static_test.rb",
    "start_line": 106,
    "raw_source": "def assert_valid_range(http_range, range, path, file)\n    request = Rack::MockRequest.new(@app)\n    response = request.get(\"/#{File.basename(path)}\", 'HTTP_RANGE' => http_range)\n\n    should_be = file[range]\n    expected_range = \"bytes #{range.begin}-#{range.end}/#{file.length}\"\n\n    assert_equal(\n      206,response.status,\n      \"Should be HTTP/1.1 206 Partial content\"\n    )\n    assert_equal(\n      should_be.length,\n      response.body.length,\n      \"Unexpected response length for #{http_range}\"\n    )\n    assert_equal(\n      should_be,\n      response.body,\n      \"Unexpected response data for #{http_range}\"\n    )\n    assert_equal(\n      should_be.length.to_s,\n      response['Content-Length'],\n      \"Incorrect Content-Length for #{http_range}\"\n    )\n    assert_equal(\n      expected_range,\n      response['Content-Range'],\n      \"Incorrect Content-Range for #{http_range}\"\n    )\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/streaming_test.rb",
    "start_line": 70,
    "raw_source": "def initialize(*)     @schedule, @defer = [], []                end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/streaming_test.rb",
    "start_line": 71,
    "raw_source": "def schedule(&block)  @schedule << block                        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/streaming_test.rb",
    "start_line": 72,
    "raw_source": "def defer(&block)     @defer    << block                        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/streaming_test.rb",
    "start_line": 73,
    "raw_source": "def schedule!(*)      @schedule.pop.call until @schedule.empty? end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/streaming_test.rb",
    "start_line": 74,
    "raw_source": "def defer!(*)         @defer.pop.call    until @defer.empty?    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/streaming_test.rb",
    "start_line": 131,
    "raw_source": "def close.callback; yield end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/streaming_test.rb",
    "start_line": 132,
    "raw_source": "def close.errback; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/templates_test.rb",
    "start_line": 5,
    "raw_source": "def prepare\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/templates_test.rb",
    "start_line": 8,
    "raw_source": "def evaluate(scope, locals={}, &block)\n    inner = block ? block.call : ''\n    data + inner\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/templates_test.rb",
    "start_line": 17,
    "raw_source": "def render_app(base=Sinatra::Base, options = {}, &block)\n    base, options = Sinatra::Base, base if base.is_a? Hash\n    mock_app(base) do\n      set :views, __dir__ + '/views'\n      set options\n      get('/', &block)\n      template(:layout3) { \"Layout 3!\\n\" }\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/templates_test.rb",
    "start_line": 28,
    "raw_source": "def with_default_layout\n    layout = __dir__ + '/views/layout.test'\n    File.open(layout, 'wb') { |io| io.write \"Layout!\\n\" }\n    yield\n  ensure\n    File.unlink(layout) rescue nil\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/templates_test.rb",
    "start_line": 363,
    "raw_source": "def some_scope.foo() 'World!' end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/templates_test.rb",
    "start_line": 376,
    "raw_source": "def find_template(views, name, engine, &block)\n        Array(views).each { |v| super(v, name, engine, &block) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 40,
    "raw_source": "def assertions\n    @assertions ||= 0\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 48,
    "raw_source": "def include?(middleware)\n    @ins.any? { |m| middleware === m }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 63,
    "raw_source": "def self.example(desc = nil, &block)\n    @example_count = 0 unless instance_variable_defined? :@example_count\n    @example_count += 1\n    it(desc || \"Example #{@example_count}\", &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 78,
    "raw_source": "def mock_app(base=Sinatra::Base, &block)\n    @app = Sinatra.new(base, &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 82,
    "raw_source": "def app\n    Rack::Lint.new(@app)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 86,
    "raw_source": "def body\n    response.body.to_s\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 90,
    "raw_source": "def assert_body(value)\n    if value.respond_to? :to_str\n      assert_equal value.lstrip.gsub(/\\s*\\n\\s*/, \"\"), body.lstrip.gsub(/\\s*\\n\\s*/, \"\")\n    else\n      assert_match value, body\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 98,
    "raw_source": "def assert_status(expected)\n    assert_equal Integer(expected), Integer(status)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 102,
    "raw_source": "def assert_like(a,b)\n    pattern = /id=['\"][^\"']*[\"']|\\s+/\n    assert_equal a.strip.gsub(pattern, \"\"), b.strip.gsub(pattern, \"\")\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 107,
    "raw_source": "def assert_include(str, substr)\n    assert str.include?(substr), \"expected #{str.inspect} to include #{substr.inspect}\"\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 111,
    "raw_source": "def options(uri, params = {}, env = {}, &block)\n    request(uri, env.merge(:method => \"OPTIONS\", :params => params), &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 115,
    "raw_source": "def patch(uri, params = {}, env = {}, &block)\n    request(uri, env.merge(:method => \"PATCH\", :params => params), &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 119,
    "raw_source": "def link(uri, params = {}, env = {}, &block)\n    request(uri, env.merge(:method => \"LINK\", :params => params), &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 123,
    "raw_source": "def unlink(uri, params = {}, env = {}, &block)\n    request(uri, env.merge(:method => \"UNLINK\", :params => params), &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 128,
    "raw_source": "def method_missing(name, *args, &block)\n    if response && response.respond_to?(name)\n      response.send(name, *args, &block)\n    else\n      super\n    end\n  rescue Rack::Test::Error\n    super\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 139,
    "raw_source": "def silence_warnings\n    $VERBOSE, v = nil, $VERBOSE\n    yield\n  ensure\n    $VERBOSE = v\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/yajl_test.rb",
    "start_line": 7,
    "raw_source": "def yajl_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  }
]