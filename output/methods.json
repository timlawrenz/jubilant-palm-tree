[
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/example/server/example_servlet.rb",
    "start_line": 4,
    "raw_source": "def price(integer)\n    format(\"$%.2d USD\", integer / 100.0)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/example/server/example_servlet.rb",
    "start_line": 8,
    "raw_source": "def prettyprint(text)\n    text.gsub(/\\*(.*)\\*/, '<b>\\1</b>')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/example/server/example_servlet.rb",
    "start_line": 12,
    "raw_source": "def count(array)\n    array.size\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/example/server/example_servlet.rb",
    "start_line": 16,
    "raw_source": "def paragraph(p)\n    \"<p>#{p}</p>\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/example/server/example_servlet.rb",
    "start_line": 22,
    "raw_source": "def index\n    { 'date' => Time.now }\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/example/server/example_servlet.rb",
    "start_line": 26,
    "raw_source": "def products\n    { 'products' => products_list, 'more_products' => more_products_list, 'description' => description, 'section' => 'Snowboards', 'cool_products' => true }\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/example/server/example_servlet.rb",
    "start_line": 32,
    "raw_source": "def products_list\n    [\n      { 'name' => 'Arbor Draft', 'price' => 39900, 'description' => 'the *arbor draft* is a excellent product' },\n      { 'name' => 'Arbor Element', 'price' => 40000, 'description' => 'the *arbor element* rocks for freestyling' },\n      { 'name' => 'Arbor Diamond', 'price' => 59900, 'description' => 'the *arbor diamond* is a made up product because im obsessed with arbor and have no creativity' }\n    ]\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/example/server/example_servlet.rb",
    "start_line": 40,
    "raw_source": "def more_products_list\n    [\n      { 'name' => 'Arbor Catalyst', 'price' => 39900, 'description' => 'the *arbor catalyst* is an advanced drop-through for freestyle and flatground performance and versatility' },\n      { 'name' => 'Arbor Fish', 'price' => 40000, 'description' => 'the *arbor fish* is a compact pin that features an extended wheelbase and time-honored teardrop shape' }\n    ]\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/example/server/example_servlet.rb",
    "start_line": 47,
    "raw_source": "def description\n    \"List of Products ~ This is a list of products with price and description.\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/example/server/liquid_servlet.rb",
    "start_line": 4,
    "raw_source": "def do_GET(req, res)\n    handle(:get, req, res)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/example/server/liquid_servlet.rb",
    "start_line": 8,
    "raw_source": "def do_POST(req, res)\n    handle(:post, req, res)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/example/server/liquid_servlet.rb",
    "start_line": 14,
    "raw_source": "def handle(_type, req, res)\n    @request  = req\n    @response = res\n\n    @request.path_info =~ /(\\w+)\\z/\n    @action  = Regexp.last_match(1) || 'index'\n    @assigns = send(@action) if respond_to?(@action)\n\n    @response['Content-Type'] = \"text/html\"\n    @response.status = 200\n    @response.body   = Liquid::Template.parse(read_template).render(@assigns, filters: [ProductsFilter])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/example/server/liquid_servlet.rb",
    "start_line": 27,
    "raw_source": "def read_template(filename = @action)\n    File.read(\"#{__dir__}/templates/#{filename}.liquid\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block.rb",
    "start_line": 7,
    "raw_source": "def initialize(tag_name, markup, options)\n      super\n      @blank = true\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block.rb",
    "start_line": 12,
    "raw_source": "def parse(tokens)\n      @body = new_body\n      while parse_body(@body, tokens)\n      end\n      @body.freeze\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block.rb",
    "start_line": 20,
    "raw_source": "def render(context)\n      @body.render(context)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block.rb",
    "start_line": 24,
    "raw_source": "def blank?\n      @blank\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block.rb",
    "start_line": 28,
    "raw_source": "def nodelist\n      @body.nodelist\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block.rb",
    "start_line": 32,
    "raw_source": "def unknown_tag(tag_name, _markup, _tokenizer)\n      Block.raise_unknown_tag(tag_name, block_name, block_delimiter, parse_context)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block.rb",
    "start_line": 37,
    "raw_source": "def self.raise_unknown_tag(tag, block_name, block_delimiter, parse_context)\n      if tag == 'else'\n        raise SyntaxError, parse_context.locale.t(\n          \"errors.syntax.unexpected_else\",\n          block_name: block_name,\n        )\n      elsif tag.start_with?('end')\n        raise SyntaxError, parse_context.locale.t(\n          \"errors.syntax.invalid_delimiter\",\n          tag: tag,\n          block_name: block_name,\n          block_delimiter: block_delimiter,\n        )\n      else\n        raise SyntaxError, parse_context.locale.t(\"errors.syntax.unknown_tag\", tag: tag)\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block.rb",
    "start_line": 55,
    "raw_source": "def raise_tag_never_closed(block_name)\n      raise SyntaxError, parse_context.locale.t(\"errors.syntax.tag_never_closed\", block_name: block_name)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block.rb",
    "start_line": 59,
    "raw_source": "def block_name\n      @tag_name\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block.rb",
    "start_line": 63,
    "raw_source": "def block_delimiter\n      @block_delimiter ||= \"end#{block_name}\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block.rb",
    "start_line": 70,
    "raw_source": "def new_body\n      parse_context.new_block_body\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block.rb",
    "start_line": 75,
    "raw_source": "def parse_body(body, tokens)\n      if parse_context.depth >= MAX_DEPTH\n        raise StackLevelError, \"Nesting too deep\"\n      end\n      parse_context.depth += 1\n      begin\n        body.parse(tokens, parse_context) do |end_tag_name, end_tag_params|\n          @blank &&= body.blank?\n\n          return false if end_tag_name == block_delimiter\n          raise_tag_never_closed(block_name) unless end_tag_name\n\n          # this tag is not registered with the system\n          # pass it to the current block for special handling or error reporting\n          unknown_tag(end_tag_name, end_tag_params, tokens)\n        end\n      ensure\n        parse_context.depth -= 1\n      end\n\n      true\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 17,
    "raw_source": "def initialize\n      @nodelist = []\n      @blank    = true\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 22,
    "raw_source": "def parse(tokenizer, parse_context, &block)\n      raise FrozenError, \"can't modify frozen Liquid::BlockBody\" if frozen?\n\n      parse_context.line_number = tokenizer.line_number\n\n      if tokenizer.for_liquid_tag\n        parse_for_liquid_tag(tokenizer, parse_context, &block)\n      else\n        parse_for_document(tokenizer, parse_context, &block)\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 34,
    "raw_source": "def freeze\n      @nodelist.freeze\n      super\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 39,
    "raw_source": "private def parse_for_liquid_tag(tokenizer, parse_context)\n      while (token = tokenizer.shift)\n        unless token.empty? || token.match?(WhitespaceOrNothing)\n          unless token =~ LiquidTagToken\n            # line isn't empty but didn't match tag syntax, yield and let the\n            # caller raise a syntax error\n            return yield token, token\n          end\n          tag_name = Regexp.last_match(1)\n          markup   = Regexp.last_match(2)\n\n          if tag_name == 'liquid'\n            parse_context.line_number -= 1\n            next parse_liquid_tag(markup, parse_context)\n          end\n\n          unless (tag = parse_context.environment.tag_for_name(tag_name))\n            # end parsing if we reach an unknown tag and let the caller decide\n            # determine how to proceed\n            return yield tag_name, markup\n          end\n          new_tag = tag.parse(tag_name, markup, tokenizer, parse_context)\n          @blank &&= new_tag.blank?\n          @nodelist << new_tag\n        end\n        parse_context.line_number = tokenizer.line_number\n      end\n\n      yield nil, nil\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 71,
    "raw_source": "def self.unknown_tag_in_liquid_tag(tag, parse_context)\n      Block.raise_unknown_tag(tag, 'liquid', '%}', parse_context)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 76,
    "raw_source": "def self.raise_missing_tag_terminator(token, parse_context)\n      raise SyntaxError, parse_context.locale.t(\"errors.syntax.tag_termination\", token: token, tag_end: TagEnd.inspect)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 81,
    "raw_source": "def self.raise_missing_variable_terminator(token, parse_context)\n      raise SyntaxError, parse_context.locale.t(\"errors.syntax.variable_termination\", token: token, tag_end: VariableEnd.inspect)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 86,
    "raw_source": "def self.render_node(context, output, node)\n      node.render_to_output_buffer(context, output)\n    rescue => exc\n      blank_tag = !node.instance_of?(Variable) && node.blank?\n      rescue_render_node(context, output, node.line_number, exc, blank_tag)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 94,
    "raw_source": "def self.rescue_render_node(context, output, line_number, exc, blank_tag)\n      case exc\n      when MemoryError\n        raise\n      when UndefinedVariable, UndefinedDropMethod, UndefinedFilter\n        context.handle_error(exc, line_number)\n      else\n        error_message = context.handle_error(exc, line_number)\n        unless blank_tag # conditional for backwards compatibility\n          output << error_message\n        end\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 108,
    "raw_source": "private def parse_liquid_tag(markup, parse_context)\n      liquid_tag_tokenizer = parse_context.new_tokenizer(\n        markup, start_line_number: parse_context.line_number, for_liquid_tag: true\n      )\n      parse_for_liquid_tag(liquid_tag_tokenizer, parse_context) do |end_tag_name, _end_tag_markup|\n        if end_tag_name\n          BlockBody.unknown_tag_in_liquid_tag(end_tag_name, parse_context)\n        end\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 119,
    "raw_source": "private def handle_invalid_tag_token(token, parse_context)\n      if token.end_with?('%}')\n        yield token, token\n      else\n        BlockBody.raise_missing_tag_terminator(token, parse_context)\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 127,
    "raw_source": "private def parse_for_document(tokenizer, parse_context, &block)\n      while (token = tokenizer.shift)\n        next if token.empty?\n        case\n        when token.start_with?(TAGSTART)\n          whitespace_handler(token, parse_context)\n          unless token =~ FullToken\n            return handle_invalid_tag_token(token, parse_context, &block)\n          end\n          tag_name = Regexp.last_match(2)\n          markup   = Regexp.last_match(4)\n\n          if parse_context.line_number\n            # newlines inside the tag should increase the line number,\n            # particularly important for multiline {% liquid %} tags\n            parse_context.line_number += Regexp.last_match(1).count(\"\\n\") + Regexp.last_match(3).count(\"\\n\")\n          end\n\n          if tag_name == 'liquid'\n            parse_liquid_tag(markup, parse_context)\n            next\n          end\n\n          unless (tag = parse_context.environment.tag_for_name(tag_name))\n            # end parsing if we reach an unknown tag and let the caller decide\n            # determine how to proceed\n            return yield tag_name, markup\n          end\n          new_tag = tag.parse(tag_name, markup, tokenizer, parse_context)\n          @blank &&= new_tag.blank?\n          @nodelist << new_tag\n        when token.start_with?(VARSTART)\n          whitespace_handler(token, parse_context)\n          @nodelist << create_variable(token, parse_context)\n          @blank = false\n        else\n          if parse_context.trim_whitespace\n            token.lstrip!\n          end\n          parse_context.trim_whitespace = false\n          @nodelist << token\n          @blank &&= token.match?(WhitespaceOrNothing)\n        end\n        parse_context.line_number = tokenizer.line_number\n      end\n\n      yield nil, nil\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 176,
    "raw_source": "def whitespace_handler(token, parse_context)\n      if token[2] == WhitespaceControl\n        previous_token = @nodelist.last\n        if previous_token.is_a?(String)\n          first_byte = previous_token.getbyte(0)\n          previous_token.rstrip!\n          if previous_token.empty? && parse_context[:bug_compatible_whitespace_trimming] && first_byte\n            previous_token << first_byte\n          end\n        end\n      end\n      parse_context.trim_whitespace = (token[-3] == WhitespaceControl)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 190,
    "raw_source": "def blank?\n      @blank\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 209,
    "raw_source": "def remove_blank_strings\n      raise \"remove_blank_strings only support being called on a blank block body\" unless @blank\n      @nodelist.reject! { |node| node.instance_of?(String) }\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 214,
    "raw_source": "def render(context)\n      render_to_output_buffer(context, +'')\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 218,
    "raw_source": "def render_to_output_buffer(context, output)\n      freeze unless frozen?\n\n      context.resource_limits.increment_render_score(@nodelist.length)\n\n      idx = 0\n      while (node = @nodelist[idx])\n        if node.instance_of?(String)\n          output << node\n        else\n          render_node(context, output, node)\n          # If we get an Interrupt that means the block must stop processing. An\n          # Interrupt is any command that stops block execution such as {% break %}\n          # or {% continue %}. These tags may also occur through Block or Include tags.\n          break if context.interrupt? # might have happened in a for-block\n        end\n        idx += 1\n\n        context.resource_limits.increment_write_score(output)\n      end\n\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 244,
    "raw_source": "def render_node(context, output, node)\n      BlockBody.render_node(context, output, node)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 248,
    "raw_source": "def create_variable(token, parse_context)\n      if token.end_with?(\"}}\")\n        i = 2\n        i = 3 if token[i] == \"-\"\n        parse_end = token.length - 3\n        parse_end -= 1 if token[parse_end] == \"-\"\n        markup_end = parse_end - i + 1\n        markup = markup_end <= 0 ? \"\" : token.slice(i, markup_end)\n\n        return Variable.new(markup, parse_context)\n      end\n\n      BlockBody.raise_missing_variable_terminator(token, parse_context)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 264,
    "raw_source": "def raise_missing_tag_terminator(token, parse_context)\n      BlockBody.raise_missing_tag_terminator(token, parse_context)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/block_body.rb",
    "start_line": 269,
    "raw_source": "def raise_missing_variable_terminator(token, parse_context)\n      BlockBody.raise_missing_variable_terminator(token, parse_context)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 36,
    "raw_source": "def initialize(method_name, to_s)\n        @method_name = method_name\n        @to_s = to_s\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 47,
    "raw_source": "def self.operators\n      @@operators\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 51,
    "raw_source": "def self.parse_expression(parse_context, markup)\n      @@method_literals[markup] || parse_context.parse_expression(markup)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 58,
    "raw_source": "def initialize(left = nil, operator = nil, right = nil)\n      @left     = left\n      @operator = operator\n      @right    = right\n\n      @child_relation  = nil\n      @child_condition = nil\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 67,
    "raw_source": "def evaluate(context = deprecated_default_context)\n      condition = self\n      result = nil\n      loop do\n        result = interpret_condition(condition.left, condition.right, condition.operator, context)\n\n        case condition.child_relation\n        when :or\n          break if Liquid::Utils.to_liquid_value(result)\n        when :and\n          break unless Liquid::Utils.to_liquid_value(result)\n        else\n          break\n        end\n        condition = condition.child_condition\n      end\n      result\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 86,
    "raw_source": "def or(condition)\n      @child_relation  = :or\n      @child_condition = condition\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 91,
    "raw_source": "def and(condition)\n      @child_relation  = :and\n      @child_condition = condition\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 96,
    "raw_source": "def attach(attachment)\n      @attachment = attachment\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 100,
    "raw_source": "def else?\n      false\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 104,
    "raw_source": "def inspect\n      \"#<Condition #{[@left, @operator, @right].compact.join(' ')}>\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 114,
    "raw_source": "def equal_variables(left, right)\n      if left.is_a?(MethodLiteral)\n        if right.respond_to?(left.method_name)\n          return right.send(left.method_name)\n        else\n          return nil\n        end\n      end\n\n      if right.is_a?(MethodLiteral)\n        if left.respond_to?(right.method_name)\n          return left.send(right.method_name)\n        else\n          return nil\n        end\n      end\n\n      left == right\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 134,
    "raw_source": "def interpret_condition(left, right, op, context)\n      # If the operator is empty this means that the decision statement is just\n      # a single variable. We can just poll this variable from the context and\n      # return this as the result.\n      return context.evaluate(left) if op.nil?\n\n      left  = Liquid::Utils.to_liquid_value(context.evaluate(left))\n      right = Liquid::Utils.to_liquid_value(context.evaluate(right))\n\n      operation = self.class.operators[op] || raise(Liquid::ArgumentError, \"Unknown operator #{op}\")\n\n      if operation.respond_to?(:call)\n        operation.call(self, left, right)\n      elsif left.respond_to?(operation) && right.respond_to?(operation) && !left.is_a?(Hash) && !right.is_a?(Hash)\n        begin\n          left.send(operation, right)\n        rescue ::ArgumentError => e\n          raise Liquid::ArgumentError, e.message\n        end\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 156,
    "raw_source": "def deprecated_default_context\n      warn(\"DEPRECATION WARNING: Condition#evaluate without a context argument is deprecated\" \\\n        \" and will be removed from Liquid 6.0.0.\")\n      Context.new\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 163,
    "raw_source": "def children\n        [\n          @node.left,\n          @node.right,\n          @node.child_condition,\n          @node.attachment\n        ].compact\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 175,
    "raw_source": "def else?\n      true\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/condition.rb",
    "start_line": 179,
    "raw_source": "def evaluate(_context)\n      true\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 21,
    "raw_source": "def self.build(environment: Environment.default, environments: {}, outer_scope: {}, registers: {}, rethrow_errors: false, resource_limits: nil, static_environments: {}, &block)\n      new(environments, outer_scope, registers, rethrow_errors, resource_limits, static_environments, environment, &block)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 25,
    "raw_source": "def initialize(environments = {}, outer_scope = {}, registers = {}, rethrow_errors = false, resource_limits = nil, static_environments = {}, environment = Environment.default)\n      @environment = environment\n      @environments = [environments]\n      @environments.flatten!\n\n      @static_environments = [static_environments].flatten(1).freeze\n      @scopes              = [outer_scope || {}]\n      @registers           = registers.is_a?(Registers) ? registers : Registers.new(registers)\n      @errors              = []\n      @partial             = false\n      @strict_variables    = false\n      @resource_limits     = resource_limits || ResourceLimits.new(environment.default_resource_limits)\n      @base_scope_depth    = 0\n      @interrupts          = []\n      @filters             = []\n      @global_filter       = nil\n      @disabled_tags       = {}\n\n      # Instead of constructing new StringScanner objects for each Expression parse,\n      # we recycle the same one.\n      @string_scanner = StringScanner.new(\"\")\n\n      @registers.static[:cached_partials] ||= {}\n      @registers.static[:file_system] ||= environment.file_system\n      @registers.static[:template_factory] ||= Liquid::TemplateFactory.new\n\n      self.exception_renderer = environment.exception_renderer\n      if rethrow_errors\n        self.exception_renderer = Liquid::RAISE_EXCEPTION_LAMBDA\n      end\n\n      yield self if block_given?\n\n      # Do this last, since it could result in this object being passed to a Proc in the environment\n      squash_instance_assigns_with_environments\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 63,
    "raw_source": "def warnings\n      @warnings ||= []\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 67,
    "raw_source": "def strainer\n      @strainer ||= @environment.create_strainer(self, @filters)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 75,
    "raw_source": "def add_filters(filters)\n      filters = [filters].flatten.compact\n      @filters += filters\n      @strainer = nil\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 81,
    "raw_source": "def apply_global_filter(obj)\n      global_filter.nil? ? obj : global_filter.call(obj)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 86,
    "raw_source": "def interrupt?\n      !@interrupts.empty?\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 91,
    "raw_source": "def push_interrupt(e)\n      @interrupts.push(e)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 96,
    "raw_source": "def pop_interrupt\n      @interrupts.pop\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 100,
    "raw_source": "def handle_error(e, line_number = nil)\n      e = internal_error unless e.is_a?(Liquid::Error)\n      e.template_name ||= template_name\n      e.line_number   ||= line_number\n      errors.push(e)\n      exception_renderer.call(e).to_s\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 108,
    "raw_source": "def invoke(method, *args)\n      strainer.invoke(method, *args).to_liquid\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 113,
    "raw_source": "def push(new_scope = {})\n      @scopes.unshift(new_scope)\n      check_overflow\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 119,
    "raw_source": "def merge(new_scopes)\n      @scopes[0].merge!(new_scopes)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 124,
    "raw_source": "def pop\n      raise ContextError if @scopes.size == 1\n      @scopes.shift\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 137,
    "raw_source": "def stack(new_scope = {})\n      push(new_scope)\n      yield\n    ensure\n      pop\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 146,
    "raw_source": "def new_isolated_subcontext\n      check_overflow\n\n      self.class.build(\n        environment: @environment,\n        resource_limits: resource_limits,\n        static_environments: static_environments,\n        registers: Registers.new(registers),\n      ).tap do |subcontext|\n        subcontext.base_scope_depth   = base_scope_depth + 1\n        subcontext.exception_renderer = exception_renderer\n        subcontext.filters  = @filters\n        subcontext.strainer = nil\n        subcontext.errors   = errors\n        subcontext.warnings = warnings\n        subcontext.disabled_tags = @disabled_tags\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 165,
    "raw_source": "def clear_instance_assigns\n      @scopes[0] = {}\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 170,
    "raw_source": "def []=(key, value)\n      @scopes[0][key] = value\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 182,
    "raw_source": "def [](expression)\n      evaluate(Expression.parse(expression, @string_scanner))\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 186,
    "raw_source": "def key?(key)\n      self[key] != nil\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 190,
    "raw_source": "def evaluate(object)\n      object.respond_to?(:evaluate) ? object.evaluate(self) : object\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 195,
    "raw_source": "def find_variable(key, raise_on_not_found: true)\n      # This was changed from find() to find_index() because this is a very hot\n      # path and find_index() is optimized in MRI to reduce object allocation\n      index = @scopes.find_index { |s| s.key?(key) }\n\n      variable = if index\n        lookup_and_evaluate(@scopes[index], key, raise_on_not_found: raise_on_not_found)\n      else\n        try_variable_find_in_environments(key, raise_on_not_found: raise_on_not_found)\n      end\n\n      # update variable's context before invoking #to_liquid\n      variable.context = self if variable.respond_to?(:context=)\n\n      liquid_variable = variable.to_liquid\n\n      liquid_variable.context = self if variable != liquid_variable && liquid_variable.respond_to?(:context=)\n\n      liquid_variable\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 216,
    "raw_source": "def lookup_and_evaluate(obj, key, raise_on_not_found: true)\n      if @strict_variables && raise_on_not_found && obj.respond_to?(:key?) && !obj.key?(key)\n        raise Liquid::UndefinedVariable, \"undefined variable #{key}\"\n      end\n\n      value = obj[key]\n\n      if value.is_a?(Proc) && obj.respond_to?(:[]=)\n        obj[key] = value.arity == 0 ? value.call : value.call(self)\n      else\n        value\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 230,
    "raw_source": "def with_disabled_tags(tag_names)\n      tag_names.each do |name|\n        @disabled_tags[name] = @disabled_tags.fetch(name, 0) + 1\n      end\n      yield\n    ensure\n      tag_names.each do |name|\n        @disabled_tags[name] -= 1\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 241,
    "raw_source": "def tag_disabled?(tag_name)\n      @disabled_tags.fetch(tag_name, 0) > 0\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 253,
    "raw_source": "def try_variable_find_in_environments(key, raise_on_not_found:)\n      @environments.each do |environment|\n        found_variable = lookup_and_evaluate(environment, key, raise_on_not_found: raise_on_not_found)\n        if !found_variable.nil? || @strict_variables && raise_on_not_found\n          return found_variable\n        end\n      end\n      @static_environments.each do |environment|\n        found_variable = lookup_and_evaluate(environment, key, raise_on_not_found: raise_on_not_found)\n        if !found_variable.nil? || @strict_variables && raise_on_not_found\n          return found_variable\n        end\n      end\n      nil\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 269,
    "raw_source": "def check_overflow\n      raise StackLevelError, \"Nesting too deep\" if overflow?\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 273,
    "raw_source": "def overflow?\n      base_scope_depth + @scopes.length > Block::MAX_DEPTH\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 277,
    "raw_source": "def internal_error\n      # raise and catch to set backtrace and cause on exception\n      raise Liquid::InternalError, 'internal'\n    rescue Liquid::InternalError => exc\n      exc\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/context.rb",
    "start_line": 284,
    "raw_source": "def squash_instance_assigns_with_environments\n      @scopes.last.each_key do |k|\n        @environments.each do |env|\n          if env.key?(k)\n            scopes.last[k] = lookup_and_evaluate(env, k)\n            break\n          end\n        end\n      end\n    end # squash_instance_assigns_with_environments"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/deprecations.rb",
    "start_line": 12,
    "raw_source": "def warn(name, alternative)\n        return if warned.include?(name)\n\n        warned << name\n\n        caller_location = caller_locations(2, 1).first\n        Warning.warn(\"[DEPRECATION] #{name} is deprecated. Use #{alternative} instead. Called from #{caller_location}\\n\")\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/document.rb",
    "start_line": 5,
    "raw_source": "def self.parse(tokens, parse_context)\n      doc = new(parse_context)\n      doc.parse(tokens, parse_context)\n      doc\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/document.rb",
    "start_line": 13,
    "raw_source": "def initialize(parse_context)\n      @parse_context = parse_context\n      @body = new_body\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/document.rb",
    "start_line": 18,
    "raw_source": "def nodelist\n      @body.nodelist\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/document.rb",
    "start_line": 22,
    "raw_source": "def parse(tokenizer, parse_context)\n      while parse_body(tokenizer)\n      end\n      @body.freeze\n    rescue SyntaxError => e\n      e.line_number ||= parse_context.line_number\n      raise\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/document.rb",
    "start_line": 31,
    "raw_source": "def unknown_tag(tag, _markup, _tokenizer)\n      case tag\n      when 'else', 'end'\n        raise SyntaxError, parse_context.locale.t(\"errors.syntax.unexpected_outer_tag\", tag: tag)\n      else\n        raise SyntaxError, parse_context.locale.t(\"errors.syntax.unknown_tag\", tag: tag)\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/document.rb",
    "start_line": 40,
    "raw_source": "def render_to_output_buffer(context, output)\n      @body.render_to_output_buffer(context, output)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/document.rb",
    "start_line": 44,
    "raw_source": "def render(context)\n      render_to_output_buffer(context, +'')\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/document.rb",
    "start_line": 50,
    "raw_source": "def new_body\n      parse_context.new_block_body\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/document.rb",
    "start_line": 54,
    "raw_source": "def parse_body(tokenizer)\n      @body.parse(tokenizer, parse_context) do |unknown_tag_name, unknown_tag_markup|\n        if unknown_tag_name\n          unknown_tag(unknown_tag_name, unknown_tag_markup, tokenizer)\n          true\n        else\n          false\n        end\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/drop.rb",
    "start_line": 28,
    "raw_source": "def initialize\n      @context = nil\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/drop.rb",
    "start_line": 33,
    "raw_source": "def liquid_method_missing(method)\n      return nil unless @context&.strict_variables\n      raise Liquid::UndefinedDropMethod, \"undefined method #{method}\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/drop.rb",
    "start_line": 39,
    "raw_source": "def invoke_drop(method_or_key)\n      if self.class.invokable?(method_or_key)\n        send(method_or_key)\n      else\n        liquid_method_missing(method_or_key)\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/drop.rb",
    "start_line": 47,
    "raw_source": "def key?(_name)\n      true\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/drop.rb",
    "start_line": 51,
    "raw_source": "def inspect\n      self.class.to_s\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/drop.rb",
    "start_line": 55,
    "raw_source": "def to_liquid\n      self\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/drop.rb",
    "start_line": 59,
    "raw_source": "def to_s\n      self.class.name\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/drop.rb",
    "start_line": 66,
    "raw_source": "def self.invokable?(method_name)\n      invokable_methods.include?(method_name.to_s)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/drop.rb",
    "start_line": 70,
    "raw_source": "def self.invokable_methods\n      @invokable_methods ||= begin\n        blacklist = Liquid::Drop.public_instance_methods + [:each]\n\n        if include?(Enumerable)\n          blacklist += Enumerable.public_instance_methods\n          blacklist -= [:sort, :count, :first, :min, :max]\n        end\n\n        whitelist = [:to_liquid] + (public_instance_methods - blacklist)\n        Set.new(whitelist.map(&:to_s))\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/environment.rb",
    "start_line": 42,
    "raw_source": "def build(tags: nil, file_system: nil, error_mode: nil, exception_renderer: nil)\n        ret = new\n        ret.tags = tags if tags\n        ret.file_system = file_system if file_system\n        ret.error_mode = error_mode if error_mode\n        ret.exception_renderer = exception_renderer if exception_renderer\n        yield ret if block_given?\n        ret.freeze\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/environment.rb",
    "start_line": 55,
    "raw_source": "def default\n        @default ||= new\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/environment.rb",
    "start_line": 65,
    "raw_source": "def dangerously_override(environment)\n        original_default = @default\n        @default = environment\n        yield\n      ensure\n        @default = original_default\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/environment.rb",
    "start_line": 76,
    "raw_source": "def initialize\n      @tags = Tags::STANDARD_TAGS.dup\n      @error_mode = :lax\n      @strainer_template = Class.new(StrainerTemplate).tap do |klass|\n        klass.add_filter(StandardFilters)\n      end\n      @exception_renderer = ->(exception) { exception }\n      @file_system = BlankFileSystem.new\n      @default_resource_limits = Const::EMPTY_HASH\n      @strainer_template_class_cache = {}\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/environment.rb",
    "start_line": 93,
    "raw_source": "def register_tag(name, klass)\n      @tags[name] = klass\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/environment.rb",
    "start_line": 101,
    "raw_source": "def register_filter(filter)\n      @strainer_template_class_cache.clear\n      @strainer_template.add_filter(filter)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/environment.rb",
    "start_line": 110,
    "raw_source": "def register_filters(filters)\n      @strainer_template_class_cache.clear\n      filters.each { |f| @strainer_template.add_filter(f) }\n      self\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/environment.rb",
    "start_line": 124,
    "raw_source": "def create_strainer(context, filters = Const::EMPTY_ARRAY)\n      return @strainer_template.new(context) if filters.empty?\n\n      strainer_template = @strainer_template_class_cache[filters] ||= begin\n        klass = Class.new(@strainer_template)\n        filters.each { |f| klass.add_filter(f) }\n        klass\n      end\n\n      strainer_template.new(context)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/environment.rb",
    "start_line": 140,
    "raw_source": "def filter_method_names\n      @strainer_template.filter_method_names\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/environment.rb",
    "start_line": 148,
    "raw_source": "def tag_for_name(name)\n      @tags[name]\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/environment.rb",
    "start_line": 152,
    "raw_source": "def freeze\n      @tags.freeze\n      # TODO: freeze the tags, currently this is not possible because of liquid-c\n      # @strainer_template.freeze\n      super\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/errors.rb",
    "start_line": 9,
    "raw_source": "def to_s(with_prefix = true)\n      str = +\"\"\n      str << message_prefix if with_prefix\n      str << super()\n\n      if markup_context\n        str << \" \"\n        str << markup_context\n      end\n\n      str\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/errors.rb",
    "start_line": 24,
    "raw_source": "def message_prefix\n      str = +\"\"\n      str << if is_a?(SyntaxError)\n        \"Liquid syntax error\"\n      else\n        \"Liquid error\"\n      end\n\n      if line_number\n        str << \" (\"\n        str << template_name << \" \" if template_name\n        str << \"line \" << line_number.to_s << \")\"\n      end\n\n      str << \": \"\n      str\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/expression.rb",
    "start_line": 31,
    "raw_source": "def parse(markup, ss = StringScanner.new(\"\"), cache = nil)\n        return unless markup\n\n        markup = markup.strip # markup can be a frozen string\n\n        if (markup.start_with?('\"') && markup.end_with?('\"')) ||\n          (markup.start_with?(\"'\") && markup.end_with?(\"'\"))\n          return markup[1..-2]\n        elsif LITERALS.key?(markup)\n          return LITERALS[markup]\n        end\n\n        # Cache only exists during parsing\n        if cache\n          return cache[markup] if cache.key?(markup)\n\n          cache[markup] = inner_parse(markup, ss, cache).freeze\n        else\n          inner_parse(markup, ss, nil).freeze\n        end\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/expression.rb",
    "start_line": 53,
    "raw_source": "def inner_parse(markup, ss, cache)\n        if (markup.start_with?(\"(\") && markup.end_with?(\")\")) && markup =~ RANGES_REGEX\n          return RangeLookup.parse(\n            Regexp.last_match(1),\n            Regexp.last_match(2),\n            ss,\n            cache,\n          )\n        end\n\n        if (num = parse_number(markup, ss))\n          num\n        else\n          VariableLookup.parse(markup, ss, cache)\n        end\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/expression.rb",
    "start_line": 70,
    "raw_source": "def parse_number(markup, ss)\n        # check if the markup is simple integer or float\n        case markup\n        when INTEGER_REGEX\n          return Integer(markup, 10)\n        when FLOAT_REGEX\n          return markup.to_f\n        end\n\n        ss.string = markup\n        # the first byte must be a digit or  a dash\n        byte = ss.scan_byte\n\n        return false if byte != DASH && (byte < ZERO || byte > NINE)\n\n        if byte == DASH\n          peek_byte = ss.peek_byte\n\n          # if it starts with a dash, the next byte must be a digit\n          return false if peek_byte.nil? || !(peek_byte >= ZERO && peek_byte <= NINE)\n        end\n\n        # The markup could be a float with multiple dots\n        first_dot_pos = nil\n        num_end_pos = nil\n\n        while (byte = ss.scan_byte)\n          return false if byte != DOT && (byte < ZERO || byte > NINE)\n\n          # we found our number and now we are just scanning the rest of the string\n          next if num_end_pos\n\n          if byte == DOT\n            if first_dot_pos.nil?\n              first_dot_pos = ss.pos\n            else\n              # we found another dot, so we know that the number ends here\n              num_end_pos = ss.pos - 1\n            end\n          end\n        end\n\n        num_end_pos = markup.length if ss.eos?\n\n        if num_end_pos\n          # number ends with a number \"123.123\"\n          markup.byteslice(0, num_end_pos).to_f\n        else\n          # number ends with a dot \"123.\"\n          markup.byteslice(0, first_dot_pos).to_f\n        end\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/extensions.rb",
    "start_line": 7,
    "raw_source": "def to_liquid\n    self\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/extensions.rb",
    "start_line": 13,
    "raw_source": "def to_liquid\n    to_s\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/extensions.rb",
    "start_line": 19,
    "raw_source": "def to_liquid\n    self\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/extensions.rb",
    "start_line": 25,
    "raw_source": "def to_liquid\n    self\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/extensions.rb",
    "start_line": 31,
    "raw_source": "def to_liquid\n    self\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/extensions.rb",
    "start_line": 37,
    "raw_source": "def to_liquid\n    self\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/extensions.rb",
    "start_line": 43,
    "raw_source": "def to_liquid\n    self\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/extensions.rb",
    "start_line": 49,
    "raw_source": "def to_liquid\n    self\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/extensions.rb",
    "start_line": 55,
    "raw_source": "def to_liquid\n    self\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/extensions.rb",
    "start_line": 61,
    "raw_source": "def to_liquid # :nodoc:\n    self\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/extensions.rb",
    "start_line": 67,
    "raw_source": "def to_liquid # :nodoc:\n    self\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/extensions.rb",
    "start_line": 73,
    "raw_source": "def to_liquid # :nodoc:\n    self\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/file_system.rb",
    "start_line": 19,
    "raw_source": "def read_template_file(_template_path)\n      raise FileSystemError, \"This liquid context does not allow includes.\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/file_system.rb",
    "start_line": 49,
    "raw_source": "def initialize(root, pattern = \"_%s.liquid\")\n      @root    = root\n      @pattern = pattern\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/file_system.rb",
    "start_line": 54,
    "raw_source": "def read_template_file(template_path)\n      full_path = full_path(template_path)\n      raise FileSystemError, \"No such template '#{template_path}'\" unless File.exist?(full_path)\n\n      File.read(full_path)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/file_system.rb",
    "start_line": 61,
    "raw_source": "def full_path(template_path)\n      raise FileSystemError, \"Illegal template name '#{template_path}'\" unless %r{\\A[^./][a-zA-Z0-9_/]+\\z}.match?(template_path)\n\n      full_path = if template_path.include?('/')\n        File.join(root, File.dirname(template_path), @pattern % File.basename(template_path))\n      else\n        File.join(root, @pattern % template_path)\n      end\n\n      raise FileSystemError, \"Illegal template path '#{File.expand_path(full_path)}'\" unless File.expand_path(full_path).start_with?(File.expand_path(root))\n\n      full_path\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/forloop_drop.rb",
    "start_line": 10,
    "raw_source": "def initialize(name, length, parentloop)\n      @name       = name\n      @length     = length\n      @parentloop = parentloop\n      @index      = 0\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/forloop_drop.rb",
    "start_line": 39,
    "raw_source": "def index\n      @index + 1\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/forloop_drop.rb",
    "start_line": 47,
    "raw_source": "def index0\n      @index\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/forloop_drop.rb",
    "start_line": 55,
    "raw_source": "def rindex\n      @length - @index\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/forloop_drop.rb",
    "start_line": 63,
    "raw_source": "def rindex0\n      @length - @index - 1\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/forloop_drop.rb",
    "start_line": 71,
    "raw_source": "def first\n      @index == 0\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/forloop_drop.rb",
    "start_line": 79,
    "raw_source": "def last\n      @index == @length - 1\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/forloop_drop.rb",
    "start_line": 85,
    "raw_source": "def increment!\n      @index += 1\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/i18n.rb",
    "start_line": 13,
    "raw_source": "def initialize(path = DEFAULT_LOCALE)\n      @path = path\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/i18n.rb",
    "start_line": 17,
    "raw_source": "def translate(name, vars = {})\n      interpolate(deep_fetch_translation(name), vars)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/i18n.rb",
    "start_line": 22,
    "raw_source": "def locale\n      @locale ||= YAML.load_file(@path)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/i18n.rb",
    "start_line": 28,
    "raw_source": "def interpolate(name, vars)\n      name.gsub(/%\\{(\\w+)\\}/) do\n        # raise TranslationError, \"Undefined key #{$1} for interpolation in translation #{name}\"  unless vars[$1.to_sym]\n        (vars[Regexp.last_match(1).to_sym]).to_s\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/i18n.rb",
    "start_line": 35,
    "raw_source": "def deep_fetch_translation(name)\n      name.split('.').reduce(locale) do |level, cur|\n        level[cur] || raise(TranslationError, \"Translation for #{name} does not exist in locale #{path}\")\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/interrupts.rb",
    "start_line": 8,
    "raw_source": "def initialize(message = nil)\n      @message = message || \"interrupt\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/lexer.rb",
    "start_line": 103,
    "raw_source": "def tokenize(ss)\n        output = []\n\n        until ss.eos?\n          ss.skip(WHITESPACE_OR_NOTHING)\n\n          break if ss.eos?\n\n          start_pos = ss.pos\n          peeked = ss.peek_byte\n\n          if (special = SPECIAL_TABLE[peeked])\n            ss.scan_byte\n            # Special case for \"..\"\n            if special == DOT && ss.peek_byte == DOT_ORD\n              ss.scan_byte\n              output << DOTDOT\n            elsif special == DASH\n              # Special case for negative numbers\n              if (peeked_byte = ss.peek_byte) && NUMBER_TABLE[peeked_byte]\n                ss.pos -= 1\n                output << [:number, ss.scan(NUMBER_LITERAL)]\n              else\n                output << special\n              end\n            else\n              output << special\n            end\n          elsif (sub_table = TWO_CHARS_COMPARISON_JUMP_TABLE[peeked])\n            ss.scan_byte\n            if (peeked_byte = ss.peek_byte) && (found = sub_table[peeked_byte])\n              output << found\n              ss.scan_byte\n            else\n              raise_syntax_error(start_pos, ss)\n            end\n          elsif (sub_table = COMPARISON_JUMP_TABLE[peeked])\n            ss.scan_byte\n            if (peeked_byte = ss.peek_byte) && (found = sub_table[peeked_byte])\n              output << found\n              ss.scan_byte\n            else\n              output << SINGLE_COMPARISON_TOKENS[peeked]\n            end\n          else\n            type, pattern = NEXT_MATCHER_JUMP_TABLE[peeked]\n\n            if type && (t = ss.scan(pattern))\n              # Special case for \"contains\"\n              output << if type == :id && t == \"contains\" && output.last&.first != :dot\n                COMPARISON_CONTAINS\n              else\n                [type, t]\n              end\n            else\n              raise_syntax_error(start_pos, ss)\n            end\n          end\n        end\n        # rubocop:enable Metrics/BlockNesting\n        output << EOS\n      rescue ::ArgumentError => e\n        if e.message == \"invalid byte sequence in #{ss.string.encoding}\"\n          raise SyntaxError, \"Invalid byte sequence in #{ss.string.encoding}\"\n        else\n          raise\n        end\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/lexer.rb",
    "start_line": 172,
    "raw_source": "def raise_syntax_error(start_pos, ss)\n        ss.pos = start_pos\n        # the character could be a UTF-8 character, use getch to get all the bytes\n        raise SyntaxError, \"Unexpected character #{ss.getch}\"\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parse_context.rb",
    "start_line": 8,
    "raw_source": "def initialize(options = Const::EMPTY_HASH)\n      @environment = options.fetch(:environment, Environment.default)\n      @template_options = options ? options.dup : {}\n\n      @locale   = @template_options[:locale] ||= I18n.new\n      @warnings = []\n\n      # constructing new StringScanner in Lexer, Tokenizer, etc is expensive\n      # This StringScanner will be shared by all of them\n      @string_scanner = StringScanner.new(\"\")\n\n      @expression_cache = if options[:expression_cache].nil?\n        {}\n      elsif options[:expression_cache].respond_to?(:[]) && options[:expression_cache].respond_to?(:[]=)\n        options[:expression_cache]\n      elsif options[:expression_cache]\n        {}\n      end\n\n      self.depth   = 0\n      self.partial = false\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parse_context.rb",
    "start_line": 31,
    "raw_source": "def [](option_key)\n      @options[option_key]\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parse_context.rb",
    "start_line": 35,
    "raw_source": "def new_block_body\n      Liquid::BlockBody.new\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parse_context.rb",
    "start_line": 39,
    "raw_source": "def new_parser(input)\n      @string_scanner.string = input\n      Parser.new(@string_scanner)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parse_context.rb",
    "start_line": 44,
    "raw_source": "def new_tokenizer(source, start_line_number: nil, for_liquid_tag: false)\n      Tokenizer.new(\n        source: source,\n        string_scanner: @string_scanner,\n        line_number: start_line_number,\n        for_liquid_tag: for_liquid_tag,\n      )\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parse_context.rb",
    "start_line": 53,
    "raw_source": "def parse_expression(markup)\n      Expression.parse(markup, @string_scanner, @expression_cache)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parse_context.rb",
    "start_line": 57,
    "raw_source": "def partial=(value)\n      @partial = value\n      @options = value ? partial_options : @template_options\n\n      @error_mode = @options[:error_mode] || @environment.error_mode\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parse_context.rb",
    "start_line": 64,
    "raw_source": "def partial_options\n      @partial_options ||= begin\n        dont_pass = @template_options[:include_options_blacklist]\n        if dont_pass == true\n          { locale: locale }\n        elsif dont_pass.is_a?(Array)\n          @template_options.reject { |k, _v| dont_pass.include?(k) }\n        else\n          @template_options\n        end\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parse_tree_visitor.rb",
    "start_line": 5,
    "raw_source": "def self.for(node, callbacks = Hash.new(proc {}))\n      if defined?(node.class::ParseTreeVisitor)\n        node.class::ParseTreeVisitor\n      else\n        self\n      end.new(node, callbacks)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parse_tree_visitor.rb",
    "start_line": 13,
    "raw_source": "def initialize(node, callbacks)\n      @node      = node\n      @callbacks = callbacks\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parse_tree_visitor.rb",
    "start_line": 18,
    "raw_source": "def add_callback_for(*classes, &block)\n      callback = block\n      callback = ->(node, _) { yield node } if block.arity.abs == 1\n      callback = ->(_, _) { yield } if block.arity.zero?\n      classes.each { |klass| @callbacks[klass] = callback }\n      self\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parse_tree_visitor.rb",
    "start_line": 26,
    "raw_source": "def visit(context = nil)\n      children.map do |node|\n        item, new_context = @callbacks[node.class].call(node, context)\n        [\n          item,\n          ParseTreeVisitor.for(node, @callbacks).visit(new_context || context),\n        ]\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parse_tree_visitor.rb",
    "start_line": 38,
    "raw_source": "def children\n      @node.respond_to?(:nodelist) ? Array(@node.nodelist) : Const::EMPTY_ARRAY\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parser.rb",
    "start_line": 5,
    "raw_source": "def initialize(input)\n      ss = input.is_a?(StringScanner) ? input : StringScanner.new(input)\n      @tokens = Lexer.tokenize(ss)\n      @p      = 0 # pointer to current location\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parser.rb",
    "start_line": 11,
    "raw_source": "def jump(point)\n      @p = point\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parser.rb",
    "start_line": 15,
    "raw_source": "def consume(type = nil)\n      token = @tokens[@p]\n      if type && token[0] != type\n        raise SyntaxError, \"Expected #{type} but found #{@tokens[@p].first}\"\n      end\n      @p += 1\n      token[1]\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parser.rb",
    "start_line": 27,
    "raw_source": "def consume?(type)\n      token = @tokens[@p]\n      return false unless token && token[0] == type\n      @p += 1\n      token[1]\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parser.rb",
    "start_line": 35,
    "raw_source": "def id?(str)\n      token = @tokens[@p]\n      return false unless token && token[0] == :id\n      return false unless token[1] == str\n      @p += 1\n      token[1]\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parser.rb",
    "start_line": 43,
    "raw_source": "def look(type, ahead = 0)\n      tok = @tokens[@p + ahead]\n      return false unless tok\n      tok[0] == type\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parser.rb",
    "start_line": 49,
    "raw_source": "def expression\n      token = @tokens[@p]\n      case token[0]\n      when :id\n        str = consume\n        str << variable_lookups\n      when :open_square\n        str = consume.dup\n        str << expression\n        str << consume(:close_square)\n        str << variable_lookups\n      when :string, :number\n        consume\n      when :open_round\n        consume\n        first = expression\n        consume(:dotdot)\n        last = expression\n        consume(:close_round)\n        \"(#{first}..#{last})\"\n      else\n        raise SyntaxError, \"#{token} is not a valid expression\"\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parser.rb",
    "start_line": 74,
    "raw_source": "def argument\n      str = +\"\"\n      # might be a keyword argument (identifier: expression)\n      if look(:id) && look(:colon, 1)\n        str << consume << consume << ' '\n      end\n\n      str << expression\n      str\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parser.rb",
    "start_line": 85,
    "raw_source": "def variable_lookups\n      str = +\"\"\n      loop do\n        if look(:open_square)\n          str << consume\n          str << expression\n          str << consume(:close_square)\n        elsif look(:dot)\n          str << consume\n          str << consume(:id)\n        else\n          break\n        end\n      end\n      str\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parser_switching.rb",
    "start_line": 5,
    "raw_source": "def strict_parse_with_error_mode_fallback(markup)\n      strict_parse_with_error_context(markup)\n    rescue SyntaxError => e\n      case parse_context.error_mode\n      when :strict\n        raise\n      when :warn\n        parse_context.warnings << e\n      end\n      lax_parse(markup)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parser_switching.rb",
    "start_line": 17,
    "raw_source": "def parse_with_selected_parser(markup)\n      case parse_context.error_mode\n      when :strict then strict_parse_with_error_context(markup)\n      when :lax    then lax_parse(markup)\n      when :warn\n        begin\n          strict_parse_with_error_context(markup)\n        rescue SyntaxError => e\n          parse_context.warnings << e\n          lax_parse(markup)\n        end\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parser_switching.rb",
    "start_line": 33,
    "raw_source": "def strict_parse_with_error_context(markup)\n      strict_parse(markup)\n    rescue SyntaxError => e\n      e.line_number    = line_number\n      e.markup_context = markup_context(markup)\n      raise e\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/parser_switching.rb",
    "start_line": 41,
    "raw_source": "def markup_context(markup)\n      \"in \\\"#{markup.strip}\\\"\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/partial_cache.rb",
    "start_line": 5,
    "raw_source": "def self.load(template_name, context:, parse_context:)\n      cached_partials = context.registers[:cached_partials]\n      cache_key = \"#{template_name}:#{parse_context.error_mode}\"\n      cached = cached_partials[cache_key]\n      return cached if cached\n\n      file_system = context.registers[:file_system]\n      source      = file_system.read_template_file(template_name)\n\n      parse_context.partial = true\n\n      template_factory = context.registers[:template_factory]\n      template = template_factory.for(template_name)\n\n      begin\n        partial = template.parse(source, parse_context)\n      rescue Liquid::Error => e\n        e.template_name = template&.name || template_name\n        raise e\n      end\n\n      partial.name ||= template_name\n\n      cached_partials[cache_key] = partial\n    ensure\n      parse_context.partial = false\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/profiler.rb",
    "start_line": 54,
    "raw_source": "def initialize(code: nil, template_name: nil, line_number: nil)\n        @code = code\n        @template_name = template_name\n        @line_number = line_number\n        @children = []\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/profiler.rb",
    "start_line": 61,
    "raw_source": "def self_time\n        @self_time ||= begin\n          total_children_time = 0.0\n          @children.each do |child|\n            total_children_time += child.total_time\n          end\n          @total_time - total_children_time\n        end\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/profiler.rb",
    "start_line": 75,
    "raw_source": "def initialize\n      @root_children = []\n      @current_children = nil\n      @total_time = 0.0\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/profiler.rb",
    "start_line": 81,
    "raw_source": "def profile(template_name, &block)\n      # nested renders are done from a tag that already has a timing node\n      return yield if @current_children\n\n      root_children = @root_children\n      render_idx = root_children.length\n      begin\n        @current_children = root_children\n        profile_node(template_name, &block)\n      ensure\n        @current_children = nil\n        if (timing = root_children[render_idx])\n          @total_time += timing.total_time\n        end\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/profiler.rb",
    "start_line": 98,
    "raw_source": "def children\n      children = @root_children\n      if children.length == 1\n        children.first.children\n      else\n        children\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/profiler.rb",
    "start_line": 107,
    "raw_source": "def each(&block)\n      children.each(&block)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/profiler.rb",
    "start_line": 111,
    "raw_source": "def [](idx)\n      children[idx]\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/profiler.rb",
    "start_line": 115,
    "raw_source": "def length\n      children.length\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/profiler.rb",
    "start_line": 119,
    "raw_source": "def profile_node(template_name, code: nil, line_number: nil)\n      timing = Timing.new(code: code, template_name: template_name, line_number: line_number)\n      parent_children = @current_children\n      start_time = monotonic_time\n      begin\n        @current_children = timing.children\n        yield\n      ensure\n        @current_children = parent_children\n        timing.total_time = monotonic_time - start_time\n        parent_children << timing\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/profiler.rb",
    "start_line": 135,
    "raw_source": "def monotonic_time\n      Process.clock_gettime(Process::CLOCK_MONOTONIC)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/profiler/hooks.rb",
    "start_line": 5,
    "raw_source": "def render_node(context, output, node)\n      if (profiler = context.profiler)\n        profiler.profile_node(context.template_name, code: node.raw, line_number: node.line_number) do\n          super\n        end\n      else\n        super\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/profiler/hooks.rb",
    "start_line": 18,
    "raw_source": "def render_to_output_buffer(context, output)\n      return super unless context.profiler\n      context.profiler.profile(context.template_name) { super }\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/profiler/hooks.rb",
    "start_line": 28,
    "raw_source": "def new_isolated_subcontext\n      new_context = super\n      new_context.profiler = profiler\n      new_context\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/range_lookup.rb",
    "start_line": 5,
    "raw_source": "def self.parse(start_markup, end_markup, string_scanner, cache = nil)\n      start_obj = Expression.parse(start_markup, string_scanner, cache)\n      end_obj   = Expression.parse(end_markup, string_scanner, cache)\n      if start_obj.respond_to?(:evaluate) || end_obj.respond_to?(:evaluate)\n        new(start_obj, end_obj)\n      else\n        begin\n          start_obj.to_i..end_obj.to_i\n        rescue NoMethodError\n          invalid_expr = start_markup unless start_obj.respond_to?(:to_i)\n          invalid_expr ||= end_markup unless end_obj.respond_to?(:to_i)\n          if invalid_expr\n            raise Liquid::SyntaxError, \"Invalid expression type '#{invalid_expr}' in range expression\"\n          end\n\n          raise\n        end\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/range_lookup.rb",
    "start_line": 27,
    "raw_source": "def initialize(start_obj, end_obj)\n      @start_obj = start_obj\n      @end_obj   = end_obj\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/range_lookup.rb",
    "start_line": 32,
    "raw_source": "def evaluate(context)\n      start_int = to_integer(context.evaluate(@start_obj))\n      end_int   = to_integer(context.evaluate(@end_obj))\n      start_int..end_int\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/range_lookup.rb",
    "start_line": 40,
    "raw_source": "def to_integer(input)\n      case input\n      when Integer\n        input\n      when NilClass, String\n        input.to_i\n      else\n        Utils.to_integer(input)\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/range_lookup.rb",
    "start_line": 52,
    "raw_source": "def children\n        [@node.start_obj, @node.end_obj]\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/registers.rb",
    "start_line": 7,
    "raw_source": "def initialize(registers = {})\n      @static = registers.is_a?(Registers) ? registers.static : registers\n      @changes = {}\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/registers.rb",
    "start_line": 12,
    "raw_source": "def []=(key, value)\n      @changes[key] = value\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/registers.rb",
    "start_line": 16,
    "raw_source": "def [](key)\n      if @changes.key?(key)\n        @changes[key]\n      else\n        @static[key]\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/registers.rb",
    "start_line": 24,
    "raw_source": "def delete(key)\n      @changes.delete(key)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/registers.rb",
    "start_line": 30,
    "raw_source": "def fetch(key, default = UNDEFINED, &block)\n      if @changes.key?(key)\n        @changes.fetch(key)\n      elsif default != UNDEFINED\n        if block_given?\n          @static.fetch(key, &block)\n        else\n          @static.fetch(key, default)\n        end\n      else\n        @static.fetch(key, &block)\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/registers.rb",
    "start_line": 44,
    "raw_source": "def key?(key)\n      @changes.key?(key) || @static.key?(key)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/resource_limits.rb",
    "start_line": 8,
    "raw_source": "def initialize(limits)\n      @render_length_limit = limits[:render_length_limit]\n      @render_score_limit  = limits[:render_score_limit]\n      @assign_score_limit  = limits[:assign_score_limit]\n      reset\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/resource_limits.rb",
    "start_line": 15,
    "raw_source": "def increment_render_score(amount)\n      @render_score += amount\n      raise_limits_reached if @render_score_limit && @render_score > @render_score_limit\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/resource_limits.rb",
    "start_line": 20,
    "raw_source": "def increment_assign_score(amount)\n      @assign_score += amount\n      raise_limits_reached if @assign_score_limit && @assign_score > @assign_score_limit\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/resource_limits.rb",
    "start_line": 26,
    "raw_source": "def increment_write_score(output)\n      if (last_captured = @last_capture_length)\n        captured = output.bytesize\n        increment = captured - last_captured\n        @last_capture_length = captured\n        increment_assign_score(increment)\n      elsif @render_length_limit && output.bytesize > @render_length_limit\n        raise_limits_reached\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/resource_limits.rb",
    "start_line": 37,
    "raw_source": "def raise_limits_reached\n      @reached_limit = true\n      raise MemoryError, \"Memory limits exceeded\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/resource_limits.rb",
    "start_line": 42,
    "raw_source": "def reached?\n      @reached_limit\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/resource_limits.rb",
    "start_line": 46,
    "raw_source": "def reset\n      @reached_limit = false\n      @last_capture_length = nil\n      @render_score = @assign_score = 0\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/resource_limits.rb",
    "start_line": 52,
    "raw_source": "def with_capture\n      old_capture_length = @last_capture_length\n      begin\n        @last_capture_length = 0\n        yield\n      ensure\n        @last_capture_length = old_capture_length\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 32,
    "raw_source": "def try_coerce_encoding(input, encoding:)\n        original_encoding = input.encoding\n        if input.encoding != encoding\n          input.force_encoding(encoding)\n          unless input.valid_encoding?\n            input.force_encoding(original_encoding)\n          end\n        end\n        input\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 54,
    "raw_source": "def size(input)\n      input.respond_to?(:size) ? input.size : 0\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 65,
    "raw_source": "def downcase(input)\n      Utils.to_s(input).downcase\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 76,
    "raw_source": "def upcase(input)\n      Utils.to_s(input).upcase\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 87,
    "raw_source": "def capitalize(input)\n      Utils.to_s(input).capitalize\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 98,
    "raw_source": "def escape(input)\n      CGI.escapeHTML(Utils.to_s(input)) unless input.nil?\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 110,
    "raw_source": "def escape_once(input)\n      Utils.to_s(input).gsub(HTML_ESCAPE_ONCE_REGEXP, HTML_ESCAPE)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 125,
    "raw_source": "def url_encode(input)\n      CGI.escape(Utils.to_s(input)) unless input.nil?\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 137,
    "raw_source": "def url_decode(input)\n      return if input.nil?\n\n      result = CGI.unescape(Utils.to_s(input))\n      raise Liquid::ArgumentError, \"invalid byte sequence in #{result.encoding}\" unless result.valid_encoding?\n\n      result\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 153,
    "raw_source": "def base64_encode(input)\n      Base64.strict_encode64(Utils.to_s(input))\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 164,
    "raw_source": "def base64_decode(input)\n      input = Utils.to_s(input)\n      StandardFilters.try_coerce_encoding(Base64.strict_decode64(input), encoding: input.encoding)\n    rescue ::ArgumentError\n      raise Liquid::ArgumentError, \"invalid base64 provided to base64_decode\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 178,
    "raw_source": "def base64_url_safe_encode(input)\n      Base64.urlsafe_encode64(Utils.to_s(input))\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 189,
    "raw_source": "def base64_url_safe_decode(input)\n      input = Utils.to_s(input)\n      StandardFilters.try_coerce_encoding(Base64.urlsafe_decode64(input), encoding: input.encoding)\n    rescue ::ArgumentError\n      raise Liquid::ArgumentError, \"invalid base64 provided to base64_url_safe_decode\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 206,
    "raw_source": "def slice(input, offset, length = nil)\n      offset = Utils.to_integer(offset)\n      length = length ? Utils.to_integer(length) : 1\n\n      begin\n        if input.is_a?(Array)\n          input.slice(offset, length) || []\n        else\n          Utils.to_s(input).slice(offset, length) || ''\n        end\n      rescue RangeError\n        if I64_RANGE.cover?(length) && I64_RANGE.cover?(offset)\n          raise # unexpected error\n        end\n        offset = offset.clamp(I64_RANGE)\n        length = length.clamp(I64_RANGE)\n        retry\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 236,
    "raw_source": "def truncate(input, length = 50, truncate_string = \"...\")\n      return if input.nil?\n      input_str = Utils.to_s(input)\n      length    = Utils.to_integer(length)\n\n      truncate_string_str = Utils.to_s(truncate_string)\n\n      l = length - truncate_string_str.length\n      l = 0 if l < 0\n\n      input_str.length > length ? input_str[0...l].concat(truncate_string_str) : input_str\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 263,
    "raw_source": "def truncatewords(input, words = 15, truncate_string = \"...\")\n      return if input.nil?\n      input = Utils.to_s(input)\n      words = Utils.to_integer(words)\n      words = 1 if words <= 0\n\n      wordlist = begin\n        input.split(\" \", words + 1)\n      rescue RangeError\n        # integer too big for String#split, but we can semantically assume no truncation is needed\n        return input if words + 1 > MAX_I32\n        raise # unexpected error\n      end\n      return input if wordlist.length <= words\n\n      wordlist.pop\n      truncate_string = Utils.to_s(truncate_string)\n      wordlist.join(\" \").concat(truncate_string)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 290,
    "raw_source": "def split(input, pattern)\n      pattern = Utils.to_s(pattern)\n      input = Utils.to_s(input)\n      input.split(pattern)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 303,
    "raw_source": "def strip(input)\n      input = Utils.to_s(input)\n      input.strip\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 315,
    "raw_source": "def lstrip(input)\n      input = Utils.to_s(input)\n      input.lstrip\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 327,
    "raw_source": "def rstrip(input)\n      input = Utils.to_s(input)\n      input.rstrip\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 339,
    "raw_source": "def strip_html(input)\n      input = Utils.to_s(input)\n      empty  = ''\n      result = input.gsub(STRIP_HTML_BLOCKS, empty)\n      result.gsub!(STRIP_HTML_TAGS, empty)\n      result\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 354,
    "raw_source": "def strip_newlines(input)\n      input = Utils.to_s(input)\n      input.gsub(/\\r?\\n/, '')\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 366,
    "raw_source": "def join(input, glue = ' ')\n      glue = Utils.to_s(glue)\n      InputIterator.new(input, context).join(glue)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 378,
    "raw_source": "def sort(input, property = nil)\n      ary = InputIterator.new(input, context)\n\n      return [] if ary.empty?\n\n      if property.nil?\n        ary.sort do |a, b|\n          nil_safe_compare(a, b)\n        end\n      elsif ary.all? { |el| el.respond_to?(:[]) }\n        begin\n          ary.sort { |a, b| nil_safe_compare(a[property], b[property]) }\n        rescue TypeError\n          raise_property_error(property)\n        end\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 407,
    "raw_source": "def sort_natural(input, property = nil)\n      ary = InputIterator.new(input, context)\n\n      return [] if ary.empty?\n\n      if property.nil?\n        ary.sort do |a, b|\n          nil_safe_casecmp(a, b)\n        end\n      elsif ary.all? { |el| el.respond_to?(:[]) }\n        begin\n          ary.sort { |a, b| nil_safe_casecmp(a[property], b[property]) }\n        rescue TypeError\n          raise_property_error(property)\n        end\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 434,
    "raw_source": "def where(input, property, target_value = nil)\n      filter_array(input, property, target_value) { |ary, &block| ary.select(&block) }\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 447,
    "raw_source": "def reject(input, property, target_value = nil)\n      filter_array(input, property, target_value) { |ary, &block| ary.reject(&block) }\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 460,
    "raw_source": "def has(input, property, target_value = nil)\n      filter_array(input, property, target_value, false) { |ary, &block| ary.any?(&block) }\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 473,
    "raw_source": "def find(input, property, target_value = nil)\n      filter_array(input, property, target_value, nil) { |ary, &block| ary.find(&block) }\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 486,
    "raw_source": "def find_index(input, property, target_value = nil)\n      filter_array(input, property, target_value, nil) { |ary, &block| ary.find_index(&block) }\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 497,
    "raw_source": "def uniq(input, property = nil)\n      ary = InputIterator.new(input, context)\n\n      if property.nil?\n        ary.uniq\n      elsif ary.empty? # The next two cases assume a non-empty array.\n        []\n      else\n        ary.uniq do |item|\n          item[property]\n        rescue TypeError\n          raise_property_error(property)\n        rescue NoMethodError\n          return nil unless item.respond_to?(:[])\n          raise\n        end\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 523,
    "raw_source": "def reverse(input)\n      ary = InputIterator.new(input, context)\n      ary.reverse\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 535,
    "raw_source": "def map(input, property)\n      InputIterator.new(input, context).map do |e|\n        e = e.call if e.is_a?(Proc)\n\n        if property == \"to_liquid\"\n          e\n        elsif e.respond_to?(:[])\n          r = e[property]\n          r.is_a?(Proc) ? r.call : r\n        end\n      end\n    rescue TypeError\n      raise_property_error(property)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 557,
    "raw_source": "def compact(input, property = nil)\n      ary = InputIterator.new(input, context)\n\n      if property.nil?\n        ary.compact\n      elsif ary.empty? # The next two cases assume a non-empty array.\n        []\n      else\n        ary.reject do |item|\n          item[property].nil?\n        rescue TypeError\n          raise_property_error(property)\n        rescue NoMethodError\n          return nil unless item.respond_to?(:[])\n          raise\n        end\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 583,
    "raw_source": "def replace(input, string, replacement = '')\n      string = Utils.to_s(string)\n      replacement = Utils.to_s(replacement)\n      input = Utils.to_s(input)\n      input.gsub(string, replacement)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 597,
    "raw_source": "def replace_first(input, string, replacement = '')\n      string = Utils.to_s(string)\n      replacement = Utils.to_s(replacement)\n      input = Utils.to_s(input)\n      input.sub(string, replacement)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 611,
    "raw_source": "def replace_last(input, string, replacement)\n      input = Utils.to_s(input)\n      string = Utils.to_s(string)\n      replacement = Utils.to_s(replacement)\n\n      start_index = input.rindex(string)\n\n      return input unless start_index\n\n      output = input.dup\n      output[start_index, string.length] = replacement\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 632,
    "raw_source": "def remove(input, string)\n      replace(input, string, '')\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 643,
    "raw_source": "def remove_first(input, string)\n      replace_first(input, string, '')\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 654,
    "raw_source": "def remove_last(input, string)\n      replace_last(input, string, '')\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 665,
    "raw_source": "def append(input, string)\n      input = Utils.to_s(input)\n      string = Utils.to_s(string)\n      input + string\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 682,
    "raw_source": "def concat(input, array)\n      unless array.respond_to?(:to_ary)\n        raise ArgumentError, \"concat filter requires an array argument\"\n      end\n      InputIterator.new(input, context).concat(array)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 696,
    "raw_source": "def prepend(input, string)\n      input = Utils.to_s(input)\n      string = Utils.to_s(string)\n      string + input\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 709,
    "raw_source": "def newline_to_br(input)\n      input = Utils.to_s(input)\n      input.gsub(/\\r?\\n/, \"<br />\\n\")\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 754,
    "raw_source": "def date(input, format)\n      str_format = Utils.to_s(format)\n      return input if str_format.empty?\n\n      return input unless (date = Utils.to_date(input))\n\n      date.strftime(str_format)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 770,
    "raw_source": "def first(array)\n      array.first if array.respond_to?(:first)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 781,
    "raw_source": "def last(array)\n      array.last if array.respond_to?(:last)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 792,
    "raw_source": "def abs(input)\n      result = Utils.to_number(input).abs\n      result.is_a?(BigDecimal) ? result.to_f : result\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 804,
    "raw_source": "def plus(input, operand)\n      apply_operation(input, operand, :+)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 815,
    "raw_source": "def minus(input, operand)\n      apply_operation(input, operand, :-)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 826,
    "raw_source": "def times(input, operand)\n      apply_operation(input, operand, :*)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 837,
    "raw_source": "def divided_by(input, operand)\n      apply_operation(input, operand, :/)\n    rescue ::ZeroDivisionError => e\n      raise Liquid::ZeroDivisionError, e.message\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 850,
    "raw_source": "def modulo(input, operand)\n      apply_operation(input, operand, :%)\n    rescue ::ZeroDivisionError => e\n      raise Liquid::ZeroDivisionError, e.message\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 863,
    "raw_source": "def round(input, n = 0)\n      result = Utils.to_number(input).round(Utils.to_number(n))\n      result = result.to_f if result.is_a?(BigDecimal)\n      result = result.to_i if n == 0\n      result\n    rescue ::FloatDomainError => e\n      raise Liquid::FloatDomainError, e.message\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 879,
    "raw_source": "def ceil(input)\n      Utils.to_number(input).ceil.to_i\n    rescue ::FloatDomainError => e\n      raise Liquid::FloatDomainError, e.message\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 892,
    "raw_source": "def floor(input)\n      Utils.to_number(input).floor.to_i\n    rescue ::FloatDomainError => e\n      raise Liquid::FloatDomainError, e.message\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 905,
    "raw_source": "def at_least(input, n)\n      min_value = Utils.to_number(n)\n\n      result = Utils.to_number(input)\n      result = min_value if min_value > result\n      result.is_a?(BigDecimal) ? result.to_f : result\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 920,
    "raw_source": "def at_most(input, n)\n      max_value = Utils.to_number(n)\n\n      result = Utils.to_number(input)\n      result = max_value if max_value < result\n      result.is_a?(BigDecimal) ? result.to_f : result\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 940,
    "raw_source": "def default(input, default_value = '', options = {})\n      options = {} unless options.is_a?(Hash)\n      false_check = options['allow_false'] ? input.nil? : !Liquid::Utils.to_liquid_value(input)\n      false_check || (input.respond_to?(:empty?) && input.empty?) ? default_value : input\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 953,
    "raw_source": "def sum(input, property = nil)\n      ary = InputIterator.new(input, context)\n      return 0 if ary.empty?\n\n      values_for_sum = ary.map do |item|\n        if property.nil?\n          item\n        elsif item.respond_to?(:[])\n          item[property]\n        else\n          0\n        end\n      rescue TypeError\n        raise_property_error(property)\n      end\n\n      result = InputIterator.new(values_for_sum, context).sum do |item|\n        Utils.to_number(item)\n      end\n\n      result.is_a?(BigDecimal) ? result.to_f : result\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 980,
    "raw_source": "def filter_array(input, property, target_value, default_value = [], &block)\n      ary = InputIterator.new(input, context)\n\n      return default_value if ary.empty?\n\n      block.call(ary) do |item|\n        if target_value.nil?\n          item[property]\n        else\n          item[property] == target_value\n        end\n      rescue TypeError\n        raise_property_error(property)\n      rescue NoMethodError\n        return nil unless item.respond_to?(:[])\n        raise\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 999,
    "raw_source": "def raise_property_error(property)\n      raise Liquid::ArgumentError, \"cannot select the property '#{Utils.to_s(property)}'\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 1003,
    "raw_source": "def apply_operation(input, operand, operation)\n      result = Utils.to_number(input).send(operation, Utils.to_number(operand))\n      result.is_a?(BigDecimal) ? result.to_f : result\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 1008,
    "raw_source": "def nil_safe_compare(a, b)\n      result = a <=> b\n\n      if result\n        result\n      elsif a.nil?\n        1\n      elsif b.nil?\n        -1\n      else\n        raise Liquid::ArgumentError, \"cannot sort values of incompatible types\"\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 1022,
    "raw_source": "def nil_safe_casecmp(a, b)\n      if !a.nil? && !b.nil?\n        a.to_s.casecmp(b.to_s)\n      elsif a.nil? && b.nil?\n        0\n      else\n        a.nil? ? 1 : -1\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 1035,
    "raw_source": "def initialize(input, context)\n        @context = context\n        @input   = if input.is_a?(Array)\n          input.flatten\n        elsif input.is_a?(Hash)\n          [input]\n        elsif input.is_a?(Enumerable)\n          input\n        else\n          Array(input)\n        end\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 1048,
    "raw_source": "def join(glue)\n        first = true\n        output = +\"\"\n        each do |item|\n          if first\n            first = false\n          else\n            output << glue\n          end\n\n          output << Liquid::Utils.to_s(item)\n        end\n        output\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 1063,
    "raw_source": "def concat(args)\n        to_a.concat(args)\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 1067,
    "raw_source": "def reverse\n        reverse_each.to_a\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 1071,
    "raw_source": "def uniq(&block)\n        to_a.uniq do |item|\n          item = Utils.to_liquid_value(item)\n          block ? yield(item) : item\n        end\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 1078,
    "raw_source": "def compact\n        to_a.compact\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 1082,
    "raw_source": "def empty?\n        @input.each { return false }\n        true\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/standardfilters.rb",
    "start_line": 1087,
    "raw_source": "def each\n        @input.each do |e|\n          e = e.respond_to?(:to_liquid) ? e.to_liquid : e\n          e.context = @context if e.respond_to?(:context=)\n          yield(e)\n        end\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/strainer_template.rb",
    "start_line": 12,
    "raw_source": "def initialize(context)\n      @context = context\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/strainer_template.rb",
    "start_line": 17,
    "raw_source": "def add_filter(filter)\n        return if include?(filter)\n\n        invokable_non_public_methods = (filter.private_instance_methods + filter.protected_instance_methods).select { |m| invokable?(m) }\n        if invokable_non_public_methods.any?\n          raise MethodOverrideError, \"Filter overrides registered public methods as non public: #{invokable_non_public_methods.join(', ')}\"\n        end\n\n        include(filter)\n\n        filter_methods.merge(filter.public_instance_methods.map(&:to_s))\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/strainer_template.rb",
    "start_line": 30,
    "raw_source": "def invokable?(method)\n        filter_methods.include?(method.to_s)\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/strainer_template.rb",
    "start_line": 34,
    "raw_source": "def inherited(subclass)\n        super\n        subclass.instance_variable_set(:@filter_methods, @filter_methods.dup)\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/strainer_template.rb",
    "start_line": 39,
    "raw_source": "def filter_method_names\n        filter_methods.map(&:to_s).to_a\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/strainer_template.rb",
    "start_line": 45,
    "raw_source": "def filter_methods\n        @filter_methods ||= Set.new\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/strainer_template.rb",
    "start_line": 50,
    "raw_source": "def invoke(method, *args)\n      if self.class.invokable?(method)\n        send(method, *args)\n      elsif @context.strict_filters\n        raise Liquid::UndefinedFilter, \"undefined filter #{method}\"\n      else\n        args.first\n      end\n    rescue ::ArgumentError => e\n      raise Liquid::ArgumentError, e.message, e.backtrace\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tablerowloop_drop.rb",
    "start_line": 10,
    "raw_source": "def initialize(length, cols)\n      @length = length\n      @row    = 1\n      @col    = 1\n      @cols   = cols\n      @index  = 0\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tablerowloop_drop.rb",
    "start_line": 40,
    "raw_source": "def index\n      @index + 1\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tablerowloop_drop.rb",
    "start_line": 48,
    "raw_source": "def index0\n      @index\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tablerowloop_drop.rb",
    "start_line": 56,
    "raw_source": "def col0\n      @col - 1\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tablerowloop_drop.rb",
    "start_line": 64,
    "raw_source": "def rindex\n      @length - @index\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tablerowloop_drop.rb",
    "start_line": 72,
    "raw_source": "def rindex0\n      @length - @index - 1\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tablerowloop_drop.rb",
    "start_line": 80,
    "raw_source": "def first\n      @index == 0\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tablerowloop_drop.rb",
    "start_line": 88,
    "raw_source": "def last\n      @index == @length - 1\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tablerowloop_drop.rb",
    "start_line": 96,
    "raw_source": "def col_first\n      @col == 1\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tablerowloop_drop.rb",
    "start_line": 104,
    "raw_source": "def col_last\n      @col == @cols\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tablerowloop_drop.rb",
    "start_line": 110,
    "raw_source": "def increment!\n      @index += 1\n\n      if @col == @cols\n        @col = 1\n        @row += 1\n      else\n        @col += 1\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tag.rb",
    "start_line": 13,
    "raw_source": "def parse(tag_name, markup, tokenizer, parse_context)\n        tag = new(tag_name, markup, parse_context)\n        tag.parse(tokenizer)\n        tag\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tag.rb",
    "start_line": 19,
    "raw_source": "def disable_tags(*tag_names)\n        tag_names += disabled_tags\n        define_singleton_method(:disabled_tags) { tag_names }\n        prepend(Disabler)\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tag.rb",
    "start_line": 29,
    "raw_source": "def disabled_tags\n        []\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tag.rb",
    "start_line": 34,
    "raw_source": "def initialize(tag_name, markup, parse_context)\n      @tag_name      = tag_name\n      @markup        = markup\n      @parse_context = parse_context\n      @line_number   = parse_context.line_number\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tag.rb",
    "start_line": 41,
    "raw_source": "def parse(_tokens)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tag.rb",
    "start_line": 44,
    "raw_source": "def raw\n      \"#{@tag_name} #{@markup}\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tag.rb",
    "start_line": 48,
    "raw_source": "def name\n      self.class.name.downcase\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tag.rb",
    "start_line": 52,
    "raw_source": "def render(_context)\n      ''\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tag.rb",
    "start_line": 59,
    "raw_source": "def render_to_output_buffer(context, output)\n      render_result = render(context)\n      output << render_result if render_result\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tag.rb",
    "start_line": 65,
    "raw_source": "def blank?\n      false\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tag.rb",
    "start_line": 71,
    "raw_source": "def parse_expression(markup)\n      parse_context.parse_expression(markup)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tag/disableable.rb",
    "start_line": 6,
    "raw_source": "def render_to_output_buffer(context, output)\n        if context.tag_disabled?(tag_name)\n          output << disabled_error(context)\n          return\n        end\n        super\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tag/disableable.rb",
    "start_line": 14,
    "raw_source": "def disabled_error(context)\n        # raise then rescue the exception so that the Context#exception_renderer can re-raise it\n        raise DisabledError, \"#{tag_name} #{parse_context[:locale].t('errors.disabled.tag')}\"\n      rescue DisabledError => exc\n        context.handle_error(exc, line_number)\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tag/disabler.rb",
    "start_line": 6,
    "raw_source": "def render_to_output_buffer(context, output)\n        context.with_disabled_tags(self.class.disabled_tags) do\n          super\n        end\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/assign.rb",
    "start_line": 24,
    "raw_source": "def self.raise_syntax_error(parse_context)\n      raise Liquid::SyntaxError, parse_context.locale.t('errors.syntax.assign')\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/assign.rb",
    "start_line": 30,
    "raw_source": "def initialize(tag_name, markup, parse_context)\n      super\n      if markup =~ Syntax\n        @to   = Regexp.last_match(1)\n        @from = Variable.new(Regexp.last_match(2), parse_context)\n      else\n        self.class.raise_syntax_error(parse_context)\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/assign.rb",
    "start_line": 40,
    "raw_source": "def render_to_output_buffer(context, output)\n      val = @from.render(context)\n      context.scopes.last[@to] = val\n      context.resource_limits.increment_assign_score(assign_score_of(val))\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/assign.rb",
    "start_line": 47,
    "raw_source": "def blank?\n      true\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/assign.rb",
    "start_line": 53,
    "raw_source": "def assign_score_of(val)\n      if val.instance_of?(String)\n        val.bytesize\n      elsif val.instance_of?(Array)\n        sum = 1\n        # Uses #each to avoid extra allocations.\n        val.each { |child| sum += assign_score_of(child) }\n        sum\n      elsif val.instance_of?(Hash)\n        sum = 1\n        val.each do |key, entry_value|\n          sum += assign_score_of(key)\n          sum += assign_score_of(entry_value)\n        end\n        sum\n      else\n        1\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/assign.rb",
    "start_line": 74,
    "raw_source": "def children\n        [@node.from]\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/break.rb",
    "start_line": 24,
    "raw_source": "def render_to_output_buffer(context, output)\n      context.push_interrupt(INTERRUPT)\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/capture.rb",
    "start_line": 25,
    "raw_source": "def initialize(tag_name, markup, options)\n      super\n      if markup =~ Syntax\n        @to = Regexp.last_match(1)\n      else\n        raise SyntaxError, options[:locale].t(\"errors.syntax.capture\")\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/capture.rb",
    "start_line": 34,
    "raw_source": "def render_to_output_buffer(context, output)\n      context.resource_limits.with_capture do\n        capture_output = render(context)\n        context.scopes.last[@to] = capture_output\n      end\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/capture.rb",
    "start_line": 42,
    "raw_source": "def blank?\n      true\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/case.rb",
    "start_line": 31,
    "raw_source": "def initialize(tag_name, markup, options)\n      super\n      @blocks = []\n\n      if markup =~ Syntax\n        @left = parse_expression(Regexp.last_match(1))\n      else\n        raise SyntaxError, options[:locale].t(\"errors.syntax.case\")\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/case.rb",
    "start_line": 42,
    "raw_source": "def parse(tokens)\n      body = case_body = new_body\n      body = @blocks.last.attachment while parse_body(body, tokens)\n      @blocks.reverse_each do |condition|\n        body = condition.attachment\n        unless body.frozen?\n          body.remove_blank_strings if blank?\n          body.freeze\n        end\n      end\n      case_body.freeze\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/case.rb",
    "start_line": 55,
    "raw_source": "def nodelist\n      @blocks.map(&:attachment)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/case.rb",
    "start_line": 59,
    "raw_source": "def unknown_tag(tag, markup, tokens)\n      case tag\n      when 'when'\n        record_when_condition(markup)\n      when 'else'\n        record_else_condition(markup)\n      else\n        super\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/case.rb",
    "start_line": 70,
    "raw_source": "def render_to_output_buffer(context, output)\n      execute_else_block = true\n\n      @blocks.each do |block|\n        if block.else?\n          block.attachment.render_to_output_buffer(context, output) if execute_else_block\n          next\n        end\n\n        result = Liquid::Utils.to_liquid_value(\n          block.evaluate(context),\n        )\n\n        if result\n          execute_else_block = false\n          block.attachment.render_to_output_buffer(context, output)\n        end\n      end\n\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/case.rb",
    "start_line": 94,
    "raw_source": "def record_when_condition(markup)\n      body = new_body\n\n      while markup\n        unless markup =~ WhenSyntax\n          raise SyntaxError, options[:locale].t(\"errors.syntax.case_invalid_when\")\n        end\n\n        markup = Regexp.last_match(2)\n\n        block = Condition.new(@left, '==', Condition.parse_expression(parse_context, Regexp.last_match(1)))\n        block.attach(body)\n        @blocks << block\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/case.rb",
    "start_line": 110,
    "raw_source": "def record_else_condition(markup)\n      unless markup.strip.empty?\n        raise SyntaxError, options[:locale].t(\"errors.syntax.case_invalid_else\")\n      end\n\n      block = ElseCondition.new\n      block.attach(new_body)\n      @blocks << block\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/case.rb",
    "start_line": 121,
    "raw_source": "def children\n        [@node.left] + @node.blocks\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/comment.rb",
    "start_line": 18,
    "raw_source": "def render_to_output_buffer(_context, output)\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/comment.rb",
    "start_line": 22,
    "raw_source": "def unknown_tag(_tag, _markup, _tokens)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/comment.rb",
    "start_line": 25,
    "raw_source": "def blank?\n      true\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/comment.rb",
    "start_line": 31,
    "raw_source": "def parse_body(body, tokenizer)\n      if parse_context.depth >= MAX_DEPTH\n        raise StackLevelError, \"Nesting too deep\"\n      end\n\n      parse_context.depth += 1\n      comment_tag_depth = 1\n\n      begin\n        # Consume tokens without creating child nodes.\n        # The children tag doesn't require to be a valid Liquid except the comment and raw tag.\n        # The child comment and raw tag must be closed.\n        while (token = tokenizer.send(:shift))\n          tag_name = if tokenizer.for_liquid_tag\n            next if token.empty? || token.match?(BlockBody::WhitespaceOrNothing)\n\n            tag_name_match = BlockBody::LiquidTagToken.match(token)\n\n            next if tag_name_match.nil?\n\n            tag_name_match[1]\n          else\n            token =~ BlockBody::FullToken\n            Regexp.last_match(2)\n          end\n\n          case tag_name\n          when \"raw\"\n            parse_raw_tag_body(tokenizer)\n          when \"comment\"\n            comment_tag_depth += 1\n          when \"endcomment\"\n            comment_tag_depth -= 1\n          end\n\n          if comment_tag_depth.zero?\n            parse_context.trim_whitespace = (token[-3] == WhitespaceControl) unless tokenizer.for_liquid_tag\n            return false\n          end\n        end\n\n        raise_tag_never_closed(block_name)\n      ensure\n        parse_context.depth -= 1\n      end\n\n      false\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/comment.rb",
    "start_line": 80,
    "raw_source": "def parse_raw_tag_body(tokenizer)\n      while (token = tokenizer.send(:shift))\n        return if token =~ BlockBody::FullTokenPossiblyInvalid && \"endraw\" == Regexp.last_match(2)\n      end\n\n      raise_tag_never_closed(\"raw\")\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/continue.rb",
    "start_line": 15,
    "raw_source": "def render_to_output_buffer(context, output)\n      context.push_interrupt(INTERRUPT)\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/cycle.rb",
    "start_line": 23,
    "raw_source": "def initialize(tag_name, markup, options)\n      super\n      case markup\n      when NamedSyntax\n        @variables = variables_from_string(Regexp.last_match(2))\n        @name      = parse_expression(Regexp.last_match(1))\n        @is_named = true\n      when SimpleSyntax\n        @variables = variables_from_string(markup)\n        @name      = @variables.to_s\n        @is_named = !@name.match?(/\\w+:0x\\h{8}/)\n      else\n        raise SyntaxError, options[:locale].t(\"errors.syntax.cycle\")\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/cycle.rb",
    "start_line": 39,
    "raw_source": "def named?\n      @is_named\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/cycle.rb",
    "start_line": 43,
    "raw_source": "def render_to_output_buffer(context, output)\n      context.registers[:cycle] ||= {}\n\n      key       = context.evaluate(@name)\n      iteration = context.registers[:cycle][key].to_i\n\n      val = context.evaluate(@variables[iteration])\n\n      if val.is_a?(Array)\n        val = val.join\n      elsif !val.is_a?(String)\n        val = val.to_s\n      end\n\n      output << val\n\n      iteration += 1\n      iteration = 0 if iteration >= @variables.size\n\n      context.registers[:cycle][key] = iteration\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/cycle.rb",
    "start_line": 68,
    "raw_source": "def variables_from_string(markup)\n      markup.split(',').collect do |var|\n        var =~ /\\s*(#{QuotedFragment})\\s*/o\n        next unless Regexp.last_match(1)\n\n        # Expression Parser returns cached objects, and we need to dup them to\n        # start the cycle over for each new cycle call.\n        # Liquid-C does not have a cache, so we don't need to dup the object.\n        var = parse_expression(Regexp.last_match(1))\n        var.is_a?(VariableLookup) ? var.dup : var\n      end.compact\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/cycle.rb",
    "start_line": 82,
    "raw_source": "def children\n        Array(@node.variables)\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/decrement.rb",
    "start_line": 28,
    "raw_source": "def initialize(tag_name, markup, options)\n      super\n      @variable_name = markup.strip\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/decrement.rb",
    "start_line": 33,
    "raw_source": "def render_to_output_buffer(context, output)\n      counter_environment = context.environments.first\n      value = counter_environment[@variable_name] || 0\n      value -= 1\n      counter_environment[@variable_name] = value\n      output << value.to_s\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/doc.rb",
    "start_line": 33,
    "raw_source": "def initialize(tag_name, markup, parse_context)\n      super\n      ensure_valid_markup(tag_name, markup, parse_context)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/doc.rb",
    "start_line": 38,
    "raw_source": "def parse(tokens)\n      @body = +\"\"\n\n      while (token = tokens.shift)\n        tag_name = token =~ BlockBody::FullTokenPossiblyInvalid && Regexp.last_match(2)\n\n        raise_nested_doc_error if tag_name == @tag_name\n\n        if tag_name == block_delimiter\n          parse_context.trim_whitespace = (token[-3] == WhitespaceControl)\n          @body << Regexp.last_match(1) if Regexp.last_match(1) != \"\"\n          return\n        end\n        @body << token unless token.empty?\n      end\n\n      raise_tag_never_closed(block_name)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/doc.rb",
    "start_line": 57,
    "raw_source": "def render_to_output_buffer(_context, output)\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/doc.rb",
    "start_line": 61,
    "raw_source": "def blank?\n      @body.empty?\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/doc.rb",
    "start_line": 65,
    "raw_source": "def nodelist\n      [@body]\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/doc.rb",
    "start_line": 71,
    "raw_source": "def ensure_valid_markup(tag_name, markup, parse_context)\n      unless NO_UNEXPECTED_ARGS.match?(markup)\n        raise SyntaxError, parse_context.locale.t(\"errors.syntax.block_tag_unexpected_args\", tag: tag_name)\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/doc.rb",
    "start_line": 77,
    "raw_source": "def raise_nested_doc_error\n      raise SyntaxError, parse_context.locale.t(\"errors.syntax.doc_invalid_nested\")\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/echo.rb",
    "start_line": 24,
    "raw_source": "def initialize(tag_name, markup, parse_context)\n      super\n      @variable = Variable.new(markup, parse_context)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/echo.rb",
    "start_line": 29,
    "raw_source": "def render(context)\n      @variable.render_to_output_buffer(context, +'')\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/echo.rb",
    "start_line": 34,
    "raw_source": "def children\n        [@node.variable]\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/for.rb",
    "start_line": 32,
    "raw_source": "def initialize(tag_name, markup, options)\n      super\n      @from = @limit = nil\n      parse_with_selected_parser(markup)\n      @for_block = new_body\n      @else_block = nil\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/for.rb",
    "start_line": 40,
    "raw_source": "def parse(tokens)\n      if parse_body(@for_block, tokens)\n        parse_body(@else_block, tokens)\n      end\n      if blank?\n        @else_block&.remove_blank_strings\n        @for_block.remove_blank_strings\n      end\n      @else_block&.freeze\n      @for_block.freeze\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/for.rb",
    "start_line": 52,
    "raw_source": "def nodelist\n      @else_block ? [@for_block, @else_block] : [@for_block]\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/for.rb",
    "start_line": 56,
    "raw_source": "def unknown_tag(tag, markup, tokens)\n      return super unless tag == 'else'\n      @else_block = new_body\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/for.rb",
    "start_line": 61,
    "raw_source": "def render_to_output_buffer(context, output)\n      segment = collection_segment(context)\n\n      if segment.empty?\n        render_else(context, output)\n      else\n        render_segment(context, output, segment)\n      end\n\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/for.rb",
    "start_line": 75,
    "raw_source": "def lax_parse(markup)\n      if markup =~ Syntax\n        @variable_name   = Regexp.last_match(1)\n        collection_name  = Regexp.last_match(2)\n        @reversed        = !!Regexp.last_match(3)\n        @name            = \"#{@variable_name}-#{collection_name}\"\n        @collection_name = parse_expression(collection_name)\n        markup.scan(TagAttributes) do |key, value|\n          set_attribute(key, value)\n        end\n      else\n        raise SyntaxError, options[:locale].t(\"errors.syntax.for\")\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/for.rb",
    "start_line": 90,
    "raw_source": "def strict_parse(markup)\n      p = @parse_context.new_parser(markup)\n      @variable_name = p.consume(:id)\n      raise SyntaxError, options[:locale].t(\"errors.syntax.for_invalid_in\") unless p.id?('in')\n\n      collection_name  = p.expression\n      @collection_name = parse_expression(collection_name)\n\n      @name     = \"#{@variable_name}-#{collection_name}\"\n      @reversed = p.id?('reversed')\n\n      while p.look(:comma) || p.look(:id)\n        p.consume?(:comma)\n        unless (attribute = p.id?('limit') || p.id?('offset'))\n          raise SyntaxError, options[:locale].t(\"errors.syntax.for_invalid_attribute\")\n        end\n        p.consume(:colon)\n        set_attribute(attribute, p.expression)\n      end\n      p.consume(:end_of_string)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/for.rb",
    "start_line": 114,
    "raw_source": "def collection_segment(context)\n      offsets = context.registers[:for] ||= {}\n\n      from = if @from == :continue\n        offsets[@name].to_i\n      else\n        from_value = context.evaluate(@from)\n        if from_value.nil?\n          0\n        else\n          Utils.to_integer(from_value)\n        end\n      end\n\n      collection = context.evaluate(@collection_name)\n      collection = collection.to_a if collection.is_a?(Range)\n\n      limit_value = context.evaluate(@limit)\n      to = if limit_value.nil?\n        nil\n      else\n        Utils.to_integer(limit_value) + from\n      end\n\n      segment = Utils.slice_collection(collection, from, to)\n      segment.reverse! if @reversed\n\n      offsets[@name] = from + segment.length\n\n      segment\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/for.rb",
    "start_line": 146,
    "raw_source": "def render_segment(context, output, segment)\n      for_stack = context.registers[:for_stack] ||= []\n      length    = segment.length\n\n      context.stack do\n        loop_vars = Liquid::ForloopDrop.new(@name, length, for_stack[-1])\n\n        for_stack.push(loop_vars)\n\n        begin\n          context['forloop'] = loop_vars\n\n          segment.each do |item|\n            context[@variable_name] = item\n            @for_block.render_to_output_buffer(context, output)\n            loop_vars.send(:increment!)\n\n            # Handle any interrupts if they exist.\n            next unless context.interrupt?\n            interrupt = context.pop_interrupt\n            break if interrupt.is_a?(BreakInterrupt)\n            next if interrupt.is_a?(ContinueInterrupt)\n          end\n        ensure\n          for_stack.pop\n        end\n      end\n\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/for.rb",
    "start_line": 177,
    "raw_source": "def set_attribute(key, expr)\n      case key\n      when 'offset'\n        @from = if expr == 'continue'\n          :continue\n        else\n          parse_expression(expr)\n        end\n      when 'limit'\n        @limit = parse_expression(expr)\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/for.rb",
    "start_line": 190,
    "raw_source": "def render_else(context, output)\n      if @else_block\n        @else_block.render_to_output_buffer(context, output)\n      else\n        output\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/for.rb",
    "start_line": 199,
    "raw_source": "def children\n        (super + [@node.limit, @node.from, @node.collection_name]).compact\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/if.rb",
    "start_line": 23,
    "raw_source": "def initialize(tag_name, markup, options)\n      super\n      @blocks = []\n      push_block('if', markup)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/if.rb",
    "start_line": 29,
    "raw_source": "def nodelist\n      @blocks.map(&:attachment)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/if.rb",
    "start_line": 33,
    "raw_source": "def parse(tokens)\n      while parse_body(@blocks.last.attachment, tokens)\n      end\n      @blocks.reverse_each do |block|\n        block.attachment.remove_blank_strings if blank?\n        block.attachment.freeze\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/if.rb",
    "start_line": 45,
    "raw_source": "def unknown_tag(tag, markup, tokens)\n      if ELSE_TAG_NAMES.include?(tag)\n        push_block(tag, markup)\n      else\n        super\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/if.rb",
    "start_line": 53,
    "raw_source": "def render_to_output_buffer(context, output)\n      @blocks.each do |block|\n        result = Liquid::Utils.to_liquid_value(\n          block.evaluate(context),\n        )\n\n        if result\n          return block.attachment.render_to_output_buffer(context, output)\n        end\n      end\n\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/if.rb",
    "start_line": 69,
    "raw_source": "def push_block(tag, markup)\n      block = if tag == 'else'\n        ElseCondition.new\n      else\n        parse_with_selected_parser(markup)\n      end\n\n      @blocks.push(block)\n      block.attach(new_body)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/if.rb",
    "start_line": 80,
    "raw_source": "def parse_expression(markup)\n      Condition.parse_expression(parse_context, markup)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/if.rb",
    "start_line": 84,
    "raw_source": "def lax_parse(markup)\n      expressions = markup.scan(ExpressionsAndOperators)\n      raise SyntaxError, options[:locale].t(\"errors.syntax.if\") unless expressions.pop =~ Syntax\n\n      condition = Condition.new(parse_expression(Regexp.last_match(1)), Regexp.last_match(2), parse_expression(Regexp.last_match(3)))\n\n      until expressions.empty?\n        operator = expressions.pop.to_s.strip\n\n        raise SyntaxError, options[:locale].t(\"errors.syntax.if\") unless expressions.pop.to_s =~ Syntax\n\n        new_condition = Condition.new(parse_expression(Regexp.last_match(1)), Regexp.last_match(2), parse_expression(Regexp.last_match(3)))\n        raise SyntaxError, options[:locale].t(\"errors.syntax.if\") unless BOOLEAN_OPERATORS.include?(operator)\n        new_condition.send(operator, condition)\n        condition = new_condition\n      end\n\n      condition\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/if.rb",
    "start_line": 104,
    "raw_source": "def strict_parse(markup)\n      p = @parse_context.new_parser(markup)\n      condition = parse_binary_comparisons(p)\n      p.consume(:end_of_string)\n      condition\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/if.rb",
    "start_line": 111,
    "raw_source": "def parse_binary_comparisons(p)\n      condition = parse_comparison(p)\n      first_condition = condition\n      while (op = p.id?('and') || p.id?('or'))\n        child_condition = parse_comparison(p)\n        condition.send(op, child_condition)\n        condition = child_condition\n      end\n      first_condition\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/if.rb",
    "start_line": 122,
    "raw_source": "def parse_comparison(p)\n      a = parse_expression(p.expression)\n      if (op = p.consume?(:comparison))\n        b = parse_expression(p.expression)\n        Condition.new(a, op, b)\n      else\n        Condition.new(a)\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/if.rb",
    "start_line": 133,
    "raw_source": "def children\n        @node.blocks\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/ifchanged.rb",
    "start_line": 5,
    "raw_source": "def render_to_output_buffer(context, output)\n      block_output = +''\n      super(context, block_output)\n\n      if block_output != context.registers[:ifchanged]\n        context.registers[:ifchanged] = block_output\n        output << block_output\n      end\n\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/include.rb",
    "start_line": 28,
    "raw_source": "def initialize(tag_name, markup, options)\n      super\n\n      if markup =~ SYNTAX\n\n        template_name = Regexp.last_match(1)\n        variable_name = Regexp.last_match(3)\n\n        @alias_name         = Regexp.last_match(5)\n        @variable_name_expr = variable_name ? parse_expression(variable_name) : nil\n        @template_name_expr = parse_expression(template_name)\n        @attributes         = {}\n\n        markup.scan(TagAttributes) do |key, value|\n          @attributes[key] = parse_expression(value)\n        end\n\n      else\n        raise SyntaxError, options[:locale].t(\"errors.syntax.include\")\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/include.rb",
    "start_line": 50,
    "raw_source": "def parse(_tokens)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/include.rb",
    "start_line": 53,
    "raw_source": "def render_to_output_buffer(context, output)\n      template_name = context.evaluate(@template_name_expr)\n      raise ArgumentError, options[:locale].t(\"errors.argument.include\") unless template_name.is_a?(String)\n\n      partial = PartialCache.load(\n        template_name,\n        context: context,\n        parse_context: parse_context,\n      )\n\n      context_variable_name = @alias_name || template_name.split('/').last\n\n      variable = if @variable_name_expr\n        context.evaluate(@variable_name_expr)\n      else\n        context.find_variable(template_name, raise_on_not_found: false)\n      end\n\n      old_template_name = context.template_name\n      old_partial       = context.partial\n\n      begin\n        context.template_name = partial.name\n        context.partial = true\n\n        context.stack do\n          @attributes.each do |key, value|\n            context[key] = context.evaluate(value)\n          end\n\n          if variable.is_a?(Array)\n            variable.each do |var|\n              context[context_variable_name] = var\n              partial.render_to_output_buffer(context, output)\n            end\n          else\n            context[context_variable_name] = variable\n            partial.render_to_output_buffer(context, output)\n          end\n        end\n      ensure\n        context.template_name = old_template_name\n        context.partial       = old_partial\n      end\n\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/include.rb",
    "start_line": 105,
    "raw_source": "def children\n        [\n          @node.template_name_expr,\n          @node.variable_name_expr,\n        ] + @node.attributes.values\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/increment.rb",
    "start_line": 28,
    "raw_source": "def initialize(tag_name, markup, options)\n      super\n      @variable_name = markup.strip\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/increment.rb",
    "start_line": 33,
    "raw_source": "def render_to_output_buffer(context, output)\n      counter_environment = context.environments.first\n      value = counter_environment[@variable_name] || 0\n      counter_environment[@variable_name] = value + 1\n\n      output << value.to_s\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/inline_comment.rb",
    "start_line": 5,
    "raw_source": "def initialize(tag_name, markup, options)\n      super\n\n      # Semantically, a comment should only ignore everything after it on the line.\n      # Currently, this implementation doesn't support mixing a comment with another tag\n      # but we need to reserve future support for this and prevent the introduction\n      # of inline comments from being backward incompatible change.\n      #\n      # As such, we're forcing users to put a # symbol on every line otherwise this\n      # tag will throw an error.\n      if markup.match?(/\\n\\s*[^#\\s]/)\n        raise SyntaxError, options[:locale].t(\"errors.syntax.inline_comment_invalid\")\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/inline_comment.rb",
    "start_line": 20,
    "raw_source": "def render_to_output_buffer(_context, output)\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/inline_comment.rb",
    "start_line": 24,
    "raw_source": "def blank?\n      true\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/raw.rb",
    "start_line": 18,
    "raw_source": "def initialize(tag_name, markup, parse_context)\n      super\n\n      ensure_valid_markup(tag_name, markup, parse_context)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/raw.rb",
    "start_line": 24,
    "raw_source": "def parse(tokens)\n      @body = +''\n      while (token = tokens.shift)\n        if token =~ BlockBody::FullTokenPossiblyInvalid && block_delimiter == Regexp.last_match(2)\n          parse_context.trim_whitespace = (token[-3] == WhitespaceControl)\n          @body << Regexp.last_match(1) if Regexp.last_match(1) != \"\"\n          return\n        end\n        @body << token unless token.empty?\n      end\n\n      raise_tag_never_closed(block_name)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/raw.rb",
    "start_line": 38,
    "raw_source": "def render_to_output_buffer(_context, output)\n      output << @body\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/raw.rb",
    "start_line": 43,
    "raw_source": "def nodelist\n      [@body]\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/raw.rb",
    "start_line": 47,
    "raw_source": "def blank?\n      @body.empty?\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/raw.rb",
    "start_line": 53,
    "raw_source": "def ensure_valid_markup(tag_name, markup, parse_context)\n      unless Syntax.match?(markup)\n        raise SyntaxError, parse_context.locale.t(\"errors.syntax.tag_unexpected_args\", tag: tag_name)\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/render.rb",
    "start_line": 36,
    "raw_source": "def initialize(tag_name, markup, options)\n      super\n\n      raise SyntaxError, options[:locale].t(\"errors.syntax.render\") unless markup =~ SYNTAX\n\n      template_name = Regexp.last_match(1)\n      with_or_for = Regexp.last_match(3)\n      variable_name = Regexp.last_match(4)\n\n      @alias_name = Regexp.last_match(6)\n      @variable_name_expr = variable_name ? parse_expression(variable_name) : nil\n      @template_name_expr = parse_expression(template_name)\n      @is_for_loop = (with_or_for == FOR)\n\n      @attributes = {}\n      markup.scan(TagAttributes) do |key, value|\n        @attributes[key] = parse_expression(value)\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/render.rb",
    "start_line": 56,
    "raw_source": "def for_loop?\n      @is_for_loop\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/render.rb",
    "start_line": 60,
    "raw_source": "def render_to_output_buffer(context, output)\n      render_tag(context, output)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/render.rb",
    "start_line": 64,
    "raw_source": "def render_tag(context, output)\n      # The expression should be a String literal, which parses to a String object\n      template_name = @template_name_expr\n      raise ::ArgumentError unless template_name.is_a?(String)\n\n      partial = PartialCache.load(\n        template_name,\n        context: context,\n        parse_context: parse_context,\n      )\n\n      context_variable_name = @alias_name || template_name.split('/').last\n\n      render_partial_func = ->(var, forloop) {\n        inner_context               = context.new_isolated_subcontext\n        inner_context.template_name = partial.name\n        inner_context.partial       = true\n        inner_context['forloop']    = forloop if forloop\n\n        @attributes.each do |key, value|\n          inner_context[key] = context.evaluate(value)\n        end\n        inner_context[context_variable_name] = var unless var.nil?\n        partial.render_to_output_buffer(inner_context, output)\n        forloop&.send(:increment!)\n      }\n\n      variable = @variable_name_expr ? context.evaluate(@variable_name_expr) : nil\n      if @is_for_loop && variable.respond_to?(:each) && variable.respond_to?(:count)\n        forloop = Liquid::ForloopDrop.new(template_name, variable.count, nil)\n        variable.each { |var| render_partial_func.call(var, forloop) }\n      else\n        render_partial_func.call(variable, nil)\n      end\n\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/render.rb",
    "start_line": 103,
    "raw_source": "def children\n        [\n          @node.template_name_expr,\n          @node.variable_name_expr,\n        ] + @node.attributes.values\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/table_row.rb",
    "start_line": 31,
    "raw_source": "def initialize(tag_name, markup, options)\n      super\n      if markup =~ Syntax\n        @variable_name   = Regexp.last_match(1)\n        @collection_name = parse_expression(Regexp.last_match(2))\n        @attributes      = {}\n        markup.scan(TagAttributes) do |key, value|\n          @attributes[key] = parse_expression(value)\n        end\n      else\n        raise SyntaxError, options[:locale].t(\"errors.syntax.table_row\")\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/table_row.rb",
    "start_line": 45,
    "raw_source": "def render_to_output_buffer(context, output)\n      (collection = context.evaluate(@collection_name)) || (return '')\n\n      from = @attributes.key?('offset') ? to_integer(context.evaluate(@attributes['offset'])) : 0\n      to = @attributes.key?('limit') ? from + to_integer(context.evaluate(@attributes['limit'])) : nil\n\n      collection = Utils.slice_collection(collection, from, to)\n      length     = collection.length\n\n      cols = @attributes.key?('cols') ? to_integer(context.evaluate(@attributes['cols'])) : length\n\n      output << \"<tr class=\\\"row1\\\">\\n\"\n      context.stack do\n        tablerowloop = Liquid::TablerowloopDrop.new(length, cols)\n        context['tablerowloop'] = tablerowloop\n\n        collection.each do |item|\n          context[@variable_name] = item\n\n          output << \"<td class=\\\"col#{tablerowloop.col}\\\">\"\n          super\n          output << '</td>'\n\n          # Handle any interrupts if they exist.\n          if context.interrupt?\n            interrupt = context.pop_interrupt\n            break if interrupt.is_a?(BreakInterrupt)\n          end\n\n          if tablerowloop.col_last && !tablerowloop.last\n            output << \"</tr>\\n<tr class=\\\"row#{tablerowloop.row + 1}\\\">\"\n          end\n\n          tablerowloop.send(:increment!)\n        end\n      end\n\n      output << \"</tr>\\n\"\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/table_row.rb",
    "start_line": 87,
    "raw_source": "def children\n        super + @node.attributes.values + [@node.collection_name]\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/table_row.rb",
    "start_line": 94,
    "raw_source": "def to_integer(value)\n      value.to_i\n    rescue NoMethodError\n      raise Liquid::ArgumentError, \"invalid integer\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tags/unless.rb",
    "start_line": 22,
    "raw_source": "def render_to_output_buffer(context, output)\n      # First condition is interpreted backwards ( if not )\n      first_block = @blocks.first\n      result = Liquid::Utils.to_liquid_value(\n        first_block.evaluate(context),\n      )\n\n      unless result\n        return first_block.attachment.render_to_output_buffer(context, output)\n      end\n\n      # After the first condition unless works just like if\n      @blocks[1..-1].each do |block|\n        result = Liquid::Utils.to_liquid_value(\n          block.evaluate(context),\n        )\n\n        if result\n          return block.attachment.render_to_output_buffer(context, output)\n        end\n      end\n\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 28,
    "raw_source": "def error_mode=(mode)\n        Deprecations.warn(\"Template.error_mode=\", \"Environment#error_mode=\")\n        Environment.default.error_mode = mode\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 33,
    "raw_source": "def error_mode\n        Environment.default.error_mode\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 37,
    "raw_source": "def default_exception_renderer=(renderer)\n        Deprecations.warn(\"Template.default_exception_renderer=\", \"Environment#exception_renderer=\")\n        Environment.default.exception_renderer = renderer\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 42,
    "raw_source": "def default_exception_renderer\n        Environment.default.exception_renderer\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 46,
    "raw_source": "def file_system=(file_system)\n        Deprecations.warn(\"Template.file_system=\", \"Environment#file_system=\")\n        Environment.default.file_system = file_system\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 51,
    "raw_source": "def file_system\n        Environment.default.file_system\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 55,
    "raw_source": "def tags\n        Environment.default.tags\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 59,
    "raw_source": "def register_tag(name, klass)\n        Deprecations.warn(\"Template.register_tag\", \"Environment#register_tag\")\n        Environment.default.register_tag(name, klass)\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 66,
    "raw_source": "def register_filter(mod)\n        Deprecations.warn(\"Template.register_filter\", \"Environment#register_filter\")\n        Environment.default.register_filter(mod)\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 71,
    "raw_source": "private def default_resource_limits=(limits)\n        Deprecations.warn(\"Template.default_resource_limits=\", \"Environment#default_resource_limits=\")\n        Environment.default.default_resource_limits = limits\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 76,
    "raw_source": "def default_resource_limits\n        Environment.default.default_resource_limits\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 83,
    "raw_source": "def parse(source, options = {})\n        environment = options[:environment] || Environment.default\n        new(environment: environment).parse(source, options)\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 89,
    "raw_source": "def initialize(environment: Environment.default)\n      @environment = environment\n      @rethrow_errors  = false\n      @resource_limits = ResourceLimits.new(environment.default_resource_limits)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 97,
    "raw_source": "def parse(source, options = {})\n      parse_context = configure_options(options)\n      source = source.to_s.to_str\n\n      unless source.valid_encoding?\n        raise TemplateEncodingError, parse_context.locale.t(\"errors.syntax.invalid_template_encoding\")\n      end\n\n      tokenizer     = parse_context.new_tokenizer(source, start_line_number: @line_numbers && 1)\n      @root         = Document.parse(tokenizer, parse_context)\n      self\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 110,
    "raw_source": "def registers\n      @registers ||= {}\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 114,
    "raw_source": "def assigns\n      @assigns ||= {}\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 118,
    "raw_source": "def instance_assigns\n      @instance_assigns ||= {}\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 122,
    "raw_source": "def errors\n      @errors ||= []\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 140,
    "raw_source": "def render(*args)\n      return '' if @root.nil?\n\n      context = case args.first\n      when Liquid::Context\n        c = args.shift\n\n        if @rethrow_errors\n          c.exception_renderer = Liquid::RAISE_EXCEPTION_LAMBDA\n        end\n\n        c\n      when Liquid::Drop\n        drop         = args.shift\n        drop.context = Context.new([drop, assigns], instance_assigns, registers, @rethrow_errors, @resource_limits, {}, @environment)\n      when Hash\n        Context.new([args.shift, assigns], instance_assigns, registers, @rethrow_errors, @resource_limits, {}, @environment)\n      when nil\n        Context.new(assigns, instance_assigns, registers, @rethrow_errors, @resource_limits, {}, @environment)\n      else\n        raise ArgumentError, \"Expected Hash or Liquid::Context as parameter\"\n      end\n\n      output = nil\n\n      case args.last\n      when Hash\n        options = args.pop\n        output  = options[:output] if options[:output]\n        static_registers = context.registers.static\n\n        options[:registers]&.each do |key, register|\n          static_registers[key] = register\n        end\n\n        apply_options_to_context(context, options)\n      when Module, Array\n        context.add_filters(args.pop)\n      end\n\n      # Retrying a render resets resource usage\n      context.resource_limits.reset\n\n      if @profiling && context.profiler.nil?\n        @profiler = context.profiler = Liquid::Profiler.new\n      end\n\n      context.template_name ||= name\n\n      begin\n        # render the nodelist.\n        @root.render_to_output_buffer(context, output || +'')\n      rescue Liquid::MemoryError => e\n        context.handle_error(e)\n      ensure\n        @errors = context.errors\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 199,
    "raw_source": "def render!(*args)\n      @rethrow_errors = true\n      render(*args)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 204,
    "raw_source": "def render_to_output_buffer(context, output)\n      render(context, output: output)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 210,
    "raw_source": "def configure_options(options)\n      if (profiling = options[:profile])\n        raise \"Profiler not loaded, require 'liquid/profiler' first\" unless defined?(Liquid::Profiler)\n      end\n\n      @options      = options\n      @profiling    = profiling\n      @line_numbers = options[:line_numbers] || @profiling\n      parse_context = if options.is_a?(ParseContext)\n        options\n      else\n        opts = options.key?(:environment) ? options : options.merge(environment: @environment)\n        ParseContext.new(opts)\n      end\n\n      @warnings = parse_context.warnings\n      parse_context\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template.rb",
    "start_line": 229,
    "raw_source": "def apply_options_to_context(context, options)\n      context.add_filters(options[:filters]) if options[:filters]\n      context.global_filter      = options[:global_filter] if options[:global_filter]\n      context.exception_renderer = options[:exception_renderer] if options[:exception_renderer]\n      context.strict_variables   = options[:strict_variables] if options[:strict_variables]\n      context.strict_filters     = options[:strict_filters] if options[:strict_filters]\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/template_factory.rb",
    "start_line": 5,
    "raw_source": "def for(_template_name)\n      Liquid::Template.new\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tokenizer.rb",
    "start_line": 17,
    "raw_source": "def initialize(\n      source:,\n      string_scanner:,\n      line_numbers: false,\n      line_number: nil,\n      for_liquid_tag: false\n    )\n      @line_number = line_number || (line_numbers ? 1 : nil)\n      @for_liquid_tag = for_liquid_tag\n      @source = source.to_s.to_str\n      @offset = 0\n      @tokens = []\n\n      if @source\n        @ss = string_scanner\n        @ss.string = @source\n        tokenize\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tokenizer.rb",
    "start_line": 37,
    "raw_source": "def shift\n      token = @tokens[@offset]\n\n      return unless token\n\n      @offset += 1\n\n      if @line_number\n        @line_number += @for_liquid_tag ? 1 : token.count(\"\\n\")\n      end\n\n      token\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tokenizer.rb",
    "start_line": 53,
    "raw_source": "def tokenize\n      if @for_liquid_tag\n        @tokens = @source.split(\"\\n\")\n      else\n        @tokens << shift_normal until @ss.eos?\n      end\n\n      @source = nil\n      @ss = nil\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tokenizer.rb",
    "start_line": 64,
    "raw_source": "def shift_normal\n      token = next_token\n\n      return unless token\n\n      token\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tokenizer.rb",
    "start_line": 72,
    "raw_source": "def next_token\n      # possible states: :text, :tag, :variable\n      byte_a = @ss.peek_byte\n\n      if byte_a == OPEN_CURLEY\n        @ss.scan_byte\n\n        byte_b = @ss.peek_byte\n\n        if byte_b == PERCENTAGE\n          @ss.scan_byte\n          return next_tag_token\n        elsif byte_b == OPEN_CURLEY\n          @ss.scan_byte\n          return next_variable_token\n        end\n\n        @ss.pos -= 1\n      end\n\n      next_text_token\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tokenizer.rb",
    "start_line": 95,
    "raw_source": "def next_text_token\n      start = @ss.pos\n\n      unless @ss.skip_until(TAG_OR_VARIABLE_START)\n        token = @ss.rest\n        @ss.terminate\n        return token\n      end\n\n      pos = @ss.pos -= 2\n      @source.byteslice(start, pos - start)\n    rescue ::ArgumentError => e\n      if e.message == \"invalid byte sequence in #{@ss.string.encoding}\"\n        raise SyntaxError, \"Invalid byte sequence in #{@ss.string.encoding}\"\n      else\n        raise\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tokenizer.rb",
    "start_line": 114,
    "raw_source": "def next_variable_token\n      start = @ss.pos - 2\n\n      byte_a = byte_b = @ss.scan_byte\n\n      while byte_b\n        byte_a = @ss.scan_byte while byte_a && (byte_a != CLOSE_CURLEY && byte_a != OPEN_CURLEY)\n\n        break unless byte_a\n\n        if @ss.eos?\n          return byte_a == CLOSE_CURLEY ? @source.byteslice(start, @ss.pos - start) : \"{{\"\n        end\n\n        byte_b = @ss.scan_byte\n\n        if byte_a == CLOSE_CURLEY\n          if byte_b == CLOSE_CURLEY\n            return @source.byteslice(start, @ss.pos - start)\n          elsif byte_b != CLOSE_CURLEY\n            @ss.pos -= 1\n            return @source.byteslice(start, @ss.pos - start)\n          end\n        elsif byte_a == OPEN_CURLEY && byte_b == PERCENTAGE\n          return next_tag_token_with_start(start)\n        end\n\n        byte_a = byte_b\n      end\n\n      \"{{\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tokenizer.rb",
    "start_line": 147,
    "raw_source": "def next_tag_token\n      start = @ss.pos - 2\n      if (len = @ss.skip_until(TAG_END))\n        @source.byteslice(start, len + 2)\n      else\n        \"{%\"\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/tokenizer.rb",
    "start_line": 156,
    "raw_source": "def next_tag_token_with_start(start)\n      @ss.skip_until(TAG_END)\n      @source.byteslice(start, @ss.pos - start)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/usage.rb",
    "start_line": 5,
    "raw_source": "def self.increment(name)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/utils.rb",
    "start_line": 5,
    "raw_source": "def self.slice_collection(collection, from, to)\n      if (from != 0 || !to.nil?) && collection.respond_to?(:load_slice)\n        collection.load_slice(from, to)\n      else\n        slice_collection_using_each(collection, from, to)\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/utils.rb",
    "start_line": 13,
    "raw_source": "def self.slice_collection_using_each(collection, from, to)\n      segments = []\n      index    = 0\n\n      # Maintains Ruby 1.8.7 String#each behaviour on 1.9\n      if collection.is_a?(String)\n        return collection.empty? ? [] : [collection]\n      end\n      return [] unless collection.respond_to?(:each)\n\n      collection.each do |item|\n        if to && to <= index\n          break\n        end\n\n        if from <= index\n          segments << item\n        end\n\n        index += 1\n      end\n\n      segments\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/utils.rb",
    "start_line": 38,
    "raw_source": "def self.to_integer(num)\n      return num if num.is_a?(Integer)\n      num = num.to_s\n      begin\n        Integer(num)\n      rescue ::ArgumentError\n        raise Liquid::ArgumentError, \"invalid integer\"\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/utils.rb",
    "start_line": 48,
    "raw_source": "def self.to_number(obj)\n      case obj\n      when Float\n        BigDecimal(obj.to_s)\n      when Numeric\n        obj\n      when String\n        /\\A-?\\d+\\.\\d+\\z/.match?(obj.strip) ? BigDecimal(obj) : obj.to_i\n      else\n        if obj.respond_to?(:to_number)\n          obj.to_number\n        else\n          0\n        end\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/utils.rb",
    "start_line": 65,
    "raw_source": "def self.to_date(obj)\n      return obj if obj.respond_to?(:strftime)\n\n      if obj.is_a?(String)\n        return nil if obj.empty?\n        obj = obj.downcase\n      end\n\n      case obj\n      when 'now', 'today'\n        Time.now\n      when /\\A\\d+\\z/, Integer\n        Time.at(obj.to_i)\n      when String\n        Time.parse(obj)\n      end\n    rescue ::ArgumentError\n      nil\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/utils.rb",
    "start_line": 85,
    "raw_source": "def self.to_liquid_value(obj)\n      # Enable \"obj\" to represent itself as a primitive value like integer, string, or boolean\n      return obj.to_liquid_value if obj.respond_to?(:to_liquid_value)\n\n      # Otherwise return the object itself\n      obj\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/utils.rb",
    "start_line": 93,
    "raw_source": "def self.to_s(obj, seen = {})\n      case obj\n      when Hash\n        # If the custom hash implementation overrides `#to_s`, use their\n        # custom implementation. Otherwise we use Liquid's default\n        # implementation.\n        if obj.class.instance_method(:to_s) == HASH_TO_S_METHOD\n          hash_inspect(obj, seen)\n        else\n          obj.to_s\n        end\n      when Array\n        array_inspect(obj, seen)\n      else\n        obj.to_s\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/utils.rb",
    "start_line": 111,
    "raw_source": "def self.inspect(obj, seen = {})\n      case obj\n      when Hash\n        # If the custom hash implementation overrides `#inspect`, use their\n        # custom implementation. Otherwise we use Liquid's default\n        # implementation.\n        if obj.class.instance_method(:inspect) == HASH_INSPECT_METHOD\n          hash_inspect(obj, seen)\n        else\n          obj.inspect\n        end\n      when Array\n        array_inspect(obj, seen)\n      else\n        obj.inspect\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/utils.rb",
    "start_line": 129,
    "raw_source": "def self.array_inspect(arr, seen = {})\n      if seen[arr.object_id]\n        return \"[...]\"\n      end\n\n      seen[arr.object_id] = true\n      str = +\"[\"\n      cursor = 0\n      len = arr.length\n\n      while cursor < len\n        if cursor > 0\n          str << \", \"\n        end\n\n        item_str = inspect(arr[cursor], seen)\n        str << item_str\n        cursor += 1\n      end\n\n      str << \"]\"\n      str\n    ensure\n      seen.delete(arr.object_id)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/utils.rb",
    "start_line": 155,
    "raw_source": "def self.hash_inspect(hash, seen = {})\n      if seen[hash.object_id]\n        return \"{...}\"\n      end\n      seen[hash.object_id] = true\n\n      str = +\"{\"\n      first = true\n      hash.each do |key, value|\n        if first\n          first = false\n        else\n          str << \", \"\n        end\n\n        key_str = inspect(key, seen)\n        str << key_str\n        str << \"=>\"\n\n        value_str = inspect(value, seen)\n        str << value_str\n      end\n      str << \"}\"\n      str\n    ensure\n      seen.delete(hash.object_id)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable.rb",
    "start_line": 27,
    "raw_source": "def initialize(markup, parse_context)\n      @markup        = markup\n      @name          = nil\n      @parse_context = parse_context\n      @line_number   = parse_context.line_number\n\n      strict_parse_with_error_mode_fallback(markup)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable.rb",
    "start_line": 36,
    "raw_source": "def raw\n      @markup\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable.rb",
    "start_line": 40,
    "raw_source": "def markup_context(markup)\n      \"in \\\"{{#{markup}}}\\\"\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable.rb",
    "start_line": 44,
    "raw_source": "def lax_parse(markup)\n      @filters = []\n      return unless markup =~ MarkupWithQuotedFragment\n\n      name_markup   = Regexp.last_match(1)\n      filter_markup = Regexp.last_match(2)\n      @name         = parse_context.parse_expression(name_markup)\n      if filter_markup =~ FilterMarkupRegex\n        filters = Regexp.last_match(1).scan(FilterParser)\n        filters.each do |f|\n          next unless f =~ /\\w+/\n          filtername = Regexp.last_match(0)\n          filterargs = f.scan(FilterArgsRegex).flatten\n          @filters << parse_filter_expressions(filtername, filterargs)\n        end\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable.rb",
    "start_line": 62,
    "raw_source": "def strict_parse(markup)\n      @filters = []\n      p = @parse_context.new_parser(markup)\n\n      return if p.look(:end_of_string)\n\n      @name = parse_context.parse_expression(p.expression)\n      while p.consume?(:pipe)\n        filtername = p.consume(:id)\n        filterargs = p.consume?(:colon) ? parse_filterargs(p) : Const::EMPTY_ARRAY\n        @filters << parse_filter_expressions(filtername, filterargs)\n      end\n      p.consume(:end_of_string)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable.rb",
    "start_line": 77,
    "raw_source": "def parse_filterargs(p)\n      # first argument\n      filterargs = [p.argument]\n      # followed by comma separated others\n      filterargs << p.argument while p.consume?(:comma)\n      filterargs\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable.rb",
    "start_line": 85,
    "raw_source": "def render(context)\n      obj = context.evaluate(@name)\n\n      @filters.each do |filter_name, filter_args, filter_kwargs|\n        filter_args = evaluate_filter_expressions(context, filter_args, filter_kwargs)\n        obj = context.invoke(filter_name, obj, *filter_args)\n      end\n\n      context.apply_global_filter(obj)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable.rb",
    "start_line": 96,
    "raw_source": "def render_to_output_buffer(context, output)\n      obj = render(context)\n      render_obj_to_output(obj, output)\n      output\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable.rb",
    "start_line": 102,
    "raw_source": "def render_obj_to_output(obj, output)\n      case obj\n      when NilClass\n        # Do nothing\n      when Array\n        obj.each do |o|\n          render_obj_to_output(o, output)\n        end\n      else\n        output << Liquid::Utils.to_s(obj)\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable.rb",
    "start_line": 115,
    "raw_source": "def disabled?(_context)\n      false\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable.rb",
    "start_line": 119,
    "raw_source": "def disabled_tags\n      []\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable.rb",
    "start_line": 125,
    "raw_source": "def parse_filter_expressions(filter_name, unparsed_args)\n      filter_args  = []\n      keyword_args = nil\n      unparsed_args.each do |a|\n        if (matches = a.match(JustTagAttributes))\n          keyword_args           ||= {}\n          keyword_args[matches[1]] = parse_context.parse_expression(matches[2])\n        else\n          filter_args << parse_context.parse_expression(a)\n        end\n      end\n      result = [filter_name, filter_args]\n      result << keyword_args if keyword_args\n      result\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable.rb",
    "start_line": 141,
    "raw_source": "def evaluate_filter_expressions(context, filter_args, filter_kwargs)\n      parsed_args = filter_args.map { |expr| context.evaluate(expr) }\n      if filter_kwargs\n        parsed_kwargs = {}\n        filter_kwargs.each do |key, expr|\n          parsed_kwargs[key] = context.evaluate(expr)\n        end\n        parsed_args << parsed_kwargs\n      end\n      parsed_args\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable.rb",
    "start_line": 154,
    "raw_source": "def children\n        [@node.name] + @node.filters.flatten\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable_lookup.rb",
    "start_line": 9,
    "raw_source": "def self.parse(markup, string_scanner = StringScanner.new(\"\"), cache = nil)\n      new(markup, string_scanner, cache)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable_lookup.rb",
    "start_line": 13,
    "raw_source": "def initialize(markup, string_scanner = StringScanner.new(\"\"), cache = nil)\n      lookups = markup.scan(VariableParser)\n\n      name = lookups.shift\n      if name&.start_with?('[') && name&.end_with?(']')\n        name = Expression.parse(\n          name[1..-2],\n          string_scanner,\n          cache,\n        )\n      end\n      @name = name\n\n      @lookups       = lookups\n      @command_flags = 0\n\n      @lookups.each_index do |i|\n        lookup = lookups[i]\n        if lookup&.start_with?('[') && lookup&.end_with?(']')\n          lookups[i] = Expression.parse(\n            lookup[1..-2],\n            string_scanner,\n            cache,\n          )\n        elsif COMMAND_METHODS.include?(lookup)\n          @command_flags |= 1 << i\n        end\n      end\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable_lookup.rb",
    "start_line": 43,
    "raw_source": "def lookup_command?(lookup_index)\n      @command_flags & (1 << lookup_index) != 0\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable_lookup.rb",
    "start_line": 47,
    "raw_source": "def evaluate(context)\n      name   = context.evaluate(@name)\n      object = context.find_variable(name)\n\n      @lookups.each_index do |i|\n        key = context.evaluate(@lookups[i])\n\n        # Cast \"key\" to its liquid value to enable it to act as a primitive value\n        key = Liquid::Utils.to_liquid_value(key)\n\n        # If object is a hash- or array-like object we look for the\n        # presence of the key and if its available we return it\n        if object.respond_to?(:[]) &&\n            ((object.respond_to?(:key?) && object.key?(key)) ||\n             (object.respond_to?(:fetch) && key.is_a?(Integer)))\n\n          # if its a proc we will replace the entry with the proc\n          res    = context.lookup_and_evaluate(object, key)\n          object = res.to_liquid\n\n          # Some special cases. If the part wasn't in square brackets and\n          # no key with the same name was found we interpret following calls\n          # as commands and call them on the current object\n        elsif lookup_command?(i) && object.respond_to?(key)\n          object = object.send(key).to_liquid\n\n          # No key was present with the desired value and it wasn't one of the directly supported\n          # keywords either. The only thing we got left is to return nil or\n          # raise an exception if `strict_variables` option is set to true\n        else\n          return nil unless context.strict_variables\n          raise Liquid::UndefinedVariable, \"undefined variable #{key}\"\n        end\n\n        # If we are dealing with a drop here we have to\n        object.context = context if object.respond_to?(:context=)\n      end\n\n      object\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable_lookup.rb",
    "start_line": 88,
    "raw_source": "def ==(other)\n      self.class == other.class && state == other.state\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable_lookup.rb",
    "start_line": 94,
    "raw_source": "def state\n      [@name, @lookups, @command_flags]\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/lib/liquid/variable_lookup.rb",
    "start_line": 99,
    "raw_source": "def children\n        @node.lookups\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/memory_profile.rb",
    "start_line": 12,
    "raw_source": "def self.run\n    puts\n    yield new\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/memory_profile.rb",
    "start_line": 17,
    "raw_source": "def initialize\n    @allocated = []\n    @retained  = []\n    @headings  = []\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/memory_profile.rb",
    "start_line": 23,
    "raw_source": "def profile(phase, &block)\n    print(LOG_LABEL)\n    print(\"#{phase}.. \".ljust(10))\n    report = MemoryProfiler.report(&block)\n    puts 'Done.'\n    @headings  << phase.capitalize\n    @allocated << \"#{report.scale_bytes(report.total_allocated_memsize)} (#{report.total_allocated} objects)\"\n    @retained  << \"#{report.scale_bytes(report.total_retained_memsize)} (#{report.total_retained} objects)\"\n\n    return if ENV['CI']\n\n    require 'fileutils'\n    report_file = File.join(REPORTS_DIR, \"#{sanitize(phase)}.txt\")\n    FileUtils.mkdir_p(REPORTS_DIR)\n    report.pretty_print(to_file: report_file, scale_bytes: true)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/memory_profile.rb",
    "start_line": 40,
    "raw_source": "def tabulate\n    table = Terminal::Table.new(headings: @headings.unshift('Phase')) do |t|\n      t << @allocated.unshift('Total allocated')\n      t << @retained.unshift('Total retained')\n    end\n\n    puts\n    puts table\n    puts \"\\nDetailed report(s) saved to #{REPORTS_DIR}/\" unless ENV['CI']\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/memory_profile.rb",
    "start_line": 51,
    "raw_source": "def sanitize(string)\n    string.downcase.gsub(/[\\W]/, '-').squeeze('-')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/comment_form.rb",
    "start_line": 6,
    "raw_source": "def initialize(tag_name, markup, options)\n    super\n\n    if markup =~ Syntax\n      @variable_name = Regexp.last_match(1)\n      @attributes    = {}\n    else\n      raise SyntaxError, \"Syntax Error in 'comment_form' - Valid syntax: comment_form [article]\"\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/comment_form.rb",
    "start_line": 17,
    "raw_source": "def render_to_output_buffer(context, output)\n    article = context[@variable_name]\n\n    context.stack do\n      context['form'] = {\n        'posted_successfully?' => context.registers[:posted_successfully],\n        'errors' => context['comment.errors'],\n        'author' => context['comment.author'],\n        'email' => context['comment.email'],\n        'body' => context['comment.body'],\n      }\n\n      output << wrap_in_form(article, render_all(@nodelist, context, output))\n      output\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/comment_form.rb",
    "start_line": 34,
    "raw_source": "def wrap_in_form(article, input)\n    %(<form id=\"article-#{article.id}-comment-form\" class=\"comment-form\" method=\"post\" action=\"\">\\n#{input}\\n</form>)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/database.rb",
    "start_line": 10,
    "raw_source": "def self.tables\n    @tables ||= begin\n      db =\n        if YAML.respond_to?(:unsafe_load_file) # Only Psych 4+ can use unsafe_load_file\n          # unsafe_load_file is needed for YAML references\n          YAML.unsafe_load_file(DATABASE_FILE_PATH)\n        else\n          YAML.load_file(DATABASE_FILE_PATH)\n        end\n\n      # From vision source\n      db['products'].each do |product|\n        collections = db['collections'].find_all do |collection|\n          collection['products'].any? { |p| p['id'].to_i == product['id'].to_i }\n        end\n        product['collections'] = collections\n      end\n\n      # key the tables by handles, as this is how liquid expects it.\n      db = db.each_with_object({}) do |(key, values), assigns|\n        assigns[key] = values.each_with_object({}) do |v, h|\n          h[v['handle']] = v\n        end\n      end\n\n      # Some standard direct accessors so that the specialized templates\n      # render correctly\n      db['collection'] = db['collections'].values.first\n      db['product']    = db['products'].values.first\n      db['blog']       = db['blogs'].values.first\n      db['article']    = db['blog']['articles'].first\n\n      db['cart']       = {\n        'total_price' => db['line_items'].values.inject(0) { |sum, item| sum + item['line_price'] * item['quantity'] },\n        'item_count' => db['line_items'].values.inject(0) { |sum, item| sum + item['quantity'] },\n        'items' => db['line_items'].values,\n      }\n\n      db\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/json_filter.rb",
    "start_line": 6,
    "raw_source": "def json(object)\n    JSON.dump(object.reject { |k, _v| k == \"collections\" })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/money_filter.rb",
    "start_line": 4,
    "raw_source": "def money_with_currency(money)\n    return '' if money.nil?\n    format(\"$ %.2f USD\", money / 100.0)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/money_filter.rb",
    "start_line": 9,
    "raw_source": "def money(money)\n    return '' if money.nil?\n    format(\"$ %.2f\", money / 100.0)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/money_filter.rb",
    "start_line": 16,
    "raw_source": "def currency\n    ShopDrop.new.currency\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/paginate.rb",
    "start_line": 6,
    "raw_source": "def initialize(tag_name, markup, options)\n    super\n\n    if markup =~ Syntax\n      @collection_name = Regexp.last_match(1)\n      @page_size       = if Regexp.last_match(2)\n        Regexp.last_match(3).to_i\n      else\n        20\n      end\n\n      @attributes = { 'window_size' => 3 }\n      markup.scan(Liquid::TagAttributes) do |key, value|\n        @attributes[key] = value\n      end\n    else\n      raise SyntaxError, \"Syntax Error in tag 'paginate' - Valid syntax: paginate [collection] by number\"\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/paginate.rb",
    "start_line": 26,
    "raw_source": "def render_to_output_buffer(context, output)\n    @context = context\n\n    context.stack do\n      current_page = context['current_page'].to_i\n\n      pagination = {\n        'page_size' => @page_size,\n        'current_page' => 5,\n        'current_offset' => @page_size * 5,\n      }\n\n      context['paginate'] = pagination\n\n      collection_size = context[@collection_name].size\n\n      raise ArgumentError, \"Cannot paginate array '#{@collection_name}'. Not found.\" if collection_size.nil?\n\n      page_count = (collection_size.to_f / @page_size.to_f).to_f.ceil + 1\n\n      pagination['items']      = collection_size\n      pagination['pages']      = page_count - 1\n      pagination['previous']   = link('&laquo; Previous', current_page - 1)  if 1 < current_page\n      pagination['next']       = link('Next &raquo;', current_page + 1)      if page_count > current_page + 1\n      pagination['parts']      = []\n\n      hellip_break = false\n\n      if page_count > 2\n        1.upto(page_count - 1) do |page|\n          if current_page == page\n            pagination['parts'] << no_link(page)\n          elsif page == 1\n            pagination['parts'] << link(page, page)\n          elsif page == page_count - 1\n            pagination['parts'] << link(page, page)\n          elsif page <= current_page - @attributes['window_size'] || page >= current_page + @attributes['window_size']\n            next if hellip_break\n            pagination['parts'] << no_link('&hellip;')\n            hellip_break = true\n            next\n          else\n            pagination['parts'] << link(page, page)\n          end\n\n          hellip_break = false\n        end\n      end\n\n      super\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/paginate.rb",
    "start_line": 81,
    "raw_source": "def no_link(title)\n    { 'title' => title, 'is_link' => false }\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/paginate.rb",
    "start_line": 85,
    "raw_source": "def link(title, page)\n    { 'title' => title, 'url' => current_url + \"?page=#{page}\", 'is_link' => true }\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/paginate.rb",
    "start_line": 89,
    "raw_source": "def current_url\n    \"/collections/frontpage\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/shop_filter.rb",
    "start_line": 4,
    "raw_source": "def asset_url(input)\n    \"/files/1/[shop_id]/[shop_id]/assets/#{input}\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/shop_filter.rb",
    "start_line": 8,
    "raw_source": "def global_asset_url(input)\n    \"/global/#{input}\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/shop_filter.rb",
    "start_line": 12,
    "raw_source": "def shopify_asset_url(input)\n    \"/shopify/#{input}\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/shop_filter.rb",
    "start_line": 16,
    "raw_source": "def script_tag(url)\n    %(<script src=\"#{url}\" type=\"text/javascript\"></script>)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/shop_filter.rb",
    "start_line": 20,
    "raw_source": "def stylesheet_tag(url, media = \"all\")\n    %(<link href=\"#{url}\" rel=\"stylesheet\" type=\"text/css\"  media=\"#{media}\"  />)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/shop_filter.rb",
    "start_line": 24,
    "raw_source": "def link_to(link, url, title = \"\")\n    %(<a href=\"#{url}\" title=\"#{title}\">#{link}</a>)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/shop_filter.rb",
    "start_line": 28,
    "raw_source": "def img_tag(url, alt = \"\")\n    %(<img src=\"#{url}\" alt=\"#{alt}\" />)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/shop_filter.rb",
    "start_line": 32,
    "raw_source": "def link_to_vendor(vendor)\n    if vendor\n      link_to(vendor, url_for_vendor(vendor), vendor)\n    else\n      'Unknown Vendor'\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/shop_filter.rb",
    "start_line": 40,
    "raw_source": "def link_to_type(type)\n    if type\n      link_to(type, url_for_type(type), type)\n    else\n      'Unknown Vendor'\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/shop_filter.rb",
    "start_line": 48,
    "raw_source": "def url_for_vendor(vendor_title)\n    \"/collections/#{to_handle(vendor_title)}\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/shop_filter.rb",
    "start_line": 52,
    "raw_source": "def url_for_type(type_title)\n    \"/collections/#{to_handle(type_title)}\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/shop_filter.rb",
    "start_line": 56,
    "raw_source": "def product_img_url(url, style = 'small')\n    unless url =~ %r{\\Aproducts/([\\w\\-\\_]+)\\.(\\w{2,4})}\n      raise ArgumentError, 'filter \"size\" can only be called on product images'\n    end\n\n    case style\n    when 'original'\n      '/files/shops/random_number/' + url\n    when 'grande', 'large', 'medium', 'compact', 'small', 'thumb', 'icon'\n      \"/files/shops/random_number/products/#{Regexp.last_match(1)}_#{style}.#{Regexp.last_match(2)}\"\n    else\n      raise ArgumentError, 'valid parameters for filter \"size\" are: original, grande, large, medium, compact, small, thumb and icon '\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/shop_filter.rb",
    "start_line": 71,
    "raw_source": "def default_pagination(paginate)\n    html = []\n    html << %(<span class=\"prev\">#{link_to(paginate['previous']['title'], paginate['previous']['url'])}</span>) if paginate['previous']\n\n    paginate['parts'].each do |part|\n      html << if part['is_link']\n        %(<span class=\"page\">#{link_to(part['title'], part['url'])}</span>)\n      elsif part['title'].to_i == paginate['current_page'].to_i\n        %(<span class=\"page current\">#{part['title']}</span>)\n      else\n        %(<span class=\"deco\">#{part['title']}</span>)\n      end\n    end\n\n    html << %(<span class=\"next\">#{link_to(paginate['next']['title'], paginate['next']['url'])}</span>) if paginate['next']\n    html.join(' ')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/shop_filter.rb",
    "start_line": 91,
    "raw_source": "def pluralize(input, singular, plural)\n    input == 1 ? singular : plural\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/shop_filter.rb",
    "start_line": 97,
    "raw_source": "def to_handle(str)\n    result = str.dup\n    result.downcase!\n    result.delete!(\"'\\\"()[]\")\n    result.gsub!(/\\W+/, '-')\n    result.gsub!(/-+\\z/, '') if result[-1] == '-'\n    result.gsub!(/\\A-+/, '') if result[0] == '-'\n    result\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/tag_filter.rb",
    "start_line": 4,
    "raw_source": "def link_to_tag(label, tag)\n    \"<a title=\\\"Show tag #{tag}\\\" href=\\\"/collections/#{@context['handle']}/#{tag}\\\">#{label}</a>\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/tag_filter.rb",
    "start_line": 8,
    "raw_source": "def highlight_active_tag(tag, css_class = 'active')\n    if @context['current_tags'].include?(tag)\n      \"<span class=\\\"#{css_class}\\\">#{tag}</span>\"\n    else\n      tag\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/tag_filter.rb",
    "start_line": 16,
    "raw_source": "def link_to_add_tag(label, tag)\n    tags = (@context['current_tags'] + [tag]).uniq\n    \"<a title=\\\"Show tag #{tag}\\\" href=\\\"/collections/#{@context['handle']}/#{tags.join('+')}\\\">#{label}</a>\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/tag_filter.rb",
    "start_line": 21,
    "raw_source": "def link_to_remove_tag(label, tag)\n    tags = (@context['current_tags'] - [tag]).uniq\n    \"<a title=\\\"Show tag #{tag}\\\" href=\\\"/collections/#{@context['handle']}/#{tags.join('+')}\\\">#{label}</a>\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/weight_filter.rb",
    "start_line": 4,
    "raw_source": "def weight(grams)\n    format(\"%.2f\", grams / 1000)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/shopify/weight_filter.rb",
    "start_line": 8,
    "raw_source": "def weight_with_unit(grams)\n    \"#{weight(grams)} kg\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/theme_runner.rb",
    "start_line": 16,
    "raw_source": "def initialize(path)\n      @path = path\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/theme_runner.rb",
    "start_line": 21,
    "raw_source": "def read_template_file(template_path)\n      File.read(@path + '/' + template_path + '.liquid')\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/theme_runner.rb",
    "start_line": 28,
    "raw_source": "def initialize\n    @tests = Dir[__dir__ + '/tests/**/*.liquid'].collect do |test|\n      next if File.basename(test) == 'theme.liquid'\n\n      theme_path = File.dirname(test) + '/theme.liquid'\n      {\n        liquid: File.read(test),\n        layout: (File.file?(theme_path) ? File.read(theme_path) : nil),\n        template_name: test,\n      }\n    end.compact\n\n    compile_all_tests\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/theme_runner.rb",
    "start_line": 44,
    "raw_source": "def compile\n    @tests.each do |test_hash|\n      Liquid::Template.new.parse(test_hash[:liquid])\n      Liquid::Template.new.parse(test_hash[:layout])\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/theme_runner.rb",
    "start_line": 52,
    "raw_source": "def tokenize\n    ss = StringScanner.new(\"\")\n    @tests.each do |test_hash|\n      tokenizer = Liquid::Tokenizer.new(\n        source: test_hash[:liquid],\n        string_scanner: ss,\n        line_numbers: true,\n      )\n      while tokenizer.shift; end\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/theme_runner.rb",
    "start_line": 65,
    "raw_source": "def run\n    each_test do |liquid, layout, assigns, page_template, template_name|\n      compile_and_render(liquid, layout, assigns, page_template, template_name)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/theme_runner.rb",
    "start_line": 72,
    "raw_source": "def render\n    @compiled_tests.each do |test|\n      tmpl    = test[:tmpl]\n      assigns = test[:assigns]\n      layout  = test[:layout]\n\n      if layout\n        assigns['content_for_layout'] = tmpl.render!(assigns)\n        layout.render!(assigns)\n      else\n        tmpl.render!(assigns)\n      end\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/theme_runner.rb",
    "start_line": 89,
    "raw_source": "def render_layout(template, layout, assigns)\n    assigns['content_for_layout'] = template.render!(assigns)\n    layout&.render!(assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/theme_runner.rb",
    "start_line": 94,
    "raw_source": "def compile_and_render(template, layout, assigns, page_template, template_file)\n    compiled_test = compile_test(template, layout, assigns, page_template, template_file)\n    render_layout(compiled_test[:tmpl], compiled_test[:layout], compiled_test[:assigns])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/theme_runner.rb",
    "start_line": 99,
    "raw_source": "def compile_all_tests\n    @compiled_tests = []\n    each_test do |liquid, layout, assigns, page_template, template_name|\n      @compiled_tests << compile_test(liquid, layout, assigns, page_template, template_name)\n    end\n    @compiled_tests\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/theme_runner.rb",
    "start_line": 107,
    "raw_source": "def compile_test(template, layout, assigns, page_template, template_file)\n    tmpl            = init_template(page_template, template_file)\n    parsed_template = tmpl.parse(template).dup\n\n    if layout\n      parsed_layout = tmpl.parse(layout)\n      { tmpl: parsed_template, assigns: assigns, layout: parsed_layout }\n    else\n      { tmpl: parsed_template, assigns: assigns }\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/theme_runner.rb",
    "start_line": 120,
    "raw_source": "def each_test\n    # Dup assigns because will make some changes to them\n    assigns = Database.tables.dup\n\n    @tests.each do |test_hash|\n      # Compute page_template outside of profiler run, uninteresting to profiler\n      page_template = File.basename(test_hash[:template_name], File.extname(test_hash[:template_name]))\n      yield(test_hash[:liquid], test_hash[:layout], assigns, page_template, test_hash[:template_name])\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/performance/theme_runner.rb",
    "start_line": 132,
    "raw_source": "def init_template(page_template, template_file)\n    tmpl                         = Liquid::Template.new\n    tmpl.assigns['page_title']   = 'Page title'\n    tmpl.assigns['template']     = page_template\n    tmpl.registers[:file_system] = ThemeRunner::FileSystem.new(File.dirname(template_file))\n    tmpl\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/assign_test.rb",
    "start_line": 8,
    "raw_source": "def test_assign_with_hyphen_in_variable_name\n    template_source = <<~END_TEMPLATE\n      {% assign this-thing = 'Print this-thing' -%}\n      {{ this-thing -}}\n    END_TEMPLATE\n    assert_template_result(\"Print this-thing\", template_source)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/assign_test.rb",
    "start_line": 16,
    "raw_source": "def test_assigned_variable\n    assert_template_result(\n      '.foo.',\n      '{% assign foo = values %}.{{ foo[0] }}.',\n      { 'values' => %w(foo bar baz) },\n    )\n\n    assert_template_result(\n      '.bar.',\n      '{% assign foo = values %}.{{ foo[1] }}.',\n      { 'values' => %w(foo bar baz) },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/assign_test.rb",
    "start_line": 30,
    "raw_source": "def test_assign_with_filter\n    assert_template_result(\n      '.bar.',\n      '{% assign foo = values | split: \",\" %}.{{ foo[1] }}.',\n      { 'values' => \"foo,bar,baz\" },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/assign_test.rb",
    "start_line": 38,
    "raw_source": "def test_assign_syntax_error\n    assert_match_syntax_error(/assign/, '{% assign foo not values %}.')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/assign_test.rb",
    "start_line": 42,
    "raw_source": "def test_assign_uses_error_mode\n    assert_match_syntax_error(\n      \"Expected dotdot but found pipe in \",\n      \"{% assign foo = ('X' | downcase) %}\",\n      error_mode: :strict,\n    )\n    assert_template_result(\"\", \"{% assign foo = ('X' | downcase) %}\", error_mode: :lax)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/assign_test.rb",
    "start_line": 51,
    "raw_source": "def test_expression_with_whitespace_in_square_brackets\n    source = \"{% assign r = a[ 'b' ] %}{{ r }}\"\n    assert_template_result('result', source, { 'a' => { 'b' => 'result' } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/assign_test.rb",
    "start_line": 56,
    "raw_source": "def test_assign_score_exceeding_resource_limit\n    t = Template.parse(\"{% assign foo = 42 %}{% assign bar = 23 %}\")\n    t.resource_limits.assign_score_limit = 1\n    assert_equal(\"Liquid error: Memory limits exceeded\", t.render)\n    assert(t.resource_limits.reached?)\n\n    t.resource_limits.assign_score_limit = 2\n    assert_equal(\"\", t.render!)\n    refute_nil(t.resource_limits.assign_score)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/assign_test.rb",
    "start_line": 67,
    "raw_source": "def test_assign_score_exceeding_limit_from_composite_object\n    t = Template.parse(\"{% assign foo = 'aaaa' | reverse %}\")\n\n    t.resource_limits.assign_score_limit = 3\n    assert_equal(\"Liquid error: Memory limits exceeded\", t.render)\n    assert(t.resource_limits.reached?)\n\n    t.resource_limits.assign_score_limit = 5\n    assert_equal(\"\", t.render!)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/assign_test.rb",
    "start_line": 78,
    "raw_source": "def test_assign_score_of_int\n    assert_equal(1, assign_score_of(123))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/assign_test.rb",
    "start_line": 82,
    "raw_source": "def test_assign_score_of_string_counts_bytes\n    assert_equal(3, assign_score_of('123'))\n    assert_equal(5, assign_score_of('12345'))\n    assert_equal(9, assign_score_of('すごい'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/assign_test.rb",
    "start_line": 88,
    "raw_source": "def test_assign_score_of_array\n    assert_equal(1, assign_score_of([]))\n    assert_equal(2, assign_score_of([123]))\n    assert_equal(6, assign_score_of([123, 'abcd']))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/assign_test.rb",
    "start_line": 94,
    "raw_source": "def test_assign_score_of_hash\n    assert_equal(1, assign_score_of({}))\n    assert_equal(5, assign_score_of('int' => 123))\n    assert_equal(12, assign_score_of('int' => 123, 'str' => 'abcd'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/assign_test.rb",
    "start_line": 103,
    "raw_source": "def initialize(obj)\n      @obj = obj\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/assign_test.rb",
    "start_line": 107,
    "raw_source": "def value\n      @obj\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/assign_test.rb",
    "start_line": 112,
    "raw_source": "def assign_score_of(obj)\n    context = Liquid::Context.new('drop' => ObjectWrapperDrop.new(obj))\n    Liquid::Template.parse('{% assign obj = drop.value %}').render!(context)\n    context.resource_limits.assign_score\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 6,
    "raw_source": "def render_to_output_buffer(_context, output)\n    output << ' '\n    output\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 16,
    "raw_source": "def wrap_in_for(body)\n    \"{% for i in (1..#{N}) %}#{body}{% endfor %}\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 20,
    "raw_source": "def wrap_in_if(body)\n    \"{% if true %}#{body}{% endif %}\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 24,
    "raw_source": "def wrap(body)\n    wrap_in_for(body) + wrap_in_if(body)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 28,
    "raw_source": "def test_new_tags_are_not_blank_by_default\n    with_custom_tag('foobar', FoobarTag) do\n      assert_equal(\" \" * N, Liquid::Template.parse(wrap_in_for(\"{% foobar %}\")).render!)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 34,
    "raw_source": "def test_loops_are_blank\n    assert_template_result(\"\", wrap_in_for(\" \"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 38,
    "raw_source": "def test_if_else_are_blank\n    assert_template_result(\"\", \"{% if true %} {% elsif false %} {% else %} {% endif %}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 42,
    "raw_source": "def test_unless_is_blank\n    assert_template_result(\"\", wrap(\"{% unless true %} {% endunless %}\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 46,
    "raw_source": "def test_mark_as_blank_only_during_parsing\n    assert_template_result(\" \" * (N + 1), wrap(\" {% if false %} this never happens, but still, this block is not blank {% endif %}\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 50,
    "raw_source": "def test_comments_are_blank\n    assert_template_result(\"\", wrap(\" {% comment %} whatever {% endcomment %} \"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 54,
    "raw_source": "def test_captures_are_blank\n    assert_template_result(\"\", wrap(\" {% capture foo %} whatever {% endcapture %} \"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 58,
    "raw_source": "def test_nested_blocks_are_blank_but_only_if_all_children_are\n    assert_template_result(\"\", wrap(wrap(\" \")))\n    assert_template_result(\n      \"\\n       but this is not \" * (N + 1),\n      wrap('{% if true %} {% comment %} this is blank {% endcomment %} {% endif %}\n      {% if true %} but this is not {% endif %}'),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 67,
    "raw_source": "def test_assigns_are_blank\n    assert_template_result(\"\", wrap(' {% assign foo = \"bar\" %} '))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 71,
    "raw_source": "def test_whitespace_is_blank\n    assert_template_result(\"\", wrap(\" \"))\n    assert_template_result(\"\", wrap(\"\\t\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 76,
    "raw_source": "def test_whitespace_is_not_blank_if_other_stuff_is_present\n    body = \"     x \"\n    assert_template_result(body * (N + 1), wrap(body))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 81,
    "raw_source": "def test_increment_is_not_blank\n    assert_template_result(\" 0\" * 2 * (N + 1), wrap(\"{% assign foo = 0 %} {% increment foo %} {% decrement foo %}\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 85,
    "raw_source": "def test_cycle_is_not_blank\n    assert_template_result(\"  \" * ((N + 1) / 2) + \" \", wrap(\"{% cycle ' ', ' ' %}\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 89,
    "raw_source": "def test_raw_is_not_blank\n    assert_template_result(\"  \" * (N + 1), wrap(\" {% raw %} {% endraw %}\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 93,
    "raw_source": "def test_include_is_blank\n    assert_template_result(\n      \"foobar\" * (N + 1),\n      wrap(\"{% include 'foobar' %}\"),\n      partials: { 'foobar' => 'foobar' },\n    )\n    assert_template_result(\n      \" foobar \" * (N + 1),\n      wrap(\"{% include ' foobar ' %}\"),\n      partials: { ' foobar ' => ' foobar ' },\n    )\n    assert_template_result(\n      \"   \" * (N + 1),\n      wrap(\" {% include ' ' %} \"),\n      partials: { ' ' => ' ' },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/blank_test.rb",
    "start_line": 111,
    "raw_source": "def test_case_is_blank\n    assert_template_result(\"\", wrap(\" {% assign foo = 'bar' %} {% case foo %} {% when 'bar' %} {% when 'whatever' %} {% else %} {% endcase %} \"))\n    assert_template_result(\"\", wrap(\" {% assign foo = 'else' %} {% case foo %} {% when 'bar' %} {% when 'whatever' %} {% else %} {% endcase %} \"))\n    assert_template_result(\"   x  \" * (N + 1), wrap(\" {% assign foo = 'else' %} {% case foo %} {% when 'bar' %} {% when 'whatever' %} {% else %} x {% endcase %} \"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/block_test.rb",
    "start_line": 8,
    "raw_source": "def test_unexpected_end_tag\n    source = '{% if true %}{% endunless %}'\n    assert_match_syntax_error(\"Liquid syntax error (line 1): 'endunless' is not a valid delimiter for if tags. use endif\", source)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/block_test.rb",
    "start_line": 13,
    "raw_source": "def test_with_custom_tag\n    with_custom_tag('testtag', Block) do\n      assert(Liquid::Template.parse(\"{% testtag %} {% endtesttag %}\"))\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/block_test.rb",
    "start_line": 19,
    "raw_source": "def test_custom_block_tags_have_a_default_render_to_output_buffer_method_for_backwards_compatibility\n    klass1 = Class.new(Block) do\n      def render(*)\n        'hello'\n      end\n    end\n\n    with_custom_tag('blabla', klass1) do\n      template = Liquid::Template.parse(\"{% blabla %} bla {% endblabla %}\")\n\n      assert_equal('hello', template.render)\n\n      buf    = +''\n      output = template.render({}, output: buf)\n      assert_equal('hello', output)\n      assert_equal('hello', buf)\n      assert_equal(buf.object_id, output.object_id)\n    end\n\n    klass2 = Class.new(klass1) do\n      def render(*)\n        'foo' + super + 'bar'\n      end\n    end\n\n    with_custom_tag('blabla', klass2) do\n      template = Liquid::Template.parse(\"{% blabla %} foo {% endblabla %}\")\n\n      assert_equal('foohellobar', template.render)\n\n      buf    = +''\n      output = template.render({}, output: buf)\n      assert_equal('foohellobar', output)\n      assert_equal('foohellobar', buf)\n      assert_equal(buf.object_id, output.object_id)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/block_test.rb",
    "start_line": 21,
    "raw_source": "def render(*)\n        'hello'\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/block_test.rb",
    "start_line": 39,
    "raw_source": "def render(*)\n        'foo' + super + 'bar'\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/capture_test.rb",
    "start_line": 8,
    "raw_source": "def test_captures_block_content_in_variable\n    assert_template_result(\"test string\", \"{% capture 'var' %}test string{% endcapture %}{{var}}\", {})\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/capture_test.rb",
    "start_line": 12,
    "raw_source": "def test_capture_with_hyphen_in_variable_name\n    template_source = <<~END_TEMPLATE\n      {% capture this-thing %}Print this-thing{% endcapture -%}\n      {{ this-thing -}}\n    END_TEMPLATE\n    assert_template_result(\"Print this-thing\", template_source)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/capture_test.rb",
    "start_line": 20,
    "raw_source": "def test_capture_to_variable_from_outer_scope_if_existing\n    template_source = <<~END_TEMPLATE\n      {% assign var = '' -%}\n      {% if true -%}\n        {% capture var %}first-block-string{% endcapture -%}\n      {% endif -%}\n      {% if true -%}\n        {% capture var %}test-string{% endcapture -%}\n      {% endif -%}\n      {{var-}}\n    END_TEMPLATE\n    assert_template_result(\"test-string\", template_source)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/capture_test.rb",
    "start_line": 34,
    "raw_source": "def test_assigning_from_capture\n    template_source = <<~END_TEMPLATE\n      {% assign first = '' -%}\n      {% assign second = '' -%}\n      {% for number in (1..3) -%}\n        {% capture first %}{{number}}{% endcapture -%}\n        {% assign second = first -%}\n      {% endfor -%}\n      {{ first }}-{{ second -}}\n    END_TEMPLATE\n    assert_template_result(\"3-3\", template_source)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/capture_test.rb",
    "start_line": 47,
    "raw_source": "def test_increment_assign_score_by_bytes_not_characters\n    t = Template.parse(\"{% capture foo %}すごい{% endcapture %}\")\n    t.render!\n    assert_equal(9, t.resource_limits.assign_score)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 6,
    "raw_source": "def to_liquid\n    100\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 12,
    "raw_source": "def amount\n    HundredCentes.new\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 16,
    "raw_source": "def non_zero?\n    true\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 22,
    "raw_source": "def test\n    @context['test']\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 30,
    "raw_source": "def initialize(name)\n    @name = name\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 34,
    "raw_source": "def to_liquid\n    CategoryDrop.new(self)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 40,
    "raw_source": "def initialize(products)\n    @products = products\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 44,
    "raw_source": "def size\n    @products.size\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 48,
    "raw_source": "def to_liquid\n    if @context[\"forloop\"]\n      @products.first(@context[\"forloop\"].length)\n    else\n      @products\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 60,
    "raw_source": "def initialize(category)\n    @category = category\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 66,
    "raw_source": "def count\n    @count ||= 0\n    @count  += 1\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 73,
    "raw_source": "def fetch(index)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 76,
    "raw_source": "def [](index)\n    @counts        ||= []\n    @counts[index] ||= 0\n    @counts[index]  += 1\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 82,
    "raw_source": "def to_liquid\n    self\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 90,
    "raw_source": "def setup\n    @context = Liquid::Context.new\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 94,
    "raw_source": "def test_variables\n    @context['string'] = 'string'\n    assert_equal('string', @context['string'])\n\n    @context['num'] = 5\n    assert_equal(5, @context['num'])\n\n    @context['time'] = Time.parse('2006-06-06 12:00:00')\n    assert_equal(Time.parse('2006-06-06 12:00:00'), @context['time'])\n\n    @context['date'] = Date.today\n    assert_equal(Date.today, @context['date'])\n\n    now = Time.now\n    @context['datetime'] = now\n    assert_equal(now, @context['datetime'])\n\n    @context['bool'] = true\n    assert_equal(true, @context['bool'])\n\n    @context['bool'] = false\n    assert_equal(false, @context['bool'])\n\n    @context['nil'] = nil\n    assert_nil(@context['nil'])\n    assert_nil(@context['nil'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 122,
    "raw_source": "def test_variables_not_existing\n    assert_template_result(\"true\", \"{% if does_not_exist == nil %}true{% endif %}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 126,
    "raw_source": "def test_scoping\n    @context.push\n    @context.pop\n\n    assert_raises(Liquid::ContextError) do\n      @context.pop\n    end\n\n    assert_raises(Liquid::ContextError) do\n      @context.push\n      @context.pop\n      @context.pop\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 141,
    "raw_source": "def test_length_query\n    assert_template_result(\n      \"true\",\n      \"{% if numbers.size == 4 %}true{% endif %}\",\n      { \"numbers\" => [1, 2, 3, 4] },\n    )\n\n    assert_template_result(\n      \"true\",\n      \"{% if numbers.size == 4 %}true{% endif %}\",\n      { \"numbers\" => { 1 => 1, 2 => 2, 3 => 3, 4 => 4 } },\n    )\n\n    assert_template_result(\n      \"true\",\n      \"{% if numbers.size == 1000 %}true{% endif %}\",\n      { \"numbers\" => { 1 => 1, 2 => 2, 3 => 3, 4 => 4, 'size' => 1000 } },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 161,
    "raw_source": "def test_hyphenated_variable\n    assert_template_result(\"godz\", \"{{ oh-my }}\", { \"oh-my\" => 'godz' })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 165,
    "raw_source": "def test_add_filter\n    filter = Module.new do\n      def hi(output)\n        output + ' hi!'\n      end\n    end\n\n    context = Context.new\n    context.add_filters(filter)\n    assert_equal('hi? hi!', context.invoke(:hi, 'hi?'))\n\n    context = Context.new\n    assert_equal('hi?', context.invoke(:hi, 'hi?'))\n\n    context.add_filters(filter)\n    assert_equal('hi? hi!', context.invoke(:hi, 'hi?'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 167,
    "raw_source": "def hi(output)\n        output + ' hi!'\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 183,
    "raw_source": "def test_only_intended_filters_make_it_there\n    filter = Module.new do\n      def hi(output)\n        output + ' hi!'\n      end\n    end\n\n    context = Context.new\n    assert_equal(\"Wookie\", context.invoke(\"hi\", \"Wookie\"))\n\n    context.add_filters(filter)\n    assert_equal(\"Wookie hi!\", context.invoke(\"hi\", \"Wookie\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 185,
    "raw_source": "def hi(output)\n        output + ' hi!'\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 197,
    "raw_source": "def test_add_item_in_outer_scope\n    @context['test'] = 'test'\n    @context.push\n    assert_equal('test', @context['test'])\n    @context.pop\n    assert_equal('test', @context['test'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 205,
    "raw_source": "def test_add_item_in_inner_scope\n    @context.push\n    @context['test'] = 'test'\n    assert_equal('test', @context['test'])\n    @context.pop\n    assert_nil(@context['test'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 213,
    "raw_source": "def test_hierachical_data\n    assigns = { 'hash' => { \"name\" => 'tobi' } }\n    assert_template_result(\"tobi\", \"{{ hash.name }}\", assigns)\n    assert_template_result(\"tobi\", '{{ hash[\"name\"] }}', assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 219,
    "raw_source": "def test_keywords\n    assert_template_result(\"pass\", \"{% if true == expect %}pass{% endif %}\", { \"expect\" => true })\n    assert_template_result(\"pass\", \"{% if false == expect %}pass{% endif %}\", { \"expect\" => false })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 224,
    "raw_source": "def test_digits\n    assert_template_result(\"pass\", \"{% if 100 == expect %}pass{% endif %}\", { \"expect\" => 100 })\n    assert_template_result(\"pass\", \"{% if 100.00 == expect %}pass{% endif %}\", { \"expect\" => 100.00 })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 229,
    "raw_source": "def test_strings\n    assert_template_result(\"hello!\", '{{ \"hello!\" }}')\n    assert_template_result(\"hello!\", \"{{ 'hello!' }}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 234,
    "raw_source": "def test_merge\n    @context.merge(\"test\" => \"test\")\n    assert_equal('test', @context['test'])\n    @context.merge(\"test\" => \"newvalue\", \"foo\" => \"bar\")\n    assert_equal('newvalue', @context['test'])\n    assert_equal('bar', @context['foo'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 242,
    "raw_source": "def test_array_notation\n    assigns = { \"test\" => [\"a\", \"b\"] }\n    assert_template_result(\"a\", \"{{ test[0] }}\", assigns)\n    assert_template_result(\"b\", \"{{ test[1] }}\", assigns)\n    assert_template_result(\"pass\", \"{% if test[2] == nil %}pass{% endif %}\", assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 249,
    "raw_source": "def test_recoursive_array_notation\n    assigns = { \"test\" => { 'test' => [1, 2, 3, 4, 5] } }\n    assert_template_result(\"1\", \"{{ test.test[0] }}\", assigns)\n\n    assigns = { \"test\" => [{ 'test' => 'worked' }] }\n    assert_template_result(\"worked\", \"{{ test[0].test }}\", assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 257,
    "raw_source": "def test_hash_to_array_transition\n    assigns = {\n      'colors' => {\n        'Blue' => ['003366', '336699', '6699CC', '99CCFF'],\n        'Green' => ['003300', '336633', '669966', '99CC99'],\n        'Yellow' => ['CC9900', 'FFCC00', 'FFFF99', 'FFFFCC'],\n        'Red' => ['660000', '993333', 'CC6666', 'FF9999'],\n      },\n    }\n\n    assert_template_result(\"003366\", \"{{ colors.Blue[0] }}\", assigns)\n    assert_template_result(\"FF9999\", \"{{ colors.Red[3] }}\", assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 271,
    "raw_source": "def test_try_first\n    assigns = { 'test' => [1, 2, 3, 4, 5] }\n    assert_template_result(\"1\", \"{{ test.first }}\", assigns)\n    assert_template_result(\"pass\", \"{% if test.last == 5 %}pass{% endif %}\", assigns)\n\n    assigns = { \"test\" => { \"test\" => [1, 2, 3, 4, 5] } }\n    assert_template_result(\"1\", \"{{ test.test.first }}\", assigns)\n    assert_template_result(\"5\", \"{{ test.test.last }}\", assigns)\n\n    assigns = { \"test\" => [1] }\n    assert_template_result(\"1\", \"{{ test.first }}\", assigns)\n    assert_template_result(\"1\", \"{{ test.last }}\", assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 285,
    "raw_source": "def test_access_hashes_with_hash_notation\n    assigns = { 'products' => { 'count' => 5, 'tags' => ['deepsnow', 'freestyle'] } }\n    assert_template_result(\"5\", '{{ products[\"count\"] }}', assigns)\n    assert_template_result(\"deepsnow\", '{{ products[\"tags\"][0] }}', assigns)\n    assert_template_result(\"deepsnow\", '{{ products[\"tags\"].first }}', assigns)\n\n    assigns = { 'product' => { 'variants' => [{ 'title' => 'draft151cm' }, { 'title' => 'element151cm' }] } }\n    assert_template_result(\"draft151cm\", '{{ product[\"variants\"][0][\"title\"] }}', assigns)\n    assert_template_result(\"element151cm\", '{{ product[\"variants\"][1][\"title\"] }}', assigns)\n    assert_template_result(\"draft151cm\", '{{ product[\"variants\"].first[\"title\"] }}', assigns)\n    assert_template_result(\"element151cm\", '{{ product[\"variants\"].last[\"title\"] }}', assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 298,
    "raw_source": "def test_access_variable_with_hash_notation\n    assert_template_result('baz', '{{ [\"foo\"] }}', { \"foo\" => \"baz\" })\n    assert_template_result('baz', '{{ [bar] }}', { 'foo' => 'baz', 'bar' => 'foo' })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 303,
    "raw_source": "def test_access_hashes_with_hash_access_variables\n    assigns = {\n      'var' => 'tags',\n      'nested' => { 'var' => 'tags' },\n      'products' => { 'count' => 5, 'tags' => ['deepsnow', 'freestyle'] },\n    }\n\n    assert_template_result('deepsnow', '{{ products[var].first }}', assigns)\n    assert_template_result('freestyle', '{{ products[nested.var].last }}', assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 314,
    "raw_source": "def test_hash_notation_only_for_hash_access\n    assigns = { \"array\" => [1, 2, 3, 4, 5] }\n    assert_template_result(\"1\", \"{{ array.first }}\", assigns)\n    assert_template_result(\"pass\", '{% if array[\"first\"] == nil %}pass{% endif %}', assigns)\n\n    assert_template_result(\"Hello\", '{{ hash[\"first\"] }}', { \"hash\" => { \"first\" => \"Hello\" } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 322,
    "raw_source": "def test_first_can_appear_in_middle_of_callchain\n    assigns = { \"product\" => { 'variants' => [{ 'title' => 'draft151cm' }, { 'title' => 'element151cm' }] } }\n\n    assert_template_result('draft151cm', '{{ product.variants[0].title }}', assigns)\n    assert_template_result('element151cm', '{{ product.variants[1].title }}', assigns)\n    assert_template_result('draft151cm', '{{ product.variants.first.title }}', assigns)\n    assert_template_result('element151cm', '{{ product.variants.last.title }}', assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 331,
    "raw_source": "def test_cents\n    @context.merge(\"cents\" => HundredCentes.new)\n    assert_equal(100, @context['cents'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 336,
    "raw_source": "def test_nested_cents\n    @context.merge(\"cents\" => { 'amount' => HundredCentes.new })\n    assert_equal(100, @context['cents.amount'])\n\n    @context.merge(\"cents\" => { 'cents' => { 'amount' => HundredCentes.new } })\n    assert_equal(100, @context['cents.cents.amount'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 344,
    "raw_source": "def test_cents_through_drop\n    @context.merge(\"cents\" => CentsDrop.new)\n    assert_equal(100, @context['cents.amount'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 349,
    "raw_source": "def test_nested_cents_through_drop\n    @context.merge(\"vars\" => { \"cents\" => CentsDrop.new })\n    assert_equal(100, @context['vars.cents.amount'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 354,
    "raw_source": "def test_drop_methods_with_question_marks\n    @context.merge(\"cents\" => CentsDrop.new)\n    assert(@context['cents.non_zero?'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 359,
    "raw_source": "def test_context_from_within_drop\n    @context.merge(\"test\" => '123', \"vars\" => ContextSensitiveDrop.new)\n    assert_equal('123', @context['vars.test'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 364,
    "raw_source": "def test_nested_context_from_within_drop\n    @context.merge(\"test\" => '123', \"vars\" => { \"local\" => ContextSensitiveDrop.new })\n    assert_equal('123', @context['vars.local.test'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 369,
    "raw_source": "def test_ranges\n    assert_template_result(\"1..5\", '{{ (1..5) }}')\n    assert_template_result(\"pass\", '{% if (1..5) == expect %}pass{% endif %}', { \"expect\" => (1..5) })\n\n    assigns = { \"test\" => '5' }\n    assert_template_result(\"1..5\", \"{{ (1..test) }}\", assigns)\n    assert_template_result(\"5..5\", \"{{ (test..test) }}\", assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 378,
    "raw_source": "def test_cents_through_drop_nestedly\n    @context.merge(\"cents\" => { \"cents\" => CentsDrop.new })\n    assert_equal(100, @context['cents.cents.amount'])\n\n    @context.merge(\"cents\" => { \"cents\" => { \"cents\" => CentsDrop.new } })\n    assert_equal(100, @context['cents.cents.cents.amount'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 386,
    "raw_source": "def test_drop_with_variable_called_only_once\n    @context['counter'] = CounterDrop.new\n\n    assert_equal(1, @context['counter.count'])\n    assert_equal(2, @context['counter.count'])\n    assert_equal(3, @context['counter.count'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 394,
    "raw_source": "def test_drop_with_key_called_only_once\n    @context['counter'] = CounterDrop.new\n\n    assert_equal(1, @context['counter[\"count\"]'])\n    assert_equal(2, @context['counter[\"count\"]'])\n    assert_equal(3, @context['counter[\"count\"]'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 402,
    "raw_source": "def test_proc_as_variable\n    @context['dynamic'] = proc { 'Hello' }\n\n    assert_equal('Hello', @context['dynamic'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 408,
    "raw_source": "def test_lambda_as_variable\n    @context['dynamic'] = proc { 'Hello' }\n\n    assert_equal('Hello', @context['dynamic'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 414,
    "raw_source": "def test_nested_lambda_as_variable\n    @context['dynamic'] = { \"lambda\" => proc { 'Hello' } }\n\n    assert_equal('Hello', @context['dynamic.lambda'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 420,
    "raw_source": "def test_array_containing_lambda_as_variable\n    @context['dynamic'] = [1, 2, proc { 'Hello' }, 4, 5]\n\n    assert_equal('Hello', @context['dynamic[2]'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 426,
    "raw_source": "def test_lambda_is_called_once\n    @global = 0\n\n    @context['callcount'] = proc {\n      @global += 1\n      @global.to_s\n    }\n\n    assert_equal('1', @context['callcount'])\n    assert_equal('1', @context['callcount'])\n    assert_equal('1', @context['callcount'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 439,
    "raw_source": "def test_nested_lambda_is_called_once\n    @global = 0\n\n    @context['callcount'] = {\n      \"lambda\" => proc {\n                    @global += 1\n                    @global.to_s\n                  },\n    }\n\n    assert_equal('1', @context['callcount.lambda'])\n    assert_equal('1', @context['callcount.lambda'])\n    assert_equal('1', @context['callcount.lambda'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 454,
    "raw_source": "def test_lambda_in_array_is_called_once\n    @global = 0\n\n    p = proc {\n      @global += 1\n      @global.to_s\n    }\n    @context['callcount'] = [1, 2, p, 4, 5]\n\n    assert_equal('1', @context['callcount[2]'])\n    assert_equal('1', @context['callcount[2]'])\n    assert_equal('1', @context['callcount[2]'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 468,
    "raw_source": "def test_access_to_context_from_proc\n    @context.registers[:magic] = 345392\n\n    @context['magic'] = proc { @context.registers[:magic] }\n\n    assert_equal(345392, @context['magic'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 476,
    "raw_source": "def test_to_liquid_and_context_at_first_level\n    @context['category'] = Category.new(\"foobar\")\n    assert_kind_of(CategoryDrop, @context['category'])\n    assert_equal(@context, @context['category'].context)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 482,
    "raw_source": "def test_interrupt_avoids_object_allocations\n    @context.interrupt? # ruby 3.0.0 allocates on the first call\n    assert_no_object_allocations do\n      @context.interrupt?\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 489,
    "raw_source": "def test_context_initialization_with_a_proc_in_environment\n    contx = Context.new([test: ->(c) { c['poutine'] }], test: :foo)\n\n    assert(contx)\n    assert_nil(contx['poutine'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 496,
    "raw_source": "def test_apply_global_filter\n    global_filter_proc = ->(output) { \"#{output} filtered\" }\n\n    context = Context.new\n    context.global_filter = global_filter_proc\n\n    assert_equal('hi filtered', context.apply_global_filter('hi'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 505,
    "raw_source": "def test_static_environments_are_read_with_lower_priority_than_environments\n    context = Context.build(\n      static_environments: { 'shadowed' => 'static', 'unshadowed' => 'static' },\n      environments: { 'shadowed' => 'dynamic' },\n    )\n\n    assert_equal('dynamic', context['shadowed'])\n    assert_equal('static', context['unshadowed'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 515,
    "raw_source": "def test_apply_global_filter_when_no_global_filter_exist\n    context = Context.new\n    assert_equal('hi', context.apply_global_filter('hi'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 520,
    "raw_source": "def test_new_isolated_subcontext_does_not_inherit_variables\n    super_context = Context.new\n    super_context['my_variable'] = 'some value'\n    subcontext = super_context.new_isolated_subcontext\n\n    assert_nil(subcontext['my_variable'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 528,
    "raw_source": "def test_new_isolated_subcontext_inherits_static_environment\n    super_context = Context.build(static_environments: { 'my_environment_value' => 'my value' })\n    subcontext    = super_context.new_isolated_subcontext\n\n    assert_equal('my value', subcontext['my_environment_value'])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 535,
    "raw_source": "def test_new_isolated_subcontext_inherits_resource_limits\n    resource_limits = ResourceLimits.new({})\n    super_context   = Context.new({}, {}, {}, false, resource_limits)\n    subcontext      = super_context.new_isolated_subcontext\n    assert_equal(resource_limits, subcontext.resource_limits)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 542,
    "raw_source": "def test_new_isolated_subcontext_inherits_exception_renderer\n    super_context = Context.new\n    super_context.exception_renderer = ->(_e) { 'my exception message' }\n    subcontext = super_context.new_isolated_subcontext\n    assert_equal('my exception message', subcontext.handle_error(Liquid::Error.new))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 549,
    "raw_source": "def test_new_isolated_subcontext_does_not_inherit_non_static_registers\n    registers = {\n      my_register: :my_value,\n    }\n    super_context = Context.new({}, {}, Registers.new(registers))\n    super_context.registers[:my_register] = :my_alt_value\n    subcontext                            = super_context.new_isolated_subcontext\n    assert_equal(:my_value, subcontext.registers[:my_register])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 559,
    "raw_source": "def test_new_isolated_subcontext_inherits_static_registers\n    super_context = Context.build(registers: { my_register: :my_value })\n    subcontext    = super_context.new_isolated_subcontext\n    assert_equal(:my_value, subcontext.registers[:my_register])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 565,
    "raw_source": "def test_new_isolated_subcontext_registers_do_not_pollute_context\n    super_context                      = Context.build(registers: { my_register: :my_value })\n    subcontext                         = super_context.new_isolated_subcontext\n    subcontext.registers[:my_register] = :my_alt_value\n    assert_equal(:my_value, super_context.registers[:my_register])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 572,
    "raw_source": "def test_new_isolated_subcontext_inherits_filters\n    my_filter = Module.new do\n      def my_filter(*)\n        'my filter result'\n      end\n    end\n\n    super_context = Context.new\n    super_context.add_filters([my_filter])\n    subcontext    = super_context.new_isolated_subcontext\n    template      = Template.parse('{{ 123 | my_filter }}')\n    assert_equal('my filter result', template.render(subcontext))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 574,
    "raw_source": "def my_filter(*)\n        'my filter result'\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 586,
    "raw_source": "def test_disables_tag_specified\n    context = Context.new\n    context.with_disabled_tags(%w(foo bar)) do\n      assert_equal(true, context.tag_disabled?(\"foo\"))\n      assert_equal(true, context.tag_disabled?(\"bar\"))\n      assert_equal(false, context.tag_disabled?(\"unknown\"))\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 595,
    "raw_source": "def test_disables_nested_tags\n    context = Context.new\n    context.with_disabled_tags([\"foo\"]) do\n      context.with_disabled_tags([\"foo\"]) do\n        assert_equal(true, context.tag_disabled?(\"foo\"))\n        assert_equal(false, context.tag_disabled?(\"bar\"))\n      end\n      context.with_disabled_tags([\"bar\"]) do\n        assert_equal(true, context.tag_disabled?(\"foo\"))\n        assert_equal(true, context.tag_disabled?(\"bar\"))\n        context.with_disabled_tags([\"foo\"]) do\n          assert_equal(true, context.tag_disabled?(\"foo\"))\n          assert_equal(true, context.tag_disabled?(\"bar\"))\n        end\n      end\n      assert_equal(true, context.tag_disabled?(\"foo\"))\n      assert_equal(false, context.tag_disabled?(\"bar\"))\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 615,
    "raw_source": "def test_override_global_filter\n    global = Module.new do\n      def notice(output)\n        \"Global #{output}\"\n      end\n    end\n\n    local = Module.new do\n      def notice(output)\n        \"Local #{output}\"\n      end\n    end\n\n    with_global_filter(global) do\n      assert_equal('Global test', Template.parse(\"{{'test' | notice }}\").render!)\n      assert_equal('Local test', Template.parse(\"{{'test' | notice }}\").render!({}, filters: [local]))\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 617,
    "raw_source": "def notice(output)\n        \"Global #{output}\"\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 623,
    "raw_source": "def notice(output)\n        \"Local #{output}\"\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 634,
    "raw_source": "def test_has_key_will_not_add_an_error_for_missing_keys\n    with_error_mode(:strict) do\n      context = Context.new\n      context.key?('unknown')\n      assert_empty(context.errors)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 642,
    "raw_source": "def test_context_always_uses_static_registers\n    registers = {\n      my_register: :my_value,\n    }\n    c = Context.new({}, {}, registers)\n    assert_instance_of(Registers, c.registers)\n    assert_equal(:my_value, c.registers[:my_register])\n\n    r = Registers.new(registers)\n    c = Context.new({}, {}, r)\n    assert_instance_of(Registers, c.registers)\n    assert_equal(:my_value, c.registers[:my_register])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 656,
    "raw_source": "def test_variable_to_liquid_returns_contextual_drop\n    context = {\n      \"products\" => ProductsDrop.new([\"A\", \"B\", \"C\", \"D\", \"E\"]),\n    }\n\n    template = Liquid::Template.parse(<<~LIQUID)\n      {%- for i in (1..3) -%}\n        for_loop_products_count: {{ products | size }}\n      {% endfor %}\n\n      unscoped_products_count: {{ products | size }}\n    LIQUID\n\n    result = template.render(context)\n\n    assert_includes(result, \"for_loop_products_count: 3\")\n    assert_includes(result, \"unscoped_products_count: 5\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 675,
    "raw_source": "def test_new_isolated_context_inherits_parent_environment\n    global_environment = Liquid::Environment.build(tags: {})\n    context = Context.build(environment: global_environment)\n\n    subcontext = context.new_isolated_subcontext\n    assert_equal(global_environment, subcontext.environment)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 683,
    "raw_source": "def test_newly_built_context_inherits_parent_environment\n    global_environment = Liquid::Environment.build(tags: {})\n    context = Context.build(environment: global_environment)\n    assert_equal(global_environment, context.environment)\n    assert(context.environment.tags.each.to_a.empty?)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/context_test.rb",
    "start_line": 692,
    "raw_source": "def assert_no_object_allocations\n    unless RUBY_ENGINE == 'ruby'\n      skip(\"stackprof needed to count object allocations\")\n    end\n    require 'stackprof'\n\n    profile = StackProf.run(mode: :object) do\n      yield\n    end\n    assert_equal(0, profile[:samples])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/document_test.rb",
    "start_line": 8,
    "raw_source": "def test_unexpected_outer_tag\n    source = \"{% else %}\"\n    assert_match_syntax_error(\"Liquid syntax error (line 1): Unexpected outer 'else' tag\", source)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/document_test.rb",
    "start_line": 13,
    "raw_source": "def test_unknown_tag\n    source = \"{% foo %}\"\n    assert_match_syntax_error(\"Liquid syntax error (line 1): Unknown tag 'foo'\", source)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 6,
    "raw_source": "def scopes\n    @context.scopes.size\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 10,
    "raw_source": "def scopes_as_array\n    (1..@context.scopes.size).to_a\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 14,
    "raw_source": "def loop_pos\n    @context['forloop.index']\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 18,
    "raw_source": "def liquid_method_missing(method)\n    @context[method]\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 25,
    "raw_source": "def array\n      ['text1', 'text2']\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 29,
    "raw_source": "def text\n      'text1'\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 35,
    "raw_source": "def liquid_method_missing(method)\n      \"catchall_method: #{method}\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 40,
    "raw_source": "def texts\n    TextDrop.new\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 44,
    "raw_source": "def catchall\n    CatchallDrop.new\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 48,
    "raw_source": "def context\n    ContextDrop.new\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 54,
    "raw_source": "def callmenot\n    \"protected\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 60,
    "raw_source": "def liquid_method_missing(method)\n    method\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 64,
    "raw_source": "def size\n    3\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 68,
    "raw_source": "def first\n    1\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 72,
    "raw_source": "def count\n    3\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 76,
    "raw_source": "def min\n    1\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 80,
    "raw_source": "def max\n    3\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 84,
    "raw_source": "def each\n    yield 1\n    yield 2\n    yield 3\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 94,
    "raw_source": "def liquid_method_missing(method)\n    method\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 98,
    "raw_source": "def each\n    yield 1\n    yield 2\n    yield 3\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 108,
    "raw_source": "def test_product_drop\n    tpl = Liquid::Template.parse('  ')\n    assert_equal('  ', tpl.render!('product' => ProductDrop.new))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 113,
    "raw_source": "def test_drop_does_only_respond_to_whitelisted_methods\n    assert_equal(\"\", Liquid::Template.parse(\"{{ product.inspect }}\").render!('product' => ProductDrop.new))\n    assert_equal(\"\", Liquid::Template.parse(\"{{ product.pretty_inspect }}\").render!('product' => ProductDrop.new))\n    assert_equal(\"\", Liquid::Template.parse(\"{{ product.whatever }}\").render!('product' => ProductDrop.new))\n    assert_equal(\"\", Liquid::Template.parse('{{ product | map: \"inspect\" }}').render!('product' => ProductDrop.new))\n    assert_equal(\"\", Liquid::Template.parse('{{ product | map: \"pretty_inspect\" }}').render!('product' => ProductDrop.new))\n    assert_equal(\"\", Liquid::Template.parse('{{ product | map: \"whatever\" }}').render!('product' => ProductDrop.new))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 122,
    "raw_source": "def test_drops_respond_to_to_liquid\n    assert_equal(\"text1\", Liquid::Template.parse(\"{{ product.to_liquid.texts.text }}\").render!('product' => ProductDrop.new))\n    assert_equal(\"text1\", Liquid::Template.parse('{{ product | map: \"to_liquid\" | map: \"texts\" | map: \"text\" }}').render!('product' => ProductDrop.new))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 127,
    "raw_source": "def test_text_drop\n    output = Liquid::Template.parse(' {{ product.texts.text }} ').render!('product' => ProductDrop.new)\n    assert_equal(' text1 ', output)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 132,
    "raw_source": "def test_catchall_unknown_method\n    output = Liquid::Template.parse(' {{ product.catchall.unknown }} ').render!('product' => ProductDrop.new)\n    assert_equal(' catchall_method: unknown ', output)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 137,
    "raw_source": "def test_catchall_integer_argument_drop\n    output = Liquid::Template.parse(' {{ product.catchall[8] }} ').render!('product' => ProductDrop.new)\n    assert_equal(' catchall_method: 8 ', output)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 142,
    "raw_source": "def test_text_array_drop\n    output = Liquid::Template.parse('{% for text in product.texts.array %} {{text}} {% endfor %}').render!('product' => ProductDrop.new)\n    assert_equal(' text1  text2 ', output)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 147,
    "raw_source": "def test_context_drop\n    output = Liquid::Template.parse(' {{ context.bar }} ').render!('context' => ContextDrop.new, 'bar' => \"carrot\")\n    assert_equal(' carrot ', output)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 152,
    "raw_source": "def test_context_drop_array_with_map\n    output = Liquid::Template.parse(' {{ contexts | map: \"bar\" }} ').render!('contexts' => [ContextDrop.new, ContextDrop.new], 'bar' => \"carrot\")\n    assert_equal(' carrotcarrot ', output)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 157,
    "raw_source": "def test_nested_context_drop\n    output = Liquid::Template.parse(' {{ product.context.foo }} ').render!('product' => ProductDrop.new, 'foo' => \"monkey\")\n    assert_equal(' monkey ', output)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 162,
    "raw_source": "def test_protected\n    output = Liquid::Template.parse(' {{ product.callmenot }} ').render!('product' => ProductDrop.new)\n    assert_equal('  ', output)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 167,
    "raw_source": "def test_object_methods_not_allowed\n    [:dup, :clone, :singleton_class, :eval, :class_eval, :inspect].each do |method|\n      output = Liquid::Template.parse(\" {{ product.#{method} }} \").render!('product' => ProductDrop.new)\n      assert_equal('  ', output)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 174,
    "raw_source": "def test_scope\n    assert_equal('1', Liquid::Template.parse('{{ context.scopes }}').render!('context' => ContextDrop.new))\n    assert_equal('2', Liquid::Template.parse('{%for i in dummy%}{{ context.scopes }}{%endfor%}').render!('context' => ContextDrop.new, 'dummy' => [1]))\n    assert_equal('3', Liquid::Template.parse('{%for i in dummy%}{%for i in dummy%}{{ context.scopes }}{%endfor%}{%endfor%}').render!('context' => ContextDrop.new, 'dummy' => [1]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 180,
    "raw_source": "def test_scope_though_proc\n    assert_equal('1', Liquid::Template.parse('{{ s }}').render!('context' => ContextDrop.new, 's' => proc { |c| c['context.scopes'] }))\n    assert_equal('2', Liquid::Template.parse('{%for i in dummy%}{{ s }}{%endfor%}').render!('context' => ContextDrop.new, 's' => proc { |c| c['context.scopes'] }, 'dummy' => [1]))\n    assert_equal('3', Liquid::Template.parse('{%for i in dummy%}{%for i in dummy%}{{ s }}{%endfor%}{%endfor%}').render!('context' => ContextDrop.new, 's' => proc { |c| c['context.scopes'] }, 'dummy' => [1]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 186,
    "raw_source": "def test_scope_with_assigns\n    assert_equal('variable', Liquid::Template.parse('{% assign a = \"variable\"%}{{a}}').render!('context' => ContextDrop.new))\n    assert_equal('variable', Liquid::Template.parse('{% assign a = \"variable\"%}{%for i in dummy%}{{a}}{%endfor%}').render!('context' => ContextDrop.new, 'dummy' => [1]))\n    assert_equal('test', Liquid::Template.parse('{% assign header_gif = \"test\"%}{{header_gif}}').render!('context' => ContextDrop.new))\n    assert_equal('test', Liquid::Template.parse(\"{% assign header_gif = 'test'%}{{header_gif}}\").render!('context' => ContextDrop.new))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 193,
    "raw_source": "def test_scope_from_tags\n    assert_equal('1', Liquid::Template.parse('{% for i in context.scopes_as_array %}{{i}}{% endfor %}').render!('context' => ContextDrop.new, 'dummy' => [1]))\n    assert_equal('12', Liquid::Template.parse('{%for a in dummy%}{% for i in context.scopes_as_array %}{{i}}{% endfor %}{% endfor %}').render!('context' => ContextDrop.new, 'dummy' => [1]))\n    assert_equal('123', Liquid::Template.parse('{%for a in dummy%}{%for a in dummy%}{% for i in context.scopes_as_array %}{{i}}{% endfor %}{% endfor %}{% endfor %}').render!('context' => ContextDrop.new, 'dummy' => [1]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 199,
    "raw_source": "def test_access_context_from_drop\n    assert_equal('123', Liquid::Template.parse('{%for a in dummy%}{{ context.loop_pos }}{% endfor %}').render!('context' => ContextDrop.new, 'dummy' => [1, 2, 3]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 203,
    "raw_source": "def test_enumerable_drop\n    assert_equal('123', Liquid::Template.parse('{% for c in collection %}{{c}}{% endfor %}').render!('collection' => EnumerableDrop.new))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 207,
    "raw_source": "def test_enumerable_drop_size\n    assert_equal('3', Liquid::Template.parse('{{collection.size}}').render!('collection' => EnumerableDrop.new))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 211,
    "raw_source": "def test_enumerable_drop_will_invoke_liquid_method_missing_for_clashing_method_names\n    [\"select\", \"each\", \"map\", \"cycle\"].each do |method|\n      assert_equal(method.to_s, Liquid::Template.parse(\"{{collection.#{method}}}\").render!('collection' => EnumerableDrop.new))\n      assert_equal(method.to_s, Liquid::Template.parse(\"{{collection[\\\"#{method}\\\"]}}\").render!('collection' => EnumerableDrop.new))\n      assert_equal(method.to_s, Liquid::Template.parse(\"{{collection.#{method}}}\").render!('collection' => RealEnumerableDrop.new))\n      assert_equal(method.to_s, Liquid::Template.parse(\"{{collection[\\\"#{method}\\\"]}}\").render!('collection' => RealEnumerableDrop.new))\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 220,
    "raw_source": "def test_some_enumerable_methods_still_get_invoked\n    [:count, :max].each do |method|\n      assert_equal(\"3\", Liquid::Template.parse(\"{{collection.#{method}}}\").render!('collection' => RealEnumerableDrop.new))\n      assert_equal(\"3\", Liquid::Template.parse(\"{{collection[\\\"#{method}\\\"]}}\").render!('collection' => RealEnumerableDrop.new))\n      assert_equal(\"3\", Liquid::Template.parse(\"{{collection.#{method}}}\").render!('collection' => EnumerableDrop.new))\n      assert_equal(\"3\", Liquid::Template.parse(\"{{collection[\\\"#{method}\\\"]}}\").render!('collection' => EnumerableDrop.new))\n    end\n\n    assert_equal(\"yes\", Liquid::Template.parse(\"{% if collection contains 3 %}yes{% endif %}\").render!('collection' => RealEnumerableDrop.new))\n\n    [:min, :first].each do |method|\n      assert_equal(\"1\", Liquid::Template.parse(\"{{collection.#{method}}}\").render!('collection' => RealEnumerableDrop.new))\n      assert_equal(\"1\", Liquid::Template.parse(\"{{collection[\\\"#{method}\\\"]}}\").render!('collection' => RealEnumerableDrop.new))\n      assert_equal(\"1\", Liquid::Template.parse(\"{{collection.#{method}}}\").render!('collection' => EnumerableDrop.new))\n      assert_equal(\"1\", Liquid::Template.parse(\"{{collection[\\\"#{method}\\\"]}}\").render!('collection' => EnumerableDrop.new))\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 238,
    "raw_source": "def test_empty_string_value_access\n    assert_equal('', Liquid::Template.parse('{{ product[value] }}').render!('product' => ProductDrop.new, 'value' => ''))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 242,
    "raw_source": "def test_nil_value_access\n    assert_equal('', Liquid::Template.parse('{{ product[value] }}').render!('product' => ProductDrop.new, 'value' => nil))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 246,
    "raw_source": "def test_default_to_s_on_drops\n    assert_equal('ProductDrop', Liquid::Template.parse(\"{{ product }}\").render!('product' => ProductDrop.new))\n    assert_equal('EnumerableDrop', Liquid::Template.parse('{{ collection }}').render!('collection' => EnumerableDrop.new))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/drop_test.rb",
    "start_line": 251,
    "raw_source": "def test_invokable_methods\n    assert_equal(%w(to_liquid catchall context texts).to_set, ProductDrop.invokable_methods)\n    assert_equal(%w(to_liquid scopes_as_array loop_pos scopes).to_set, ContextDrop.invokable_methods)\n    assert_equal(%w(to_liquid size max min first count).to_set, EnumerableDrop.invokable_methods)\n    assert_equal(%w(to_liquid max min sort count first).to_set, RealEnumerableDrop.invokable_methods)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 8,
    "raw_source": "def test_templates_parsed_with_line_numbers_renders_them_in_errors\n    template = <<-LIQUID\n      Hello,\n\n      {{ errors.standard_error }} will raise a standard error.\n\n      Bla bla test.\n\n      {{ errors.syntax_error }} will raise a syntax error.\n\n      This is an argument error: {{ errors.argument_error }}\n\n      Bla.\n    LIQUID\n\n    expected = <<-TEXT\n      Hello,\n\n      Liquid error (line 3): standard error will raise a standard error.\n\n      Bla bla test.\n\n      Liquid syntax error (line 7): syntax error will raise a syntax error.\n\n      This is an argument error: Liquid error (line 9): argument error\n\n      Bla.\n    TEXT\n\n    output = Liquid::Template.parse(template, line_numbers: true).render('errors' => ErrorDrop.new)\n    assert_equal(expected, output)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 41,
    "raw_source": "def test_standard_error\n    template = Liquid::Template.parse(' {{ errors.standard_error }} ')\n    assert_equal(' Liquid error: standard error ', template.render('errors' => ErrorDrop.new))\n\n    assert_equal(1, template.errors.size)\n    assert_equal(StandardError, template.errors.first.class)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 49,
    "raw_source": "def test_syntax\n    template = Liquid::Template.parse(' {{ errors.syntax_error }} ')\n    assert_equal(' Liquid syntax error: syntax error ', template.render('errors' => ErrorDrop.new))\n\n    assert_equal(1, template.errors.size)\n    assert_equal(SyntaxError, template.errors.first.class)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 57,
    "raw_source": "def test_argument\n    template = Liquid::Template.parse(' {{ errors.argument_error }} ')\n    assert_equal(' Liquid error: argument error ', template.render('errors' => ErrorDrop.new))\n\n    assert_equal(1, template.errors.size)\n    assert_equal(ArgumentError, template.errors.first.class)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 65,
    "raw_source": "def test_missing_endtag_parse_time_error\n    assert_match_syntax_error(/: 'for' tag was never closed\\z/, ' {% for a in b %} ... ')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 69,
    "raw_source": "def test_unrecognized_operator\n    with_error_mode(:strict) do\n      assert_raises(SyntaxError) do\n        Liquid::Template.parse(' {% if 1 =! 2 %}ok{% endif %} ')\n      end\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 77,
    "raw_source": "def test_lax_unrecognized_operator\n    template = Liquid::Template.parse(' {% if 1 =! 2 %}ok{% endif %} ', error_mode: :lax)\n    assert_equal(' Liquid error: Unknown operator =! ', template.render)\n    assert_equal(1, template.errors.size)\n    assert_equal(Liquid::ArgumentError, template.errors.first.class)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 84,
    "raw_source": "def test_with_line_numbers_adds_numbers_to_parser_errors\n    source = <<~LIQUID\n      foobar\n\n      {% \"cat\" | foobar %}\n\n      bla\n    LIQUID\n    assert_match_syntax_error(/Liquid syntax error \\(line 3\\)/, source)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 95,
    "raw_source": "def test_with_line_numbers_adds_numbers_to_parser_errors_with_whitespace_trim\n    source = <<~LIQUID\n      foobar\n\n      {%- \"cat\" | foobar -%}\n\n      bla\n    LIQUID\n\n    assert_match_syntax_error(/Liquid syntax error \\(line 3\\)/, source)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 107,
    "raw_source": "def test_parsing_warn_with_line_numbers_adds_numbers_to_lexer_errors\n    template = Liquid::Template.parse(\n      '\n        foobar\n\n        {% if 1 =! 2 %}ok{% endif %}\n\n        bla\n            ',\n      error_mode: :warn,\n      line_numbers: true,\n    )\n\n    assert_equal(\n      ['Liquid syntax error (line 4): Unexpected character = in \"1 =! 2\"'],\n      template.warnings.map(&:message),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 126,
    "raw_source": "def test_parsing_strict_with_line_numbers_adds_numbers_to_lexer_errors\n    err = assert_raises(SyntaxError) do\n      Liquid::Template.parse(\n        '\n          foobar\n\n          {% if 1 =! 2 %}ok{% endif %}\n\n          bla\n                ',\n        error_mode: :strict,\n        line_numbers: true,\n      )\n    end\n\n    assert_equal('Liquid syntax error (line 4): Unexpected character = in \"1 =! 2\"', err.message)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 144,
    "raw_source": "def test_syntax_errors_in_nested_blocks_have_correct_line_number\n    source = <<~LIQUID\n      foobar\n\n      {% if 1 != 2 %}\n        {% foo %}\n      {% endif %}\n\n      bla\n    LIQUID\n\n    assert_match_syntax_error(\"Liquid syntax error (line 4): Unknown tag 'foo'\", source)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 158,
    "raw_source": "def test_strict_error_messages\n    err = assert_raises(SyntaxError) do\n      Liquid::Template.parse(' {% if 1 =! 2 %}ok{% endif %} ', error_mode: :strict)\n    end\n    assert_equal('Liquid syntax error: Unexpected character = in \"1 =! 2\"', err.message)\n\n    err = assert_raises(SyntaxError) do\n      Liquid::Template.parse('{{%%%}}', error_mode: :strict)\n    end\n    assert_equal('Liquid syntax error: Unexpected character % in \"{{%%%}}\"', err.message)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 170,
    "raw_source": "def test_warnings\n    template = Liquid::Template.parse('{% if ~~~ %}{{%%%}}{% else %}{{ hello. }}{% endif %}', error_mode: :warn)\n    assert_equal(3, template.warnings.size)\n    assert_equal('Unexpected character ~ in \"~~~\"', template.warnings[0].to_s(false))\n    assert_equal('Unexpected character % in \"{{%%%}}\"', template.warnings[1].to_s(false))\n    assert_equal('Expected id but found end_of_string in \"{{ hello. }}\"', template.warnings[2].to_s(false))\n    assert_equal('', template.render)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 179,
    "raw_source": "def test_warning_line_numbers\n    template = Liquid::Template.parse(\"{% if ~~~ %}\\n{{%%%}}{% else %}\\n{{ hello. }}{% endif %}\", error_mode: :warn, line_numbers: true)\n    assert_equal('Liquid syntax error (line 1): Unexpected character ~ in \"~~~\"', template.warnings[0].message)\n    assert_equal('Liquid syntax error (line 2): Unexpected character % in \"{{%%%}}\"', template.warnings[1].message)\n    assert_equal('Liquid syntax error (line 3): Expected id but found end_of_string in \"{{ hello. }}\"', template.warnings[2].message)\n    assert_equal(3, template.warnings.size)\n    assert_equal([1, 2, 3], template.warnings.map(&:line_number))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 189,
    "raw_source": "def test_exceptions_propagate\n    assert_raises(Exception) do\n      template = Liquid::Template.parse('{{ errors.exception }}')\n      template.render('errors' => ErrorDrop.new)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 196,
    "raw_source": "def test_default_exception_renderer_with_internal_error\n    template = Liquid::Template.parse('This is a runtime error: {{ errors.runtime_error }}', line_numbers: true)\n\n    output = template.render('errors' => ErrorDrop.new)\n\n    assert_equal('This is a runtime error: Liquid error (line 1): internal', output)\n    assert_equal([Liquid::InternalError], template.errors.map(&:class))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 205,
    "raw_source": "def test_setting_default_exception_renderer\n    exceptions = []\n    default_exception_renderer = ->(e) {\n      exceptions << e\n      ''\n    }\n\n    env = Liquid::Environment.build(exception_renderer: default_exception_renderer)\n    template = Liquid::Template.parse('This is a runtime error: {{ errors.argument_error }}', environment: env)\n\n    output = template.render('errors' => ErrorDrop.new)\n\n    assert_equal('This is a runtime error: ', output)\n    assert_equal([Liquid::ArgumentError], template.errors.map(&:class))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 221,
    "raw_source": "def test_setting_exception_renderer_on_environment\n    exceptions = []\n    exception_renderer = ->(e) do\n      exceptions << e\n      ''\n    end\n\n    environment = Liquid::Environment.build(exception_renderer: exception_renderer)\n    template = Liquid::Template.parse('This is a runtime error: {{ errors.argument_error }}', environment: environment)\n    output = template.render('errors' => ErrorDrop.new)\n\n    assert_equal('This is a runtime error: ', output)\n    assert_equal([Liquid::ArgumentError], template.errors.map(&:class))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 236,
    "raw_source": "def test_exception_renderer_exposing_non_liquid_error\n    template   = Liquid::Template.parse('This is a runtime error: {{ errors.runtime_error }}', line_numbers: true)\n    exceptions = []\n    handler    = ->(e) {\n      exceptions << e\n      e.cause\n    }\n\n    output = template.render({ 'errors' => ErrorDrop.new }, exception_renderer: handler)\n\n    assert_equal('This is a runtime error: runtime error', output)\n    assert_equal([Liquid::InternalError], exceptions.map(&:class))\n    assert_equal(exceptions, template.errors)\n    assert_equal('#<RuntimeError: runtime error>', exceptions.first.cause.inspect)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 253,
    "raw_source": "def read_template_file(_template_path)\n      \"{{ errors.argument_error }}\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 258,
    "raw_source": "def test_included_template_name_with_line_numbers\n    environment = Liquid::Environment.build(file_system: TestFileSystem.new)\n    template = Liquid::Template.parse(\"Argument error:\\n{% include 'product' %}\", line_numbers: true, environment: environment)\n    page     = template.render('errors' => ErrorDrop.new)\n\n    assert_equal(\"Argument error:\\nLiquid error (product line 1): argument error\", page)\n    assert_equal(\"product\", template.errors.first.template_name)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 267,
    "raw_source": "def test_bug_compatible_silencing_of_errors_in_blank_nodes\n    output = Liquid::Template.parse(\"{% assign x = 0 %}{% if 1 < '2' %}not blank{% assign x = 3 %}{% endif %}{{ x }}\").render\n    assert_equal(\"Liquid error: comparison of Integer with String failed0\", output)\n\n    output = Liquid::Template.parse(\"{% assign x = 0 %}{% if 1 < '2' %}{% assign x = 3 %}{% endif %}{{ x }}\").render\n    assert_equal(\"0\", output)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 275,
    "raw_source": "def test_syntax_error_is_raised_with_template_name\n    file_system = StubFileSystem.new(\"snippet\" => \"1\\n2\\n{{ 1\")\n\n    context = Liquid::Context.build(\n      registers: { file_system: file_system },\n    )\n\n    template = Template.parse(\n      '{% render \"snippet\" %}',\n      line_numbers: true,\n    )\n    template.name = \"template/index\"\n\n    assert_equal(\n      \"Liquid syntax error (snippet line 3): Variable '{{' was not properly terminated with regexp: /\\\\}\\\\}/\",\n      template.render(context),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 294,
    "raw_source": "def test_syntax_error_is_raised_with_template_name_from_template_factory\n    file_system = StubFileSystem.new(\"snippet\" => \"1\\n2\\n{{ 1\")\n\n    context = Liquid::Context.build(\n      registers: {\n        file_system: file_system,\n        template_factory: StubTemplateFactory.new,\n      },\n    )\n\n    template = Template.parse(\n      '{% render \"snippet\" %}',\n      line_numbers: true,\n    )\n    template.name = \"template/index\"\n\n    assert_equal(\n      \"Liquid syntax error (some/path/snippet line 3): Variable '{{' was not properly terminated with regexp: /\\\\}\\\\}/\",\n      template.render(context),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 316,
    "raw_source": "def test_error_is_raised_during_parse_with_template_name\n    depth = Liquid::Block::MAX_DEPTH + 1\n    code = \"{% if true %}\" * depth + \"rendered\" + \"{% endif %}\" * depth\n\n    template = Template.parse(\"{% render 'snippet' %}\", line_numbers: true)\n\n    context = Liquid::Context.build(\n      registers: {\n        file_system: StubFileSystem.new(\"snippet\" => code),\n        template_factory: StubTemplateFactory.new,\n      },\n    )\n\n    assert_equal(\"Liquid error (some/path/snippet line 1): Nesting too deep\", template.render(context))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/error_handling_test.rb",
    "start_line": 332,
    "raw_source": "def test_internal_error_is_raised_with_template_name\n    template = Template.new\n    template.parse(\n      \"{% render 'snippet' %}\",\n      line_numbers: true,\n    )\n    template.name = \"template/index\"\n\n    context = Liquid::Context.build(\n      registers: {\n        file_system: StubFileSystem.new({}),\n      },\n    )\n\n    assert_equal(\n      \"Liquid error (template/index line 1): internal\",\n      template.render(context),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/expression_test.rb",
    "start_line": 7,
    "raw_source": "def test_keyword_literals\n    assert_template_result(\"true\", \"{{ true }}\")\n    assert_expression_result(true, \"true\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/expression_test.rb",
    "start_line": 12,
    "raw_source": "def test_string\n    assert_template_result(\"single quoted\", \"{{'single quoted'}}\")\n    assert_template_result(\"double quoted\", '{{\"double quoted\"}}')\n    assert_template_result(\"spaced\", \"{{ 'spaced' }}\")\n    assert_template_result(\"spaced2\", \"{{ 'spaced2' }}\")\n    assert_template_result(\"emoji🔥\", \"{{ 'emoji🔥' }}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/expression_test.rb",
    "start_line": 20,
    "raw_source": "def test_int\n    assert_template_result(\"456\", \"{{ 456 }}\")\n    assert_expression_result(123, \"123\")\n    assert_expression_result(12, \"012\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/expression_test.rb",
    "start_line": 26,
    "raw_source": "def test_float\n    assert_template_result(\"-17.42\", \"{{ -17.42 }}\")\n    assert_template_result(\"2.5\", \"{{ 2.5 }}\")\n    assert_expression_result(0.0, \"0.....5\")\n    assert_expression_result(0.0, \"-0..1\")\n    assert_expression_result(1.5, \"1.5\")\n\n    # this is a unfortunate quirky behavior of Liquid\n    result = Expression.parse(\".5\")\n    assert_kind_of(Liquid::VariableLookup, result)\n\n    result = Expression.parse(\"-.5\")\n    assert_kind_of(Liquid::VariableLookup, result)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/expression_test.rb",
    "start_line": 41,
    "raw_source": "def test_range\n    assert_template_result(\"3..4\", \"{{ ( 3 .. 4 ) }}\")\n    assert_expression_result(1..2, \"(1..2)\")\n\n    assert_match_syntax_error(\n      \"Liquid syntax error (line 1): Invalid expression type 'false' in range expression\",\n      \"{{ (false..true) }}\",\n    )\n    assert_match_syntax_error(\n      \"Liquid syntax error (line 1): Invalid expression type '(1..2)' in range expression\",\n      \"{{ ((1..2)..3) }}\",\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/expression_test.rb",
    "start_line": 55,
    "raw_source": "def test_quirky_negative_sign_expression_markup\n    result = Expression.parse(\"-\", nil)\n    assert(result.is_a?(VariableLookup))\n    assert_equal(\"-\", result.name)\n\n    # for this template, the expression markup is \"-\"\n    assert_template_result(\n      \"\",\n      \"{{ - 'theme.css' - }}\",\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/expression_test.rb",
    "start_line": 67,
    "raw_source": "def test_expression_cache\n    skip(\"Liquid-C does not support Expression caching\") if defined?(Liquid::C) && Liquid::C.enabled\n\n    cache = {}\n    template = <<~LIQUID\n      {% assign x = 1 %}\n      {{ x }}\n      {% assign x = 2 %}\n      {{ x }}\n      {% assign y = 1 %}\n      {{ y }}\n    LIQUID\n\n    Liquid::Template.parse(template, expression_cache: cache).render\n\n    assert_equal(\n      [\"1\", \"2\", \"x\", \"y\"],\n      cache.to_a.map { _1[0] }.sort,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/expression_test.rb",
    "start_line": 88,
    "raw_source": "def test_expression_cache_with_true_boolean\n    skip(\"Liquid-C does not support Expression caching\") if defined?(Liquid::C) && Liquid::C.enabled\n\n    template = <<~LIQUID\n      {% assign x = 1 %}\n      {{ x }}\n      {% assign x = 2 %}\n      {{ x }}\n      {% assign y = 1 %}\n      {{ y }}\n    LIQUID\n\n    parse_context = ParseContext.new(expression_cache: true)\n\n    Liquid::Template.parse(template, parse_context).render\n\n    cache = parse_context.instance_variable_get(:@expression_cache)\n\n    assert_equal(\n      [\"1\", \"2\", \"x\", \"y\"],\n      cache.to_a.map { _1[0] }.sort,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/expression_test.rb",
    "start_line": 112,
    "raw_source": "def test_expression_cache_with_lru_redux\n    skip(\"Liquid-C does not support Expression caching\") if defined?(Liquid::C) && Liquid::C.enabled\n\n    cache = LruRedux::Cache.new(10)\n    template = <<~LIQUID\n      {% assign x = 1 %}\n      {{ x }}\n      {% assign x = 2 %}\n      {{ x }}\n      {% assign y = 1 %}\n      {{ y }}\n    LIQUID\n\n    Liquid::Template.parse(template, expression_cache: cache).render\n\n    assert_equal(\n      [\"1\", \"2\", \"x\", \"y\"],\n      cache.to_a.map { _1[0] }.sort,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/expression_test.rb",
    "start_line": 133,
    "raw_source": "def test_disable_expression_cache\n    skip(\"Liquid-C does not support Expression caching\") if defined?(Liquid::C) && Liquid::C.enabled\n\n    template = <<~LIQUID\n      {% assign x = 1 %}\n      {{ x }}\n      {% assign x = 2 %}\n      {{ x }}\n      {% assign y = 1 %}\n      {{ y }}\n    LIQUID\n\n    parse_context = Liquid::ParseContext.new(expression_cache: false)\n    Liquid::Template.parse(template, parse_context).render\n    assert(parse_context.instance_variable_get(:@expression_cache).nil?)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/expression_test.rb",
    "start_line": 152,
    "raw_source": "def assert_expression_result(expect, markup, **assigns)\n    liquid = \"{% if expect == #{markup} %}pass{% else %}got {{ #{markup} }}{% endif %}\"\n    assert_template_result(\"pass\", liquid, { \"expect\" => expect, **assigns })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_kwarg_test.rb",
    "start_line": 7,
    "raw_source": "def html_tag(_tag, attributes)\n      attributes\n        .map { |key, value| \"#{key}='#{value}'\" }\n        .join(' ')\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_kwarg_test.rb",
    "start_line": 16,
    "raw_source": "def test_can_parse_data_kwargs\n    with_global_filter(KwargFilter) do\n      assert_equal(\n        \"data-src='src' data-widths='100, 200'\",\n        Template.parse(\"{{ 'img' | html_tag: data-src: 'src', data-widths: '100, 200' }}\").render(nil, nil),\n      )\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 6,
    "raw_source": "def money(input)\n    format(' %d$ ', input)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 10,
    "raw_source": "def money_with_underscore(input)\n    format(' %d$ ', input)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 16,
    "raw_source": "def money(input)\n    format(' %d$ CAD ', input)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 22,
    "raw_source": "def substitute(input, params = {})\n    input.gsub(/%\\{(\\w+)\\}/) { |_match| params[Regexp.last_match(1)] }\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 31,
    "raw_source": "def tap(_input)\n      \"tap overridden\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 36,
    "raw_source": "def setup\n    @context = Context.new\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 40,
    "raw_source": "def test_local_filter\n    @context['var'] = 1000\n    @context.add_filters(MoneyFilter)\n\n    assert_equal(' 1000$ ', Template.parse(\"{{var | money}}\").render(@context))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 47,
    "raw_source": "def test_underscore_in_filter_name\n    @context['var'] = 1000\n    @context.add_filters(MoneyFilter)\n    assert_equal(' 1000$ ', Template.parse(\"{{var | money_with_underscore}}\").render(@context))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 53,
    "raw_source": "def test_second_filter_overwrites_first\n    @context['var'] = 1000\n    @context.add_filters(MoneyFilter)\n    @context.add_filters(CanadianMoneyFilter)\n\n    assert_equal(' 1000$ CAD ', Template.parse(\"{{var | money}}\").render(@context))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 61,
    "raw_source": "def test_size\n    assert_template_result(\"4\", \"{{var | size}}\", { \"var\" => 'abcd' })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 65,
    "raw_source": "def test_join\n    assert_template_result(\"1 2 3 4\", \"{{var | join}}\", { \"var\" => [1, 2, 3, 4] })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 69,
    "raw_source": "def test_sort\n    assert_template_result(\"1 2 3 4\", \"{{numbers | sort | join}}\", { \"numbers\" => [2, 1, 4, 3] })\n    assert_template_result(\n      \"alphabetic as expected\",\n      \"{{words | sort | join}}\",\n      { \"words\" => ['expected', 'as', 'alphabetic'] },\n    )\n    assert_template_result(\"3\", \"{{value | sort}}\", { \"value\" => 3 })\n    assert_template_result('are flower', \"{{arrays | sort | join}}\", { 'arrays' => ['flower', 'are'] })\n    assert_template_result(\n      \"Expected case sensitive\",\n      \"{{case_sensitive | sort | join}}\",\n      { \"case_sensitive\" => [\"sensitive\", \"Expected\", \"case\"] },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 85,
    "raw_source": "def test_sort_natural\n    # Test strings\n    assert_template_result(\n      \"Assert case Insensitive\",\n      \"{{words | sort_natural | join}}\",\n      { \"words\" => [\"case\", \"Assert\", \"Insensitive\"] },\n    )\n\n    # Test hashes\n    assert_template_result(\n      \"A b C\",\n      \"{{hashes | sort_natural: 'a' | map: 'a' | join}}\",\n      { \"hashes\" => [{ \"a\" => \"A\" }, { \"a\" => \"b\" }, { \"a\" => \"C\" }] },\n    )\n\n    # Test objects\n    @context['objects'] = [TestObject.new('A'), TestObject.new('b'), TestObject.new('C')]\n    assert_equal('A b C', Template.parse(\"{{objects | sort_natural: 'a' | map: 'a' | join}}\").render(@context))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 105,
    "raw_source": "def test_compact\n    # Test strings\n    assert_template_result(\n      \"a b c\",\n      \"{{words | compact | join}}\",\n      { \"words\" => ['a', nil, 'b', nil, 'c'] },\n    )\n\n    # Test hashes\n    assert_template_result(\n      \"A C\",\n      \"{{hashes | compact: 'a' | map: 'a' | join}}\",\n      { \"hashes\" => [{ \"a\" => \"A\" }, { \"a\" => nil }, { \"a\" => \"C\" }] },\n    )\n\n    # Test objects\n    @context['objects'] = [TestObject.new('A'), TestObject.new(nil), TestObject.new('C')]\n    assert_equal('A C', Template.parse(\"{{objects | compact: 'a' | map: 'a' | join}}\").render(@context))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 125,
    "raw_source": "def test_strip_html\n    assert_template_result(\"bla blub\", \"{{ var | strip_html }}\", { \"var\" => \"<b>bla blub</a>\" })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 129,
    "raw_source": "def test_strip_html_ignore_comments_with_html\n    assert_template_result(\n      \"bla blub\",\n      \"{{ var | strip_html }}\",\n      { \"var\" => \"<!-- split and some <ul> tag --><b>bla blub</a>\" },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 137,
    "raw_source": "def test_capitalize\n    assert_template_result(\"Blub\", \"{{ var | capitalize }}\", { \"var\" => \"blub\" })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 141,
    "raw_source": "def test_nonexistent_filter_is_ignored\n    assert_template_result(\"1000\", \"{{ var | xyzzy }}\", { \"var\" => 1000 })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 145,
    "raw_source": "def test_filter_with_keyword_arguments\n    @context['surname'] = 'john'\n    @context['input']   = 'hello %{first_name}, %{last_name}'\n    @context.add_filters(SubstituteFilter)\n    output              = Template.parse(%({{ input | substitute: first_name: surname, last_name: 'doe' }})).render(@context)\n    assert_equal('hello john, doe', output)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 153,
    "raw_source": "def test_override_object_method_in_filter\n    assert_equal(\"tap overridden\", Template.parse(\"{{var | tap}}\").render!({ 'var' => 1000 }, filters: [OverrideObjectMethodFilter]))\n\n    # tap still treated as a non-existent filter\n    assert_equal(\"1000\", Template.parse(\"{{var | tap}}\").render!('var' => 1000))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 160,
    "raw_source": "def test_liquid_argument_error\n    source = \"{{ '' | size: 'too many args' }}\"\n    exc = assert_raises(Liquid::ArgumentError) do\n      Template.parse(source).render!\n    end\n    assert_match(/\\ALiquid error: wrong number of arguments /, exc.message)\n    assert_equal(exc.message, Template.parse(source).render)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 173,
    "raw_source": "def test_local_global\n    with_global_filter(MoneyFilter) do\n      assert_equal(\" 1000$ \", Template.parse(\"{{1000 | money}}\").render!(nil, nil))\n      assert_equal(\" 1000$ CAD \", Template.parse(\"{{1000 | money}}\").render!(nil, filters: CanadianMoneyFilter))\n      assert_equal(\" 1000$ CAD \", Template.parse(\"{{1000 | money}}\").render!(nil, filters: [CanadianMoneyFilter]))\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 181,
    "raw_source": "def test_local_filter_with_deprecated_syntax\n    assert_equal(\" 1000$ CAD \", Template.parse(\"{{1000 | money}}\").render!(nil, CanadianMoneyFilter))\n    assert_equal(\" 1000$ CAD \", Template.parse(\"{{1000 | money}}\").render!(nil, [CanadianMoneyFilter]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/filter_test.rb",
    "start_line": 189,
    "raw_source": "def initialize(a)\n    @a = a\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_ordering_test.rb",
    "start_line": 7,
    "raw_source": "def money(input)\n      format(' %d$ ', input)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_ordering_test.rb",
    "start_line": 13,
    "raw_source": "def money(input)\n      format(' %d$ CAD ', input)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_ordering_test.rb",
    "start_line": 20,
    "raw_source": "def test_global_register_order\n    with_global_filter(MoneyFilter, CanadianMoneyFilter) do\n      assert_equal(\" 1000$ CAD \", Template.parse(\"{{1000 | money}}\").render(nil, nil))\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 6,
    "raw_source": "def test_render_empty_hash\n    assert_template_result(\"{}\", \"{{ my_hash }}\", { \"my_hash\" => {} })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 10,
    "raw_source": "def test_render_hash_with_string_keys_and_values\n    assert_template_result(\"{\\\"key1\\\"=>\\\"value1\\\", \\\"key2\\\"=>\\\"value2\\\"}\", \"{{ my_hash }}\", { \"my_hash\" => { \"key1\" => \"value1\", \"key2\" => \"value2\" } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 14,
    "raw_source": "def test_render_hash_with_symbol_keys_and_integer_values\n    assert_template_result(\"{:key1=>1, :key2=>2}\", \"{{ my_hash }}\", { \"my_hash\" => { key1: 1, key2: 2 } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 18,
    "raw_source": "def test_render_nested_hash\n    assert_template_result(\"{\\\"outer\\\"=>{\\\"inner\\\"=>\\\"value\\\"}}\", \"{{ my_hash }}\", { \"my_hash\" => { \"outer\" => { \"inner\" => \"value\" } } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 22,
    "raw_source": "def test_render_hash_with_array_values\n    assert_template_result(\"{\\\"numbers\\\"=>[1, 2, 3]}\", \"{{ my_hash }}\", { \"my_hash\" => { \"numbers\" => [1, 2, 3] } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 26,
    "raw_source": "def test_render_recursive_hash\n    recursive_hash = { \"self\" => {} }\n    recursive_hash[\"self\"][\"self\"] = recursive_hash\n    assert_template_result(\"{\\\"self\\\"=>{\\\"self\\\"=>{...}}}\", \"{{ my_hash }}\", { \"my_hash\" => recursive_hash })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 32,
    "raw_source": "def test_hash_with_downcase_filter\n    assert_template_result(\"{\\\"key\\\"=>\\\"value\\\", \\\"anotherkey\\\"=>\\\"anothervalue\\\"}\", \"{{ my_hash | downcase }}\", { \"my_hash\" => { \"Key\" => \"Value\", \"AnotherKey\" => \"AnotherValue\" } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 36,
    "raw_source": "def test_hash_with_upcase_filter\n    assert_template_result(\"{\\\"KEY\\\"=>\\\"VALUE\\\", \\\"ANOTHERKEY\\\"=>\\\"ANOTHERVALUE\\\"}\", \"{{ my_hash | upcase }}\", { \"my_hash\" => { \"Key\" => \"Value\", \"AnotherKey\" => \"AnotherValue\" } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 40,
    "raw_source": "def test_hash_with_strip_filter\n    assert_template_result(\"{\\\"Key\\\"=>\\\"Value\\\", \\\"AnotherKey\\\"=>\\\"AnotherValue\\\"}\", \"{{ my_hash | strip }}\", { \"my_hash\" => { \"Key\" => \"Value\", \"AnotherKey\" => \"AnotherValue\" } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 44,
    "raw_source": "def test_hash_with_escape_filter\n    assert_template_result(\"{&quot;Key&quot;=&gt;&quot;Value&quot;, &quot;AnotherKey&quot;=&gt;&quot;AnotherValue&quot;}\", \"{{ my_hash | escape }}\", { \"my_hash\" => { \"Key\" => \"Value\", \"AnotherKey\" => \"AnotherValue\" } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 48,
    "raw_source": "def test_hash_with_url_encode_filter\n    assert_template_result(\"%7B%22Key%22%3D%3E%22Value%22%2C+%22AnotherKey%22%3D%3E%22AnotherValue%22%7D\", \"{{ my_hash | url_encode }}\", { \"my_hash\" => { \"Key\" => \"Value\", \"AnotherKey\" => \"AnotherValue\" } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 52,
    "raw_source": "def test_hash_with_strip_html_filter\n    assert_template_result(\"{\\\"Key\\\"=>\\\"Value\\\", \\\"AnotherKey\\\"=>\\\"AnotherValue\\\"}\", \"{{ my_hash | strip_html }}\", { \"my_hash\" => { \"Key\" => \"Value\", \"AnotherKey\" => \"AnotherValue\" } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 56,
    "raw_source": "def test_hash_with_truncate__20_filter\n    assert_template_result(\"{\\\"Key\\\"=>\\\"Value\\\", ...\", \"{{ my_hash | truncate: 20 }}\", { \"my_hash\" => { \"Key\" => \"Value\", \"AnotherKey\" => \"AnotherValue\" } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 60,
    "raw_source": "def test_hash_with_replace___key____replaced_key__filter\n    assert_template_result(\"{\\\"Key\\\"=>\\\"Value\\\", \\\"AnotherKey\\\"=>\\\"AnotherValue\\\"}\", \"{{ my_hash | replace: 'key', 'replaced_key' }}\", { \"my_hash\" => { \"Key\" => \"Value\", \"AnotherKey\" => \"AnotherValue\" } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 64,
    "raw_source": "def test_hash_with_append____appended_text__filter\n    assert_template_result(\"{\\\"Key\\\"=>\\\"Value\\\", \\\"AnotherKey\\\"=>\\\"AnotherValue\\\"} appended text\", \"{{ my_hash | append: ' appended text' }}\", { \"my_hash\" => { \"Key\" => \"Value\", \"AnotherKey\" => \"AnotherValue\" } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 68,
    "raw_source": "def test_hash_with_prepend___prepended_text___filter\n    assert_template_result(\"prepended text {\\\"Key\\\"=>\\\"Value\\\", \\\"AnotherKey\\\"=>\\\"AnotherValue\\\"}\", \"{{ my_hash | prepend: 'prepended text ' }}\", { \"my_hash\" => { \"Key\" => \"Value\", \"AnotherKey\" => \"AnotherValue\" } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 72,
    "raw_source": "def test_render_hash_with_array_values_empty\n    assert_template_result(\"{\\\"numbers\\\"=>[]}\", \"{{ my_hash }}\", { \"my_hash\" => { \"numbers\" => [] } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 76,
    "raw_source": "def test_render_hash_with_array_values_hash\n    assert_template_result(\"{\\\"numbers\\\"=>[{:foo=>42}]}\", \"{{ my_hash }}\", { \"my_hash\" => { \"numbers\" => [{ foo: 42 }] } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 80,
    "raw_source": "def test_join_filter_with_hash\n    array = [{ \"key1\" => \"value1\" }, { \"key2\" => \"value2\" }]\n    glue = { \"lol\" => \"wut\" }\n    assert_template_result(\"{\\\"key1\\\"=>\\\"value1\\\"}{\\\"lol\\\"=>\\\"wut\\\"}{\\\"key2\\\"=>\\\"value2\\\"}\", \"{{ my_array | join: glue }}\", { \"my_array\" => array, \"glue\" => glue })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 86,
    "raw_source": "def test_render_hash_with_hash_key\n    assert_template_result(\"{{\\\"foo\\\"=>\\\"bar\\\"}=>42}\", \"{{ my_hash }}\", { \"my_hash\" => { Hash[\"foo\" => \"bar\"] => 42 } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 90,
    "raw_source": "def test_rendering_hash_with_custom_to_s_method_uses_custom_to_s\n    my_hash = Class.new(Hash) do\n      def to_s\n        \"kewl\"\n      end\n    end.new\n\n    assert_template_result(\"kewl\", \"{{ my_hash }}\", { \"my_hash\" => my_hash })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 92,
    "raw_source": "def to_s\n        \"kewl\"\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/hash_rendering_test.rb",
    "start_line": 100,
    "raw_source": "def test_rendering_hash_without_custom_to_s_uses_default_inspect\n    my_hash = Class.new(Hash).new\n    my_hash[:foo] = :bar\n\n    assert_template_result(\"{:foo=>:bar}\", \"{{ my_hash }}\", { \"my_hash\" => my_hash })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 6,
    "raw_source": "def make_funny(_input)\n    'LOL'\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 10,
    "raw_source": "def cite_funny(input)\n    \"LOL: #{input}\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 14,
    "raw_source": "def add_smiley(input, smiley = \":-)\")\n    \"#{input} #{smiley}\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 18,
    "raw_source": "def add_tag(input, tag = \"p\", id = \"foo\")\n    %(<#{tag} id=\"#{id}\">#{input}</#{tag}>)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 22,
    "raw_source": "def paragraph(input)\n    \"<p>#{input}</p>\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 26,
    "raw_source": "def link_to(name, url)\n    %(<a href=\"#{url}\">#{name}</a>)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 34,
    "raw_source": "def setup\n    @assigns = {\n      'car' => { 'bmw' => 'good', 'gm' => 'bad' },\n    }\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 40,
    "raw_source": "def test_variable\n    assert_template_result(\" bmw \", \" {{best_cars}} \", { \"best_cars\" => \"bmw\" })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 44,
    "raw_source": "def test_variable_traversing_with_two_brackets\n    source = \"{{ site.data.menu[include.menu][include.locale] }}\"\n    assert_template_result(\"it works!\", source, {\n      \"site\" => { \"data\" => { \"menu\" => { \"foo\" => { \"bar\" => \"it works!\" } } } },\n      \"include\" => { \"menu\" => \"foo\", \"locale\" => \"bar\" },\n    })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 52,
    "raw_source": "def test_variable_traversing\n    source = \" {{car.bmw}} {{car.gm}} {{car.bmw}} \"\n    assert_template_result(\" good bad good \", source, @assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 57,
    "raw_source": "def test_variable_piping\n    text     = %( {{ car.gm | make_funny }} )\n    expected = %( LOL )\n\n    assert_equal(expected, Template.parse(text).render!(@assigns, filters: [FunnyFilter]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 64,
    "raw_source": "def test_variable_piping_with_input\n    text     = %( {{ car.gm | cite_funny }} )\n    expected = %( LOL: bad )\n\n    assert_equal(expected, Template.parse(text).render!(@assigns, filters: [FunnyFilter]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 71,
    "raw_source": "def test_variable_piping_with_args\n    text     = %! {{ car.gm | add_smiley : ':-(' }} !\n    expected = %| bad :-( |\n\n    assert_equal(expected, Template.parse(text).render!(@assigns, filters: [FunnyFilter]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 78,
    "raw_source": "def test_variable_piping_with_no_args\n    text     = %( {{ car.gm | add_smiley }} )\n    expected = %| bad :-) |\n\n    assert_equal(expected, Template.parse(text).render!(@assigns, filters: [FunnyFilter]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 85,
    "raw_source": "def test_multiple_variable_piping_with_args\n    text     = %! {{ car.gm | add_smiley : ':-(' | add_smiley : ':-('}} !\n    expected = %| bad :-( :-( |\n\n    assert_equal(expected, Template.parse(text).render!(@assigns, filters: [FunnyFilter]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 92,
    "raw_source": "def test_variable_piping_with_multiple_args\n    text     = %( {{ car.gm | add_tag : 'span', 'bar'}} )\n    expected = %( <span id=\"bar\">bad</span> )\n\n    assert_equal(expected, Template.parse(text).render!(@assigns, filters: [FunnyFilter]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 99,
    "raw_source": "def test_variable_piping_with_variable_args\n    text     = %( {{ car.gm | add_tag : 'span', car.bmw}} )\n    expected = %( <span id=\"good\">bad</span> )\n\n    assert_equal(expected, Template.parse(text).render!(@assigns, filters: [FunnyFilter]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 106,
    "raw_source": "def test_multiple_pipings\n    assigns = { 'best_cars' => 'bmw' }\n    text     = %( {{ best_cars | cite_funny | paragraph }} )\n    expected = %( <p>LOL: bmw</p> )\n\n    assert_equal(expected, Template.parse(text).render!(assigns, filters: [FunnyFilter]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/output_test.rb",
    "start_line": 114,
    "raw_source": "def test_link_to\n    text     = %( {{ 'Typo' | link_to: 'http://typo.leetsoft.com' }} )\n    expected = %( <a href=\"http://typo.leetsoft.com\">Typo</a> )\n\n    assert_equal(expected, Template.parse(text).render!(@assigns, filters: [FunnyFilter]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 8,
    "raw_source": "def test_parsing_css\n    text = \" div { font-weight: bold; } \"\n    assert_equal(text, Template.parse(text).render!)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 13,
    "raw_source": "def test_raise_on_single_close_bracet\n    assert_raises(SyntaxError) do\n      Template.parse(\"text {{method} oh nos!\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 19,
    "raw_source": "def test_raise_on_label_and_no_close_bracets\n    assert_raises(SyntaxError) do\n      Template.parse(\"TEST {{ \")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 25,
    "raw_source": "def test_raise_on_label_and_no_close_bracets_percent\n    assert_raises(SyntaxError) do\n      Template.parse(\"TEST {% \")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 31,
    "raw_source": "def test_error_on_empty_filter\n    assert(Template.parse(\"{{test}}\"))\n\n    with_error_mode(:lax) do\n      assert(Template.parse(\"{{|test}}\"))\n    end\n\n    with_error_mode(:strict) do\n      assert_raises(SyntaxError) { Template.parse(\"{{|test}}\") }\n      assert_raises(SyntaxError) { Template.parse(\"{{test |a|b|}}\") }\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 44,
    "raw_source": "def test_meaningless_parens_error\n    with_error_mode(:strict) do\n      assert_raises(SyntaxError) do\n        markup = \"a == 'foo' or (b == 'bar' and c == 'baz') or false\"\n        Template.parse(\"{% if #{markup} %} YES {% endif %}\")\n      end\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 53,
    "raw_source": "def test_unexpected_characters_syntax_error\n    with_error_mode(:strict) do\n      assert_raises(SyntaxError) do\n        markup = \"true && false\"\n        Template.parse(\"{% if #{markup} %} YES {% endif %}\")\n      end\n      assert_raises(SyntaxError) do\n        markup = \"false || true\"\n        Template.parse(\"{% if #{markup} %} YES {% endif %}\")\n      end\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 66,
    "raw_source": "def test_no_error_on_lax_empty_filter\n    assert(Template.parse(\"{{test |a|b|}}\", error_mode: :lax))\n    assert(Template.parse(\"{{test}}\", error_mode: :lax))\n    assert(Template.parse(\"{{|test|}}\", error_mode: :lax))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 72,
    "raw_source": "def test_meaningless_parens_lax\n    with_error_mode(:lax) do\n      assigns = { 'b' => 'bar', 'c' => 'baz' }\n      markup  = \"a == 'foo' or (b == 'bar' and c == 'baz') or false\"\n      assert_template_result(' YES ', \"{% if #{markup} %} YES {% endif %}\", assigns)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 80,
    "raw_source": "def test_unexpected_characters_silently_eat_logic_lax\n    with_error_mode(:lax) do\n      markup = \"true && false\"\n      assert_template_result(' YES ', \"{% if #{markup} %} YES {% endif %}\")\n      markup = \"false || true\"\n      assert_template_result('', \"{% if #{markup} %} YES {% endif %}\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 89,
    "raw_source": "def test_raise_on_invalid_tag_delimiter\n    assert_raises(Liquid::SyntaxError) do\n      Template.new.parse('{% end %}')\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 95,
    "raw_source": "def test_unanchored_filter_arguments\n    with_error_mode(:lax) do\n      assert_template_result('hi', \"{{ 'hi there' | split$$$:' ' | first }}\")\n\n      assert_template_result('x', \"{{ 'X' | downcase) }}\")\n\n      # After the messed up quotes a filter without parameters (reverse) should work\n      # but one with parameters (remove) shouldn't be detected.\n      assert_template_result('here',  \"{{ 'hi there' | split:\\\"t\\\"\\\" | reverse | first}}\")\n      assert_template_result('hi ', \"{{ 'hi there' | split:\\\"t\\\"\\\" | remove:\\\"i\\\" | first}}\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 108,
    "raw_source": "def test_invalid_variables_work\n    with_error_mode(:lax) do\n      assert_template_result('bar', \"{% assign 123foo = 'bar' %}{{ 123foo }}\")\n      assert_template_result('123', \"{% assign 123 = 'bar' %}{{ 123 }}\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 115,
    "raw_source": "def test_extra_dots_in_ranges\n    with_error_mode(:lax) do\n      assert_template_result('12345', \"{% for i in (1...5) %}{{ i }}{% endfor %}\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 121,
    "raw_source": "def test_blank_variable_markup\n    assert_template_result('', \"{{}}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 125,
    "raw_source": "def test_lookup_on_var_with_literal_name\n    assigns = { \"blank\" => { \"x\" => \"result\" } }\n    assert_template_result('result', \"{{ blank.x }}\", assigns)\n    assert_template_result('result', \"{{ blank['x'] }}\", assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 131,
    "raw_source": "def test_contains_in_id\n    assert_template_result(' YES ', '{% if containsallshipments == true %} YES {% endif %}', { 'containsallshipments' => true })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/parsing_quirks_test.rb",
    "start_line": 135,
    "raw_source": "def test_incomplete_expression\n    with_error_mode(:lax) do\n      assert_template_result(\"false\", \"{{ false - }}\")\n      assert_template_result(\"false\", \"{{ false > }}\")\n      assert_template_result(\"false\", \"{{ false < }}\")\n      assert_template_result(\"false\", \"{{ false = }}\")\n      assert_template_result(\"false\", \"{{ false ! }}\")\n      assert_template_result(\"false\", \"{{ false 1 }}\")\n      assert_template_result(\"false\", \"{{ false a }}\")\n\n      assert_template_result(\"false\", \"{% liquid assign foo = false -\\n%}{{ foo }}\")\n      assert_template_result(\"false\", \"{% liquid assign foo = false >\\n%}{{ foo }}\")\n      assert_template_result(\"false\", \"{% liquid assign foo = false <\\n%}{{ foo }}\")\n      assert_template_result(\"false\", \"{% liquid assign foo = false =\\n%}{{ foo }}\")\n      assert_template_result(\"false\", \"{% liquid assign foo = false !\\n%}{{ foo }}\")\n      assert_template_result(\"false\", \"{% liquid assign foo = false 1\\n%}{{ foo }}\")\n      assert_template_result(\"false\", \"{% liquid assign foo = false a\\n%}{{ foo }}\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 7,
    "raw_source": "def initialize(value)\n      super()\n      @value = value\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 12,
    "raw_source": "def to_s\n      artificial_execution_time\n\n      @value\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 22,
    "raw_source": "def artificial_execution_time\n      sleep(Process.clock_getres(Process::CLOCK_MONOTONIC))\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 30,
    "raw_source": "def read_template_file(template_path)\n      \"Rendering template {% assign template_name = '#{template_path}'%}\\n{{ template_name }}\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 35,
    "raw_source": "def setup\n    Liquid::Environment.default.file_system = ProfilingFileSystem.new\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 39,
    "raw_source": "def test_template_allows_flagging_profiling\n    t = Template.parse(\"{{ 'a string' | upcase }}\")\n    t.render!\n\n    assert_nil(t.profiler)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 46,
    "raw_source": "def test_parse_makes_available_simple_profiling\n    t = Template.parse(\"{{ 'a string' | upcase }}\", profile: true)\n    t.render!\n\n    assert_equal(1, t.profiler.length)\n\n    node = t.profiler[0]\n    assert_equal(\" 'a string' | upcase \", node.code)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 56,
    "raw_source": "def test_render_ignores_raw_strings_when_profiling\n    t = Template.parse(\"This is raw string\\nstuff\\nNewline\", profile: true)\n    t.render!\n\n    assert_equal(0, t.profiler.length)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 63,
    "raw_source": "def test_profiling_includes_line_numbers_of_liquid_nodes\n    t = Template.parse(\"{{ 'a string' | upcase }}\\n{% increment test %}\", profile: true)\n    t.render!\n    assert_equal(2, t.profiler.length)\n\n    # {{ 'a string' | upcase }}\n    assert_equal(1, t.profiler[0].line_number)\n    # {{ increment test }}\n    assert_equal(2, t.profiler[1].line_number)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 74,
    "raw_source": "def test_profiling_includes_line_numbers_of_included_partials\n    t = Template.parse(\"{% include 'a_template' %}\", profile: true)\n    t.render!\n\n    included_children = t.profiler[0].children\n\n    # {% assign template_name = 'a_template' %}\n    assert_equal(1, included_children[0].line_number)\n    # {{ template_name }}\n    assert_equal(2, included_children[1].line_number)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 86,
    "raw_source": "def test_profiling_render_tag\n    t = Template.parse(\"{% render 'a_template' %}\", profile: true)\n    t.render!\n\n    render_children = t.profiler[0].children\n    render_children.each do |timing|\n      assert_equal('a_template', timing.partial)\n    end\n    assert_equal([1, 2], render_children.map(&:line_number))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 97,
    "raw_source": "def test_profiling_times_the_rendering_of_tokens\n    t = Template.parse(\"{% include 'a_template' %}\", profile: true)\n    t.render!\n\n    node = t.profiler[0]\n    refute_nil(node.render_time)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 105,
    "raw_source": "def test_profiling_times_the_entire_render\n    t = Template.parse(\"{% include 'a_template' %}\", profile: true)\n    t.render!\n\n    assert(t.profiler.total_render_time >= 0, \"Total render time was not calculated\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 113,
    "raw_source": "def initialize(tag_name, markup, parse_context)\n      super\n      @duration = Float(markup)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 118,
    "raw_source": "def render_to_output_buffer(_context, _output)\n      sleep(@duration)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 123,
    "raw_source": "def test_profiling_multiple_renders\n    with_custom_tag('sleep', SleepTag) do\n      context = Liquid::Context.new\n      t = Liquid::Template.parse(\"{% sleep 0.001 %}\", profile: true)\n      context.template_name = 'index'\n      t.render!(context)\n      context.template_name = 'layout'\n      first_render_time = context.profiler.total_time\n      t.render!(context)\n\n      profiler = context.profiler\n      children = profiler.children\n      assert_operator(first_render_time, :>=, 0.001)\n      assert_operator(profiler.total_time, :>=, 0.001 + first_render_time)\n      assert_equal([\"index\", \"layout\"], children.map(&:template_name))\n      assert_equal([nil, nil], children.map(&:code))\n      assert_equal(profiler.total_time, children.map(&:total_time).reduce(&:+))\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 143,
    "raw_source": "def test_profiling_uses_include_to_mark_children\n    t = Template.parse(\"{{ 'a string' | upcase }}\\n{% include 'a_template' %}\", profile: true)\n    t.render!\n\n    include_node = t.profiler[1]\n    assert_equal(2, include_node.children.length)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 151,
    "raw_source": "def test_profiling_marks_children_with_the_name_of_included_partial\n    t = Template.parse(\"{{ 'a string' | upcase }}\\n{% include 'a_template' %}\", profile: true)\n    t.render!\n\n    include_node = t.profiler[1]\n    include_node.children.each do |child|\n      assert_equal(\"a_template\", child.partial)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 161,
    "raw_source": "def test_profiling_supports_multiple_templates\n    t = Template.parse(\"{{ 'a string' | upcase }}\\n{% include 'a_template' %}\\n{% include 'b_template' %}\", profile: true)\n    t.render!\n\n    a_template = t.profiler[1]\n    a_template.children.each do |child|\n      assert_equal(\"a_template\", child.partial)\n    end\n\n    b_template = t.profiler[2]\n    b_template.children.each do |child|\n      assert_equal(\"b_template\", child.partial)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 176,
    "raw_source": "def test_profiling_supports_rendering_the_same_partial_multiple_times\n    t = Template.parse(\"{{ 'a string' | upcase }}\\n{% include 'a_template' %}\\n{% include 'a_template' %}\", profile: true)\n    t.render!\n\n    a_template1 = t.profiler[1]\n    a_template1.children.each do |child|\n      assert_equal(\"a_template\", child.partial)\n    end\n\n    a_template2 = t.profiler[2]\n    a_template2.children.each do |child|\n      assert_equal(\"a_template\", child.partial)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 191,
    "raw_source": "def test_can_iterate_over_each_profiling_entry\n    t = Template.parse(\"{{ 'a string' | upcase }}\\n{% increment test %}\", profile: true)\n    t.render!\n\n    timing_count = 0\n    t.profiler.each do |_timing|\n      timing_count += 1\n    end\n\n    assert_equal(2, timing_count)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 203,
    "raw_source": "def test_profiling_marks_children_of_if_blocks\n    t = Template.parse(\"{% if true %} {% increment test %} {{ test }} {% endif %}\", profile: true)\n    t.render!\n\n    assert_equal(1, t.profiler.length)\n    assert_equal(2, t.profiler[0].children.length)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 211,
    "raw_source": "def test_profiling_marks_children_of_for_blocks\n    t = Template.parse(\"{% for item in collection %} {{ item }} {% endfor %}\", profile: true)\n    t.render!(\"collection\" => [\"one\", \"two\"])\n\n    assert_equal(1, t.profiler.length)\n    # Will profile each invocation of the for block\n    assert_equal(2, t.profiler[0].children.length)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 220,
    "raw_source": "def test_profiling_supports_self_time\n    t = Template.parse(\"{% for item in collection %} {{ item }} {% endfor %}\", profile: true)\n    collection = [\n      TestDrop.new(\"one\"),\n      TestDrop.new(\"two\"),\n    ]\n    output = t.render!(\"collection\" => collection)\n    assert_equal(\" one  two \", output)\n\n    leaf = t.profiler[0].children[0]\n    assert_operator(leaf.self_time, :>, 0.0)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/profiler_test.rb",
    "start_line": 233,
    "raw_source": "def test_profiling_supports_total_time\n    t = Template.parse(\"{% if true %} {{ test }} {% endif %}\", profile: true)\n    output = t.render!(\"test\" => TestDrop.new(\"one\"))\n    assert_equal(\" one \", output)\n\n    assert_operator(t.profiler[0].total_time, :>, 0.0)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/security_test.rb",
    "start_line": 6,
    "raw_source": "def add_one(input)\n    \"#{input} + 1\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/security_test.rb",
    "start_line": 14,
    "raw_source": "def setup\n    @assigns = {}\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/security_test.rb",
    "start_line": 18,
    "raw_source": "def test_no_instance_eval\n    text     = %( {{ '1+1' | instance_eval }} )\n    expected = %( 1+1 )\n\n    assert_equal(expected, Template.parse(text).render!(@assigns))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/security_test.rb",
    "start_line": 25,
    "raw_source": "def test_no_existing_instance_eval\n    text     = %( {{ '1+1' | __instance_eval__ }} )\n    expected = %( 1+1 )\n\n    assert_equal(expected, Template.parse(text).render!(@assigns))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/security_test.rb",
    "start_line": 32,
    "raw_source": "def test_no_instance_eval_after_mixing_in_new_filter\n    text     = %( {{ '1+1' | instance_eval }} )\n    expected = %( 1+1 )\n\n    assert_equal(expected, Template.parse(text).render!(@assigns))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/security_test.rb",
    "start_line": 39,
    "raw_source": "def test_no_instance_eval_later_in_chain\n    text     = %( {{ '1+1' | add_one | instance_eval }} )\n    expected = %( 1+1 + 1 )\n\n    assert_equal(expected, Template.parse(text).render!(@assigns, filters: SecurityFilter))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/security_test.rb",
    "start_line": 46,
    "raw_source": "def test_does_not_permanently_add_filters_to_symbol_table\n    current_symbols = Symbol.all_symbols\n\n    # MRI imprecisely marks objects found on the C stack, which can result\n    # in uninitialized memory being marked. This can even result in the test failing\n    # deterministically for a given compilation of ruby. Using a separate thread will\n    # keep these writes of the symbol pointer on a separate stack that will be garbage\n    # collected after Thread#join.\n    Thread.new do\n      test = %( {{ \"some_string\" | a_bad_filter }} )\n      Template.parse(test).render!\n      nil\n    end.join\n\n    GC.start\n\n    assert_equal([], (Symbol.all_symbols - current_symbols))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/security_test.rb",
    "start_line": 65,
    "raw_source": "def test_does_not_add_drop_methods_to_symbol_table\n    current_symbols = Symbol.all_symbols\n\n    assigns = { 'drop' => Drop.new }\n    assert_equal(\"\", Template.parse(\"{{ drop.custom_method_1 }}\", assigns).render!)\n    assert_equal(\"\", Template.parse(\"{{ drop.custom_method_2 }}\", assigns).render!)\n    assert_equal(\"\", Template.parse(\"{{ drop.custom_method_3 }}\", assigns).render!)\n\n    assert_equal([], (Symbol.all_symbols - current_symbols))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/security_test.rb",
    "start_line": 76,
    "raw_source": "def test_max_depth_nested_blocks_does_not_raise_exception\n    depth = Liquid::Block::MAX_DEPTH\n    code  = \"{% if true %}\" * depth + \"rendered\" + \"{% endif %}\" * depth\n    assert_equal(\"rendered\", Template.parse(code).render!)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/security_test.rb",
    "start_line": 82,
    "raw_source": "def test_more_than_max_depth_nested_blocks_raises_exception\n    depth = Liquid::Block::MAX_DEPTH + 1\n    code  = \"{% if true %}\" * depth + \"rendered\" + \"{% endif %}\" * depth\n    assert_raises(Liquid::StackLevelError) do\n      Template.parse(code).render!\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 9,
    "raw_source": "def initialize\n    @foo = 0\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 13,
    "raw_source": "def to_s\n    \"woot: #{@foo}\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 17,
    "raw_source": "def [](_whatever)\n    to_s\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 21,
    "raw_source": "def to_liquid\n    @foo += 1\n    self\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 28,
    "raw_source": "def initialize(value:)\n    @value = value\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 34,
    "raw_source": "def registers\n    \"{#{@value.inspect}=>#{@context.registers[@value].inspect}}\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 40,
    "raw_source": "def initialize(value:)\n    @value = value\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 44,
    "raw_source": "def to_liquid\n    TestDrop.new(value: @value)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 52,
    "raw_source": "def each(&block)\n    [{ \"foo\" => 1, \"bar\" => 2 }, { \"foo\" => 2, \"bar\" => 1 }, { \"foo\" => 3, \"bar\" => 3 }].each(&block)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 58,
    "raw_source": "def initialize(amount)\n    @amount = amount\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 62,
    "raw_source": "def to_number\n    @amount\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 73,
    "raw_source": "def setup\n    @filters = Filters.new(Context.new)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 77,
    "raw_source": "def test_size\n    assert_equal(3, @filters.size([1, 2, 3]))\n    assert_equal(0, @filters.size([]))\n    assert_equal(0, @filters.size(nil))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 83,
    "raw_source": "def test_downcase\n    assert_equal('testing', @filters.downcase(\"Testing\"))\n    assert_equal('', @filters.downcase(nil))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 88,
    "raw_source": "def test_upcase\n    assert_equal('TESTING', @filters.upcase(\"Testing\"))\n    assert_equal('', @filters.upcase(nil))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 93,
    "raw_source": "def test_slice\n    assert_equal('oob', @filters.slice('foobar', 1, 3))\n    assert_equal('oobar', @filters.slice('foobar', 1, 1000))\n    assert_equal('', @filters.slice('foobar', 1, 0))\n    assert_equal('o', @filters.slice('foobar', 1, 1))\n    assert_equal('bar', @filters.slice('foobar', 3, 3))\n    assert_equal('ar', @filters.slice('foobar', -2, 2))\n    assert_equal('ar', @filters.slice('foobar', -2, 1000))\n    assert_equal('r', @filters.slice('foobar', -1))\n    assert_equal('', @filters.slice(nil, 0))\n    assert_equal('', @filters.slice('foobar', 100, 10))\n    assert_equal('', @filters.slice('foobar', -100, 10))\n    assert_equal('oob', @filters.slice('foobar', '1', '3'))\n    assert_raises(Liquid::ArgumentError) do\n      @filters.slice('foobar', nil)\n    end\n    assert_raises(Liquid::ArgumentError) do\n      @filters.slice('foobar', 0, \"\")\n    end\n    assert_equal(\"\", @filters.slice(\"foobar\", 0, -(1 << 64)))\n    assert_equal(\"foobar\", @filters.slice(\"foobar\", 0, 1 << 63))\n    assert_equal(\"\", @filters.slice(\"foobar\", 1 << 63, 6))\n    assert_equal(\"\", @filters.slice(\"foobar\", -(1 << 63), 6))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 118,
    "raw_source": "def test_slice_on_arrays\n    input = 'foobar'.split(//)\n    assert_equal(%w(o o b), @filters.slice(input, 1, 3))\n    assert_equal(%w(o o b a r), @filters.slice(input, 1, 1000))\n    assert_equal(%w(), @filters.slice(input, 1, 0))\n    assert_equal(%w(o), @filters.slice(input, 1, 1))\n    assert_equal(%w(b a r), @filters.slice(input, 3, 3))\n    assert_equal(%w(a r), @filters.slice(input, -2, 2))\n    assert_equal(%w(a r), @filters.slice(input, -2, 1000))\n    assert_equal(%w(r), @filters.slice(input, -1))\n    assert_equal(%w(), @filters.slice(input, 100, 10))\n    assert_equal(%w(), @filters.slice(input, -100, 10))\n    assert_equal([], @filters.slice(input, 0, -(1 << 64)))\n    assert_equal(input, @filters.slice(input, 0, 1 << 63))\n    assert_equal([], @filters.slice(input, 1 << 63, 6))\n    assert_equal([], @filters.slice(input, -(1 << 63), 6))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 136,
    "raw_source": "def test_find_on_empty_array\n    assert_nil(@filters.find([], 'foo', 'bar'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 140,
    "raw_source": "def test_find_index_on_empty_array\n    assert_nil(@filters.find_index([], 'foo', 'bar'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 144,
    "raw_source": "def test_has_on_empty_array\n    refute(@filters.has([], 'foo', 'bar'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 148,
    "raw_source": "def test_truncate\n    assert_equal('1234...', @filters.truncate('1234567890', 7))\n    assert_equal('1234567890', @filters.truncate('1234567890', 20))\n    assert_equal('...', @filters.truncate('1234567890', 0))\n    assert_equal('1234567890', @filters.truncate('1234567890'))\n    assert_equal(\"测试...\", @filters.truncate(\"测试测试测试测试\", 5))\n    assert_equal('12341', @filters.truncate(\"1234567890\", 5, 1))\n    assert_equal(\"foobar\", @filters.truncate(\"foobar\", 1 << 63))\n    assert_equal(\"...\", @filters.truncate(\"foobar\", -(1 << 63)))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 159,
    "raw_source": "def test_split\n    assert_equal(['12', '34'], @filters.split('12~34', '~'))\n    assert_equal(['A? ', ' ,Z'], @filters.split('A? ~ ~ ~ ,Z', '~ ~ ~'))\n    assert_equal(['A?Z'], @filters.split('A?Z', '~'))\n    assert_equal([], @filters.split(nil, ' '))\n    assert_equal(['A', 'Z'], @filters.split('A1Z', 1))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 167,
    "raw_source": "def test_escape\n    assert_equal('&lt;strong&gt;', @filters.escape('<strong>'))\n    assert_equal('1', @filters.escape(1))\n    assert_equal('2001-02-03', @filters.escape(Date.new(2001, 2, 3)))\n    assert_nil(@filters.escape(nil))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 174,
    "raw_source": "def test_h\n    assert_equal('&lt;strong&gt;', @filters.h('<strong>'))\n    assert_equal('1', @filters.h(1))\n    assert_equal('2001-02-03', @filters.h(Date.new(2001, 2, 3)))\n    assert_nil(@filters.h(nil))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 181,
    "raw_source": "def test_escape_once\n    assert_equal('&lt;strong&gt;Hulk&lt;/strong&gt;', @filters.escape_once('&lt;strong&gt;Hulk</strong>'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 185,
    "raw_source": "def test_base64_encode\n    assert_equal('b25lIHR3byB0aHJlZQ==', @filters.base64_encode('one two three'))\n    assert_equal('', @filters.base64_encode(nil))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 190,
    "raw_source": "def test_base64_decode\n    decoded = @filters.base64_decode('b25lIHR3byB0aHJlZQ==')\n    assert_equal('one two three', decoded)\n    assert_equal(Encoding::UTF_8, decoded.encoding)\n\n    decoded = @filters.base64_decode('4pyF')\n    assert_equal('✅', decoded)\n    assert_equal(Encoding::UTF_8, decoded.encoding)\n\n    decoded = @filters.base64_decode(\"/w==\")\n    assert_equal(Encoding::ASCII_8BIT, decoded.encoding)\n    assert_equal((+\"\\xFF\").force_encoding(Encoding::ASCII_8BIT), decoded)\n\n    exception = assert_raises(Liquid::ArgumentError) do\n      @filters.base64_decode(\"invalidbase64\")\n    end\n\n    assert_equal('Liquid error: invalid base64 provided to base64_decode', exception.message)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 210,
    "raw_source": "def test_base64_url_safe_encode\n    assert_equal(\n      'YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogMTIzNDU2Nzg5MCAhQCMkJV4mKigpLT1fKy8_Ljo7W117fVx8',\n      @filters.base64_url_safe_encode('abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890 !@#$%^&*()-=_+/?.:;[]{}\\|'),\n    )\n    assert_equal('', @filters.base64_url_safe_encode(nil))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 218,
    "raw_source": "def test_base64_url_safe_decode\n    decoded = @filters.base64_url_safe_decode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogMTIzNDU2Nzg5MCAhQCMkJV4mKigpLT1fKy8_Ljo7W117fVx8')\n    assert_equal(\n      'abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890 !@#$%^&*()-=_+/?.:;[]{}\\|',\n      decoded,\n    )\n    assert_equal(Encoding::UTF_8, decoded.encoding)\n\n    decoded = @filters.base64_url_safe_decode('4pyF')\n    assert_equal('✅', decoded)\n    assert_equal(Encoding::UTF_8, decoded.encoding)\n\n    decoded = @filters.base64_url_safe_decode(\"_w==\")\n    assert_equal(Encoding::ASCII_8BIT, decoded.encoding)\n    assert_equal((+\"\\xFF\").force_encoding(Encoding::ASCII_8BIT), decoded)\n\n    exception = assert_raises(Liquid::ArgumentError) do\n      @filters.base64_url_safe_decode(\"invalidbase64\")\n    end\n    assert_equal('Liquid error: invalid base64 provided to base64_url_safe_decode', exception.message)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 240,
    "raw_source": "def test_url_encode\n    assert_equal('foo%2B1%40example.com', @filters.url_encode('foo+1@example.com'))\n    assert_equal('1', @filters.url_encode(1))\n    assert_equal('2001-02-03', @filters.url_encode(Date.new(2001, 2, 3)))\n    assert_nil(@filters.url_encode(nil))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 247,
    "raw_source": "def test_url_decode\n    assert_equal('foo bar', @filters.url_decode('foo+bar'))\n    assert_equal('foo bar', @filters.url_decode('foo%20bar'))\n    assert_equal('foo+1@example.com', @filters.url_decode('foo%2B1%40example.com'))\n    assert_equal('1', @filters.url_decode(1))\n    assert_equal('2001-02-03', @filters.url_decode(Date.new(2001, 2, 3)))\n    assert_nil(@filters.url_decode(nil))\n    exception = assert_raises(Liquid::ArgumentError) do\n      @filters.url_decode('%ff')\n    end\n    assert_equal('Liquid error: invalid byte sequence in UTF-8', exception.message)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 260,
    "raw_source": "def test_truncatewords\n    assert_equal('one two three', @filters.truncatewords('one two three', 4))\n    assert_equal('one two...', @filters.truncatewords('one two three', 2))\n    assert_equal('one two three', @filters.truncatewords('one two three'))\n    assert_equal(\n      'Two small (13&#8221; x 5.5&#8221; x 10&#8221; high) baskets fit inside one large basket (13&#8221;...',\n      @filters.truncatewords('Two small (13&#8221; x 5.5&#8221; x 10&#8221; high) baskets fit inside one large basket (13&#8221; x 16&#8221; x 10.5&#8221; high) with cover.', 15),\n    )\n    assert_equal(\"测试测试测试测试\", @filters.truncatewords('测试测试测试测试', 5))\n    assert_equal('one two1', @filters.truncatewords(\"one two three\", 2, 1))\n    assert_equal('one two three...', @filters.truncatewords(\"one  two\\tthree\\nfour\", 3))\n    assert_equal('one two...', @filters.truncatewords(\"one two three four\", 2))\n    assert_equal('one...', @filters.truncatewords(\"one two three four\", 0))\n    assert_equal('one two three four', @filters.truncatewords(\"one two three four\", 1 << 31))\n    assert_equal('one...', @filters.truncatewords(\"one two three four\", -(1 << 32)))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 277,
    "raw_source": "def test_strip_html\n    assert_equal('test', @filters.strip_html(\"<div>test</div>\"))\n    assert_equal('test', @filters.strip_html(\"<div id='test'>test</div>\"))\n    assert_equal('', @filters.strip_html(\"<script type='text/javascript'>document.write('some stuff');</script>\"))\n    assert_equal('', @filters.strip_html(\"<style type='text/css'>foo bar</style>\"))\n    assert_equal('test', @filters.strip_html(\"<div\\nclass='multiline'>test</div>\"))\n    assert_equal('test', @filters.strip_html(\"<!-- foo bar \\n test -->test\"))\n    assert_equal('', @filters.strip_html(nil))\n\n    # Quirk of the existing implementation\n    assert_equal('foo;', @filters.strip_html(\"<<<script </script>script>foo;</script>\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 290,
    "raw_source": "def test_join\n    assert_equal('1 2 3 4', @filters.join([1, 2, 3, 4]))\n    assert_equal('1 - 2 - 3 - 4', @filters.join([1, 2, 3, 4], ' - '))\n    assert_equal('1121314', @filters.join([1, 2, 3, 4], 1))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 296,
    "raw_source": "def test_join_calls_to_liquid_on_each_element\n    drop = Class.new(Liquid::Drop) do\n      def to_liquid\n        'i did it'\n      end\n    end\n\n    assert_equal('i did it, i did it', @filters.join([drop.new, drop.new], \", \"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 298,
    "raw_source": "def to_liquid\n        'i did it'\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 306,
    "raw_source": "def test_sort\n    assert_equal([1, 2, 3, 4], @filters.sort([4, 3, 2, 1]))\n    assert_equal([{ \"a\" => 1 }, { \"a\" => 2 }, { \"a\" => 3 }, { \"a\" => 4 }], @filters.sort([{ \"a\" => 4 }, { \"a\" => 3 }, { \"a\" => 1 }, { \"a\" => 2 }], \"a\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 311,
    "raw_source": "def test_sort_with_nils\n    assert_equal([1, 2, 3, 4, nil], @filters.sort([nil, 4, 3, 2, 1]))\n    assert_equal([{ \"a\" => 1 }, { \"a\" => 2 }, { \"a\" => 3 }, { \"a\" => 4 }, {}], @filters.sort([{ \"a\" => 4 }, { \"a\" => 3 }, {}, { \"a\" => 1 }, { \"a\" => 2 }], \"a\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 316,
    "raw_source": "def test_sort_when_property_is_sometimes_missing_puts_nils_last\n    input       = [\n      { \"price\" => 4, \"handle\" => \"alpha\" },\n      { \"handle\" => \"beta\" },\n      { \"price\" => 1, \"handle\" => \"gamma\" },\n      { \"handle\" => \"delta\" },\n      { \"price\" => 2, \"handle\" => \"epsilon\" },\n    ]\n    expectation = [\n      { \"price\" => 1, \"handle\" => \"gamma\" },\n      { \"price\" => 2, \"handle\" => \"epsilon\" },\n      { \"price\" => 4, \"handle\" => \"alpha\" },\n      { \"handle\" => \"beta\" },\n      { \"handle\" => \"delta\" },\n    ]\n    assert_equal(expectation, @filters.sort(input, \"price\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 334,
    "raw_source": "def test_sort_natural\n    assert_equal([\"a\", \"B\", \"c\", \"D\"], @filters.sort_natural([\"c\", \"D\", \"a\", \"B\"]))\n    assert_equal([{ \"a\" => \"a\" }, { \"a\" => \"B\" }, { \"a\" => \"c\" }, { \"a\" => \"D\" }], @filters.sort_natural([{ \"a\" => \"D\" }, { \"a\" => \"c\" }, { \"a\" => \"a\" }, { \"a\" => \"B\" }], \"a\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 339,
    "raw_source": "def test_sort_natural_with_nils\n    assert_equal([\"a\", \"B\", \"c\", \"D\", nil], @filters.sort_natural([nil, \"c\", \"D\", \"a\", \"B\"]))\n    assert_equal([{ \"a\" => \"a\" }, { \"a\" => \"B\" }, { \"a\" => \"c\" }, { \"a\" => \"D\" }, {}], @filters.sort_natural([{ \"a\" => \"D\" }, { \"a\" => \"c\" }, {}, { \"a\" => \"a\" }, { \"a\" => \"B\" }], \"a\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 344,
    "raw_source": "def test_sort_natural_when_property_is_sometimes_missing_puts_nils_last\n    input       = [\n      { \"price\" => \"4\", \"handle\" => \"alpha\" },\n      { \"handle\" => \"beta\" },\n      { \"price\" => \"1\", \"handle\" => \"gamma\" },\n      { \"handle\" => \"delta\" },\n      { \"price\" => 2, \"handle\" => \"epsilon\" },\n    ]\n    expectation = [\n      { \"price\" => \"1\", \"handle\" => \"gamma\" },\n      { \"price\" => 2, \"handle\" => \"epsilon\" },\n      { \"price\" => \"4\", \"handle\" => \"alpha\" },\n      { \"handle\" => \"beta\" },\n      { \"handle\" => \"delta\" },\n    ]\n    assert_equal(expectation, @filters.sort_natural(input, \"price\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 362,
    "raw_source": "def test_sort_natural_case_check\n    input = [\n      { \"key\" => \"X\" },\n      { \"key\" => \"Y\" },\n      { \"key\" => \"Z\" },\n      { \"fake\" => \"t\" },\n      { \"key\" => \"a\" },\n      { \"key\" => \"b\" },\n      { \"key\" => \"c\" },\n    ]\n    expectation = [\n      { \"key\" => \"a\" },\n      { \"key\" => \"b\" },\n      { \"key\" => \"c\" },\n      { \"key\" => \"X\" },\n      { \"key\" => \"Y\" },\n      { \"key\" => \"Z\" },\n      { \"fake\" => \"t\" },\n    ]\n    assert_equal(expectation, @filters.sort_natural(input, \"key\"))\n    assert_equal([\"a\", \"b\", \"c\", \"X\", \"Y\", \"Z\"], @filters.sort_natural([\"X\", \"Y\", \"Z\", \"a\", \"b\", \"c\"]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 385,
    "raw_source": "def test_sort_empty_array\n    assert_equal([], @filters.sort([], \"a\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 389,
    "raw_source": "def test_sort_invalid_property\n    foo = [\n      [1],\n      [2],\n      [3],\n    ]\n\n    assert_raises(Liquid::ArgumentError) do\n      @filters.sort(foo, \"bar\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 401,
    "raw_source": "def test_sort_natural_empty_array\n    assert_equal([], @filters.sort_natural([], \"a\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 405,
    "raw_source": "def test_sort_natural_invalid_property\n    foo = [\n      [1],\n      [2],\n      [3],\n    ]\n\n    assert_raises(Liquid::ArgumentError) do\n      @filters.sort_natural(foo, \"bar\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 417,
    "raw_source": "def test_legacy_sort_hash\n    assert_equal([{ a: 1, b: 2 }], @filters.sort(a: 1, b: 2))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 421,
    "raw_source": "def test_numerical_vs_lexicographical_sort\n    assert_equal([2, 10], @filters.sort([10, 2]))\n    assert_equal([{ \"a\" => 2 }, { \"a\" => 10 }], @filters.sort([{ \"a\" => 10 }, { \"a\" => 2 }], \"a\"))\n    assert_equal([\"10\", \"2\"], @filters.sort([\"10\", \"2\"]))\n    assert_equal([{ \"a\" => \"10\" }, { \"a\" => \"2\" }], @filters.sort([{ \"a\" => \"10\" }, { \"a\" => \"2\" }], \"a\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 428,
    "raw_source": "def test_uniq\n    assert_equal([\"foo\"], @filters.uniq(\"foo\"))\n    assert_equal([1, 3, 2, 4], @filters.uniq([1, 1, 3, 2, 3, 1, 4, 3, 2, 1]))\n    assert_equal([{ \"a\" => 1 }, { \"a\" => 3 }, { \"a\" => 2 }], @filters.uniq([{ \"a\" => 1 }, { \"a\" => 3 }, { \"a\" => 1 }, { \"a\" => 2 }], \"a\"))\n    test_drop = TestDrop.new(value: \"test\")\n    test_drop_alternate = TestDrop.new(value: \"test\")\n    assert_equal([test_drop], @filters.uniq([test_drop, test_drop_alternate], 'value'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 437,
    "raw_source": "def test_uniq_empty_array\n    assert_equal([], @filters.uniq([], \"a\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 441,
    "raw_source": "def test_uniq_invalid_property\n    foo = [\n      [1],\n      [2],\n      [3],\n    ]\n\n    assert_raises(Liquid::ArgumentError) do\n      @filters.uniq(foo, \"bar\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 453,
    "raw_source": "def test_compact_empty_array\n    assert_equal([], @filters.compact([], \"a\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 457,
    "raw_source": "def test_compact_invalid_property\n    foo = [\n      [1],\n      [2],\n      [3],\n    ]\n\n    assert_raises(Liquid::ArgumentError) do\n      @filters.compact(foo, \"bar\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 469,
    "raw_source": "def test_reverse\n    assert_equal([4, 3, 2, 1], @filters.reverse([1, 2, 3, 4]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 473,
    "raw_source": "def test_legacy_reverse_hash\n    assert_equal([{ a: 1, b: 2 }], @filters.reverse(a: 1, b: 2))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 477,
    "raw_source": "def test_map\n    assert_equal([1, 2, 3, 4], @filters.map([{ \"a\" => 1 }, { \"a\" => 2 }, { \"a\" => 3 }, { \"a\" => 4 }], 'a'))\n    assert_template_result(\n      'abc',\n      \"{{ ary | map:'foo' | map:'bar' }}\",\n      { 'ary' => [{ 'foo' => { 'bar' => 'a' } }, { 'foo' => { 'bar' => 'b' } }, { 'foo' => { 'bar' => 'c' } }] },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 486,
    "raw_source": "def test_map_doesnt_call_arbitrary_stuff\n    assert_template_result(\"\", '{{ \"foo\" | map: \"__id__\" }}')\n    assert_template_result(\"\", '{{ \"foo\" | map: \"inspect\" }}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 491,
    "raw_source": "def test_map_calls_to_liquid\n    t = TestThing.new\n    assert_template_result(\"woot: 1\", '{{ foo | map: \"whatever\" }}', { \"foo\" => [t] })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 496,
    "raw_source": "def test_map_calls_context=\n    model = TestModel.new(value: :test)\n\n    template = Template.parse('{{ foo | map: \"registers\" }}')\n    template.registers[:test] = 1234\n    template.assigns['foo'] = [model]\n\n    assert_template_result(\"{:test=>1234}\", template.render!)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 506,
    "raw_source": "def test_map_on_hashes\n    assert_template_result(\n      \"4217\",\n      '{{ thing | map: \"foo\" | map: \"bar\" }}',\n      { \"thing\" => { \"foo\" => [{ \"bar\" => 42 }, { \"bar\" => 17 }] } },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 514,
    "raw_source": "def test_legacy_map_on_hashes_with_dynamic_key\n    template = \"{% assign key = 'foo' %}{{ thing | map: key | map: 'bar' }}\"\n    hash     = { \"foo\" => { \"bar\" => 42 } }\n    assert_template_result(\"42\", template, { \"thing\" => hash })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 520,
    "raw_source": "def test_sort_calls_to_liquid\n    t = TestThing.new\n    Liquid::Template.parse('{{ foo | sort: \"whatever\" }}').render(\"foo\" => [t])\n    assert(t.foo > 0)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 526,
    "raw_source": "def test_map_over_proc\n    drop  = TestDrop.new(value: \"testfoo\")\n    p     = proc { drop }\n    output = Liquid::Template.parse('{{ procs | map: \"value\" }}').render!({ \"procs\" => [p] })\n    assert_equal(\"testfoo\", output)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 533,
    "raw_source": "def test_map_over_drops_returning_procs\n    drops = [\n      {\n        \"proc\" => -> { \"foo\" },\n      },\n      {\n        \"proc\" => -> { \"bar\" },\n      },\n    ]\n    output = Liquid::Template.parse('{{ drops | map: \"proc\" }}').render!({ \"drops\" => drops })\n    assert_equal(\"foobar\", output)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 546,
    "raw_source": "def test_map_works_on_enumerables\n    output = Liquid::Template.parse('{{ foo | map: \"foo\" }}').render!({ \"foo\" => TestEnumerable.new })\n    assert_equal(\"123\", output)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 551,
    "raw_source": "def test_map_returns_empty_on_2d_input_array\n    foo = [\n      [1],\n      [2],\n      [3],\n    ]\n\n    assert_raises(Liquid::ArgumentError) do\n      @filters.map(foo, \"bar\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 563,
    "raw_source": "def test_map_with_value_property\n    array = [\n      { \"handle\" => \"alpha\", \"value\" => \"A\" },\n      { \"handle\" => \"beta\", \"value\" => \"B\" },\n      { \"handle\" => \"gamma\", \"value\" => \"C\" }\n    ]\n\n    assert_template_result(\"A B C\", \"{{ array | map: 'value' | join: ' ' }}\", { \"array\" => array })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 573,
    "raw_source": "def test_map_returns_input_with_no_property\n    foo = [\n      [1],\n      [2],\n      [3],\n    ]\n\n    assert_raises(Liquid::ArgumentError) do\n      @filters.map(foo, nil)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 585,
    "raw_source": "def test_sort_works_on_enumerables\n    assert_template_result(\"213\", '{{ foo | sort: \"bar\" | map: \"foo\" }}', { \"foo\" => TestEnumerable.new })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 589,
    "raw_source": "def test_first_and_last_call_to_liquid\n    assert_template_result('foobar', '{{ foo | first }}', { 'foo' => [ThingWithToLiquid.new] })\n    assert_template_result('foobar', '{{ foo | last }}', { 'foo' => [ThingWithToLiquid.new] })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 594,
    "raw_source": "def test_truncate_calls_to_liquid\n    assert_template_result(\"wo...\", '{{ foo | truncate: 5 }}', { \"foo\" => TestThing.new })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 598,
    "raw_source": "def test_date\n    assert_equal('May', @filters.date(Time.parse(\"2006-05-05 10:00:00\"), \"%B\"))\n    assert_equal('June', @filters.date(Time.parse(\"2006-06-05 10:00:00\"), \"%B\"))\n    assert_equal('July', @filters.date(Time.parse(\"2006-07-05 10:00:00\"), \"%B\"))\n\n    assert_equal('May', @filters.date(\"2006-05-05 10:00:00\", \"%B\"))\n    assert_equal('June', @filters.date(\"2006-06-05 10:00:00\", \"%B\"))\n    assert_equal('July', @filters.date(\"2006-07-05 10:00:00\", \"%B\"))\n\n    assert_equal('2006-07-05 10:00:00', @filters.date(\"2006-07-05 10:00:00\", \"\"))\n    assert_equal('2006-07-05 10:00:00', @filters.date(\"2006-07-05 10:00:00\", \"\"))\n    assert_equal('2006-07-05 10:00:00', @filters.date(\"2006-07-05 10:00:00\", \"\"))\n    assert_equal('2006-07-05 10:00:00', @filters.date(\"2006-07-05 10:00:00\", nil))\n\n    assert_equal('07/05/2006', @filters.date(\"2006-07-05 10:00:00\", \"%m/%d/%Y\"))\n\n    assert_equal(\"07/16/2004\", @filters.date(\"Fri Jul 16 01:00:00 2004\", \"%m/%d/%Y\"))\n    assert_equal(Date.today.year.to_s, @filters.date('now', '%Y'))\n    assert_equal(Date.today.year.to_s, @filters.date('today', '%Y'))\n    assert_equal(Date.today.year.to_s, @filters.date('Today', '%Y'))\n\n    assert_nil(@filters.date(nil, \"%B\"))\n\n    assert_equal('', @filters.date('', \"%B\"))\n\n    with_timezone(\"UTC\") do\n      assert_equal(\"07/05/2006\", @filters.date(1152098955, \"%m/%d/%Y\"))\n      assert_equal(\"07/05/2006\", @filters.date(\"1152098955\", \"%m/%d/%Y\"))\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 629,
    "raw_source": "def test_first_last\n    assert_equal(1, @filters.first([1, 2, 3]))\n    assert_equal(3, @filters.last([1, 2, 3]))\n    assert_nil(@filters.first([]))\n    assert_nil(@filters.last([]))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 636,
    "raw_source": "def test_replace\n    assert_equal('b b b b', @filters.replace('a a a a', 'a', 'b'))\n    assert_equal('2 2 2 2', @filters.replace('1 1 1 1', 1, 2))\n    assert_equal('1 1 1 1', @filters.replace('1 1 1 1', 2, 3))\n    assert_template_result('2 2 2 2', \"{{ '1 1 1 1' | replace: '1', 2 }}\")\n\n    assert_equal('b a a a', @filters.replace_first('a a a a', 'a', 'b'))\n    assert_equal('2 1 1 1', @filters.replace_first('1 1 1 1', 1, 2))\n    assert_equal('1 1 1 1', @filters.replace_first('1 1 1 1', 2, 3))\n    assert_template_result('2 1 1 1', \"{{ '1 1 1 1' | replace_first: '1', 2 }}\")\n\n    assert_equal('a a a b', @filters.replace_last('a a a a', 'a', 'b'))\n    assert_equal('1 1 1 2', @filters.replace_last('1 1 1 1', 1, 2))\n    assert_equal('1 1 1 1', @filters.replace_last('1 1 1 1', 2, 3))\n    assert_template_result('1 1 1 2', \"{{ '1 1 1 1' | replace_last: '1', 2 }}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 653,
    "raw_source": "def test_remove\n    assert_equal('   ', @filters.remove(\"a a a a\", 'a'))\n    assert_template_result('   ', \"{{ '1 1 1 1' | remove: 1 }}\")\n\n    assert_equal('b a a', @filters.remove_first(\"a b a a\", 'a '))\n    assert_template_result(' 1 1 1', \"{{ '1 1 1 1' | remove_first: 1 }}\")\n\n    assert_equal('a a b', @filters.remove_last(\"a a b a\", ' a'))\n    assert_template_result('1 1 1 ', \"{{ '1 1 1 1' | remove_last: 1 }}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 664,
    "raw_source": "def test_pipes_in_string_arguments\n    assert_template_result('foobar', \"{{ 'foo|bar' | remove: '|' }}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 668,
    "raw_source": "def test_strip\n    assert_template_result('ab c', \"{{ source | strip }}\", { 'source' => \" ab c  \" })\n    assert_template_result('ab c', \"{{ source | strip }}\", { 'source' => \" \\tab c  \\n \\t\" })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 673,
    "raw_source": "def test_lstrip\n    assert_template_result('ab c  ', \"{{ source | lstrip }}\", { 'source' => \" ab c  \" })\n    assert_template_result(\"ab c  \\n \\t\", \"{{ source | lstrip }}\", { 'source' => \" \\tab c  \\n \\t\" })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 678,
    "raw_source": "def test_rstrip\n    assert_template_result(\" ab c\", \"{{ source | rstrip }}\", { 'source' => \" ab c  \" })\n    assert_template_result(\" \\tab c\", \"{{ source | rstrip }}\", { 'source' => \" \\tab c  \\n \\t\" })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 683,
    "raw_source": "def test_strip_newlines\n    assert_template_result('abc', \"{{ source | strip_newlines }}\", { 'source' => \"a\\nb\\nc\" })\n    assert_template_result('abc', \"{{ source | strip_newlines }}\", { 'source' => \"a\\r\\nb\\nc\" })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 688,
    "raw_source": "def test_newlines_to_br\n    assert_template_result(\"a<br />\\nb<br />\\nc\", \"{{ source | newline_to_br }}\", { 'source' => \"a\\nb\\nc\" })\n    assert_template_result(\"a<br />\\nb<br />\\nc\", \"{{ source | newline_to_br }}\", { 'source' => \"a\\r\\nb\\nc\" })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 693,
    "raw_source": "def test_plus\n    assert_template_result(\"2\", \"{{ 1 | plus:1 }}\")\n    assert_template_result(\"2.0\", \"{{ '1' | plus:'1.0' }}\")\n\n    assert_template_result(\"5\", \"{{ price | plus:'2' }}\", { 'price' => NumberLikeThing.new(3) })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 700,
    "raw_source": "def test_minus\n    assert_template_result(\"4\", \"{{ input | minus:operand }}\", { 'input' => 5, 'operand' => 1 })\n    assert_template_result(\"2.3\", \"{{ '4.3' | minus:'2' }}\")\n\n    assert_template_result(\"5\", \"{{ price | minus:'2' }}\", { 'price' => NumberLikeThing.new(7) })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 707,
    "raw_source": "def test_abs\n    assert_template_result(\"17\", \"{{ 17 | abs }}\")\n    assert_template_result(\"17\", \"{{ -17 | abs }}\")\n    assert_template_result(\"17\", \"{{ '17' | abs }}\")\n    assert_template_result(\"17\", \"{{ '-17' | abs }}\")\n    assert_template_result(\"0\", \"{{ 0 | abs }}\")\n    assert_template_result(\"0\", \"{{ '0' | abs }}\")\n    assert_template_result(\"17.42\", \"{{ 17.42 | abs }}\")\n    assert_template_result(\"17.42\", \"{{ -17.42 | abs }}\")\n    assert_template_result(\"17.42\", \"{{ '17.42' | abs }}\")\n    assert_template_result(\"17.42\", \"{{ '-17.42' | abs }}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 720,
    "raw_source": "def test_times\n    assert_template_result(\"12\", \"{{ 3 | times:4 }}\")\n    assert_template_result(\"0\", \"{{ 'foo' | times:4 }}\")\n    assert_template_result(\"6\", \"{{ '2.1' | times:3 | replace: '.','-' | plus:0}}\")\n    assert_template_result(\"7.25\", \"{{ 0.0725 | times:100 }}\")\n    assert_template_result(\"-7.25\", '{{ \"-0.0725\" | times:100 }}')\n    assert_template_result(\"7.25\", '{{ \"-0.0725\" | times: -100 }}')\n    assert_template_result(\"4\", \"{{ price | times:2 }}\", { 'price' => NumberLikeThing.new(2) })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 730,
    "raw_source": "def test_divided_by\n    assert_template_result(\"4\", \"{{ 12 | divided_by:3 }}\")\n    assert_template_result(\"4\", \"{{ 14 | divided_by:3 }}\")\n\n    assert_template_result(\"5\", \"{{ 15 | divided_by:3 }}\")\n    assert_equal(\"Liquid error: divided by 0\", Template.parse(\"{{ 5 | divided_by:0 }}\").render)\n\n    assert_template_result(\"0.5\", \"{{ 2.0 | divided_by:4 }}\")\n    assert_raises(Liquid::ZeroDivisionError) do\n      assert_template_result(\"4\", \"{{ 1 | modulo: 0 }}\")\n    end\n\n    assert_template_result(\"5\", \"{{ price | divided_by:2 }}\", { 'price' => NumberLikeThing.new(10) })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 745,
    "raw_source": "def test_modulo\n    assert_template_result(\"1\", \"{{ 3 | modulo:2 }}\")\n    assert_raises(Liquid::ZeroDivisionError) do\n      assert_template_result(\"4\", \"{{ 1 | modulo: 0 }}\")\n    end\n\n    assert_template_result(\"1\", \"{{ price | modulo:2 }}\", { 'price' => NumberLikeThing.new(3) })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 754,
    "raw_source": "def test_round\n    assert_template_result(\"5\", \"{{ input | round }}\", { 'input' => 4.6 })\n    assert_template_result(\"4\", \"{{ '4.3' | round }}\")\n    assert_template_result(\"4.56\", \"{{ input | round: 2 }}\", { 'input' => 4.5612 })\n    assert_raises(Liquid::FloatDomainError) do\n      assert_template_result(\"4\", \"{{ 1.0 | divided_by: 0.0 | round }}\")\n    end\n\n    assert_template_result(\"5\", \"{{ price | round }}\", { 'price' => NumberLikeThing.new(4.6) })\n    assert_template_result(\"4\", \"{{ price | round }}\", { 'price' => NumberLikeThing.new(4.3) })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 766,
    "raw_source": "def test_ceil\n    assert_template_result(\"5\", \"{{ input | ceil }}\", { 'input' => 4.6 })\n    assert_template_result(\"5\", \"{{ '4.3' | ceil }}\")\n    assert_raises(Liquid::FloatDomainError) do\n      assert_template_result(\"4\", \"{{ 1.0 | divided_by: 0.0 | ceil }}\")\n    end\n\n    assert_template_result(\"5\", \"{{ price | ceil }}\", { 'price' => NumberLikeThing.new(4.6) })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 776,
    "raw_source": "def test_floor\n    assert_template_result(\"4\", \"{{ input | floor }}\", { 'input' => 4.6 })\n    assert_template_result(\"4\", \"{{ '4.3' | floor }}\")\n    assert_raises(Liquid::FloatDomainError) do\n      assert_template_result(\"4\", \"{{ 1.0 | divided_by: 0.0 | floor }}\")\n    end\n\n    assert_template_result(\"5\", \"{{ price | floor }}\", { 'price' => NumberLikeThing.new(5.4) })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 786,
    "raw_source": "def test_at_most\n    assert_template_result(\"4\", \"{{ 5 | at_most:4 }}\")\n    assert_template_result(\"5\", \"{{ 5 | at_most:5 }}\")\n    assert_template_result(\"5\", \"{{ 5 | at_most:6 }}\")\n\n    assert_template_result(\"4.5\", \"{{ 4.5 | at_most:5 }}\")\n    assert_template_result(\"5\", \"{{ width | at_most:5 }}\", { 'width' => NumberLikeThing.new(6) })\n    assert_template_result(\"4\", \"{{ width | at_most:5 }}\", { 'width' => NumberLikeThing.new(4) })\n    assert_template_result(\"4\", \"{{ 5 | at_most: width }}\", { 'width' => NumberLikeThing.new(4) })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 797,
    "raw_source": "def test_at_least\n    assert_template_result(\"5\", \"{{ 5 | at_least:4 }}\")\n    assert_template_result(\"5\", \"{{ 5 | at_least:5 }}\")\n    assert_template_result(\"6\", \"{{ 5 | at_least:6 }}\")\n\n    assert_template_result(\"5\", \"{{ 4.5 | at_least:5 }}\")\n    assert_template_result(\"6\", \"{{ width | at_least:5 }}\", { 'width' => NumberLikeThing.new(6) })\n    assert_template_result(\"5\", \"{{ width | at_least:5 }}\", { 'width' => NumberLikeThing.new(4) })\n    assert_template_result(\"6\", \"{{ 5 | at_least: width }}\", { 'width' => NumberLikeThing.new(6) })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 808,
    "raw_source": "def test_append\n    assigns = { 'a' => 'bc', 'b' => 'd' }\n    assert_template_result('bcd', \"{{ a | append: 'd'}}\", assigns)\n    assert_template_result('bcd', \"{{ a | append: b}}\", assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 814,
    "raw_source": "def test_concat\n    assert_equal([1, 2, 3, 4], @filters.concat([1, 2], [3, 4]))\n    assert_equal([1, 2, 'a'],  @filters.concat([1, 2], ['a']))\n    assert_equal([1, 2, 10],   @filters.concat([1, 2], [10]))\n\n    assert_raises(Liquid::ArgumentError, \"concat filter requires an array argument\") do\n      @filters.concat([1, 2], 10)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 824,
    "raw_source": "def test_prepend\n    assigns = { 'a' => 'bc', 'b' => 'a' }\n    assert_template_result('abc', \"{{ a | prepend: 'a'}}\", assigns)\n    assert_template_result('abc', \"{{ a | prepend: b}}\", assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 830,
    "raw_source": "def test_default\n    assert_equal(\"foo\", @filters.default(\"foo\", \"bar\"))\n    assert_equal(\"bar\", @filters.default(nil, \"bar\"))\n    assert_equal(\"bar\", @filters.default(\"\", \"bar\"))\n    assert_equal(\"bar\", @filters.default(false, \"bar\"))\n    assert_equal(\"bar\", @filters.default([], \"bar\"))\n    assert_equal(\"bar\", @filters.default({}, \"bar\"))\n    assert_template_result('bar', \"{{ false | default: 'bar' }}\")\n    assert_template_result('bar', \"{{ drop | default: 'bar' }}\", { 'drop' => BooleanDrop.new(false) })\n    assert_template_result('Yay', \"{{ drop | default: 'bar' }}\", { 'drop' => BooleanDrop.new(true) })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 842,
    "raw_source": "def test_default_handle_false\n    assert_equal(\"foo\", @filters.default(\"foo\", \"bar\", \"allow_false\" => true))\n    assert_equal(\"bar\", @filters.default(nil, \"bar\", \"allow_false\" => true))\n    assert_equal(\"bar\", @filters.default(\"\", \"bar\", \"allow_false\" => true))\n    assert_equal(false, @filters.default(false, \"bar\", \"allow_false\" => true))\n    assert_equal(\"bar\", @filters.default([], \"bar\", \"allow_false\" => true))\n    assert_equal(\"bar\", @filters.default({}, \"bar\", \"allow_false\" => true))\n    assert_template_result('false', \"{{ false | default: 'bar', allow_false: true }}\")\n    assert_template_result('Nay', \"{{ drop | default: 'bar', allow_false: true }}\", { 'drop' => BooleanDrop.new(false) })\n    assert_template_result('Yay', \"{{ drop | default: 'bar', allow_false: true }}\", { 'drop' => BooleanDrop.new(true) })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 854,
    "raw_source": "def test_cannot_access_private_methods\n    assert_template_result('a', \"{{ 'a' | to_number }}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 858,
    "raw_source": "def test_date_raises_nothing\n    assert_template_result('', \"{{ '' | date: '%D' }}\")\n    assert_template_result('abc', \"{{ 'abc' | date: '%D' }}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 863,
    "raw_source": "def test_reject\n    array = [\n      { \"handle\" => \"alpha\", \"ok\" => true },\n      { \"handle\" => \"beta\", \"ok\" => false },\n      { \"handle\" => \"gamma\", \"ok\" => false },\n      { \"handle\" => \"delta\", \"ok\" => true },\n    ]\n\n    template = \"{{ array | reject: 'ok' | map: 'handle' | join: ' ' }}\"\n    expected_output = \"beta gamma\"\n\n    assert_template_result(expected_output, template, { \"array\" => array })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 877,
    "raw_source": "def test_reject_with_value\n    array = [\n      { \"handle\" => \"alpha\", \"ok\" => true },\n      { \"handle\" => \"beta\", \"ok\" => false },\n      { \"handle\" => \"gamma\", \"ok\" => false },\n      { \"handle\" => \"delta\", \"ok\" => true },\n    ]\n\n    template = \"{{ array | reject: 'ok', true | map: 'handle' | join: ' ' }}\"\n    expected_output = \"beta gamma\"\n\n    assert_template_result(expected_output, template, { \"array\" => array })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 891,
    "raw_source": "def test_reject_with_false_value\n    array = [\n      { \"handle\" => \"alpha\", \"ok\" => true },\n      { \"handle\" => \"beta\", \"ok\" => false },\n      { \"handle\" => \"gamma\", \"ok\" => false },\n      { \"handle\" => \"delta\", \"ok\" => true },\n    ]\n\n    template = \"{{ array | reject: 'ok', false | map: 'handle' | join: ' ' }}\"\n    expected_output = \"alpha delta\"\n\n    assert_template_result(expected_output, template, { \"array\" => array })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 905,
    "raw_source": "def test_has\n    array = [\n      { \"handle\" => \"alpha\", \"ok\" => true },\n      { \"handle\" => \"beta\", \"ok\" => false },\n      { \"handle\" => \"gamma\", \"ok\" => false },\n      { \"handle\" => \"delta\", \"ok\" => false },\n    ]\n\n    expected_output = \"true\"\n\n    assert_template_result(expected_output, \"{{ array | has: 'ok' }}\", { \"array\" => array })\n    assert_template_result(expected_output, \"{{ array | has: 'ok', true }}\", { \"array\" => array })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 919,
    "raw_source": "def test_has_when_does_not_have_it\n    array = [\n      { \"handle\" => \"alpha\", \"ok\" => false },\n      { \"handle\" => \"beta\", \"ok\" => false },\n      { \"handle\" => \"gamma\", \"ok\" => false },\n      { \"handle\" => \"delta\", \"ok\" => false },\n    ]\n\n    expected_output = \"false\"\n\n    assert_template_result(expected_output, \"{{ array | has: 'ok' }}\", { \"array\" => array })\n    assert_template_result(expected_output, \"{{ array | has: 'ok', true }}\", { \"array\" => array })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 933,
    "raw_source": "def test_has_with_empty_arrays\n    template = <<~LIQUID\n      {%- assign has_product = products | has: 'title.content', 'Not found' -%}\n      {%- unless has_product -%}\n        Product not found.\n      {%- endunless -%}\n    LIQUID\n    expected_output = \"Product not found.\"\n\n    assert_template_result(expected_output, template, { \"products\" => [] })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 945,
    "raw_source": "def test_has_with_false_value\n    array = [\n      { \"handle\" => \"alpha\", \"ok\" => true },\n      { \"handle\" => \"beta\", \"ok\" => false },\n      { \"handle\" => \"gamma\", \"ok\" => false },\n      { \"handle\" => \"delta\", \"ok\" => true },\n    ]\n\n    template = \"{{ array | has: 'ok', false }}\"\n    expected_output = \"true\"\n\n    assert_template_result(expected_output, template, { \"array\" => array })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 959,
    "raw_source": "def test_has_with_false_value_when_does_not_have_it\n    array = [\n      { \"handle\" => \"alpha\", \"ok\" => true },\n      { \"handle\" => \"beta\", \"ok\" => true },\n      { \"handle\" => \"gamma\", \"ok\" => true },\n      { \"handle\" => \"delta\", \"ok\" => true },\n    ]\n\n    template = \"{{ array | has: 'ok', false }}\"\n    expected_output = \"false\"\n\n    assert_template_result(expected_output, template, { \"array\" => array })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 973,
    "raw_source": "def test_find_with_value\n    products = [\n      { \"title\" => \"Pro goggles\",    \"price\" => 1299 },\n      { \"title\" => \"Thermal gloves\", \"price\" => 1499 },\n      { \"title\" => \"Alpine jacket\",  \"price\" => 3999 },\n      { \"title\" => \"Mountain boots\", \"price\" => 3899 },\n      { \"title\" => \"Safety helmet\",  \"price\" => 1999 }\n    ]\n\n    template = <<~LIQUID\n      {%- assign product = products | find: 'price', 3999 -%}\n      {{- product.title -}}\n    LIQUID\n    expected_output = \"Alpine jacket\"\n\n    assert_template_result(expected_output, template, { \"products\" => products })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 991,
    "raw_source": "def test_find_with_empty_arrays\n    template = <<~LIQUID\n      {%- assign product = products | find: 'title.content', 'Not found' -%}\n      {%- unless product -%}\n        Product not found.\n      {%- endunless -%}\n    LIQUID\n    expected_output = \"Product not found.\"\n\n    assert_template_result(expected_output, template, { \"products\" => [] })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1003,
    "raw_source": "def test_find_index_with_value\n    products = [\n      { \"title\" => \"Pro goggles\",    \"price\" => 1299 },\n      { \"title\" => \"Thermal gloves\", \"price\" => 1499 },\n      { \"title\" => \"Alpine jacket\",  \"price\" => 3999 },\n      { \"title\" => \"Mountain boots\", \"price\" => 3899 },\n      { \"title\" => \"Safety helmet\",  \"price\" => 1999 }\n    ]\n\n    template = <<~LIQUID\n      {%- assign index = products | find_index: 'price', 3999 -%}\n      {{- index -}}\n    LIQUID\n    expected_output = \"2\"\n\n    assert_template_result(expected_output, template, { \"products\" => products })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1021,
    "raw_source": "def test_find_index_with_empty_arrays\n    template = <<~LIQUID\n      {%- assign index = products | find_index: 'title.content', 'Not found' -%}\n      {%- unless index -%}\n        Index not found.\n      {%- endunless -%}\n    LIQUID\n    expected_output = \"Index not found.\"\n\n    assert_template_result(expected_output, template, { \"products\" => [] })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1033,
    "raw_source": "def test_where\n    array = [\n      { \"handle\" => \"alpha\", \"ok\" => true },\n      { \"handle\" => \"beta\", \"ok\" => false },\n      { \"handle\" => \"gamma\", \"ok\" => false },\n      { \"handle\" => \"delta\", \"ok\" => true },\n    ]\n\n    template = \"{{ array | where: 'ok' | map: 'handle' | join: ' ' }}\"\n    expected_output = \"alpha delta\"\n\n    assert_template_result(expected_output, template, { \"array\" => array })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1047,
    "raw_source": "def test_where_with_empty_string_is_a_no_op\n    environment = { \"array\" => [\"alpha\", \"beta\", \"gamma\"] }\n    expected_output = \"alpha beta gamma\"\n    template = \"{{ array | where: '' | join: ' ' }}\"\n\n    assert_template_result(expected_output, template, environment)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1055,
    "raw_source": "def test_where_with_nil_is_a_no_op\n    environment = { \"array\" => [\"alpha\", \"beta\", \"gamma\"] }\n    template = \"{{ array | where: nil | join: ' ' }}\"\n\n    assert_raises(Liquid::ArgumentError) do\n      assert_template_result(\"alpha beta gamma\", template, environment)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1064,
    "raw_source": "def test_where_with_value\n    array = [\n      { \"handle\" => \"alpha\", \"ok\" => true },\n      { \"handle\" => \"beta\", \"ok\" => false },\n      { \"handle\" => \"gamma\", \"ok\" => false },\n      { \"handle\" => \"delta\", \"ok\" => true },\n    ]\n\n    template = \"{{ array | where: 'ok', true | map: 'handle' | join: ' ' }}\"\n    expected_output = \"alpha delta\"\n\n    assert_template_result(expected_output, template, { \"array\" => array })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1078,
    "raw_source": "def test_where_with_false_value\n    array = [\n      { \"handle\" => \"alpha\", \"ok\" => true },\n      { \"handle\" => \"beta\", \"ok\" => false },\n      { \"handle\" => \"gamma\", \"ok\" => false },\n      { \"handle\" => \"delta\", \"ok\" => true },\n    ]\n\n    template = \"{{ array | where: 'ok', false | map: 'handle' | join: ' ' }}\"\n    expected_output = \"beta gamma\"\n\n    assert_template_result(expected_output, template, { \"array\" => array })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1092,
    "raw_source": "def test_where_string_keys\n    input = [\n      \"alpha\", \"beta\", \"gamma\", \"delta\"\n    ]\n\n    expectation = [\n      \"beta\",\n    ]\n\n    assert_equal(expectation, @filters.where(input, \"be\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1104,
    "raw_source": "def test_where_no_key_set\n    input = [\n      { \"handle\" => \"alpha\", \"ok\" => true },\n      { \"handle\" => \"beta\" },\n      { \"handle\" => \"gamma\" },\n      { \"handle\" => \"delta\", \"ok\" => true },\n    ]\n\n    expectation = [\n      { \"handle\" => \"alpha\", \"ok\" => true },\n      { \"handle\" => \"delta\", \"ok\" => true },\n    ]\n\n    assert_equal(expectation, @filters.where(input, \"ok\", true))\n    assert_equal(expectation, @filters.where(input, \"ok\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1121,
    "raw_source": "def test_where_non_array_map_input\n    assert_equal([{ \"a\" => \"ok\" }], @filters.where({ \"a\" => \"ok\" }, \"a\", \"ok\"))\n    assert_equal([], @filters.where({ \"a\" => \"not ok\" }, \"a\", \"ok\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1126,
    "raw_source": "def test_where_indexable_but_non_map_value\n    assert_raises(Liquid::ArgumentError) { @filters.where(1, \"ok\", true) }\n    assert_raises(Liquid::ArgumentError) { @filters.where(1, \"ok\") }\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1131,
    "raw_source": "def test_where_non_boolean_value\n    input = [\n      { \"message\" => \"Bonjour!\", \"language\" => \"French\" },\n      { \"message\" => \"Hello!\", \"language\" => \"English\" },\n      { \"message\" => \"Hallo!\", \"language\" => \"German\" },\n    ]\n\n    assert_equal([{ \"message\" => \"Bonjour!\", \"language\" => \"French\" }], @filters.where(input, \"language\", \"French\"))\n    assert_equal([{ \"message\" => \"Hallo!\", \"language\" => \"German\" }], @filters.where(input, \"language\", \"German\"))\n    assert_equal([{ \"message\" => \"Hello!\", \"language\" => \"English\" }], @filters.where(input, \"language\", \"English\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1143,
    "raw_source": "def test_where_array_of_only_unindexable_values\n    assert_nil(@filters.where([nil], \"ok\", true))\n    assert_nil(@filters.where([nil], \"ok\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1148,
    "raw_source": "def test_all_filters_never_raise_non_liquid_exception\n    test_drop = TestDrop.new(value: \"test\")\n    test_drop.context = Context.new\n    test_enum = TestEnumerable.new\n    test_enum.context = Context.new\n    test_types = [\n      \"foo\",\n      123,\n      0,\n      0.0,\n      -1234.003030303,\n      -99999999,\n      1234.38383000383830003838300,\n      nil,\n      true,\n      false,\n      TestThing.new,\n      test_drop,\n      test_enum,\n      [\"foo\", \"bar\"],\n      { \"foo\" => \"bar\" },\n      { foo: \"bar\" },\n      [{ \"foo\" => \"bar\" }, { \"foo\" => 123 }, { \"foo\" => nil }, { \"foo\" => true }, { \"foo\" => [\"foo\", \"bar\"] }],\n      { 1 => \"bar\" },\n      [\"foo\", 123, nil, true, false, Drop, [\"foo\"], { foo: \"bar\" }],\n    ]\n    StandardFilters.public_instance_methods(false).each do |method|\n      arg_count = @filters.method(method).arity\n      arg_count *= -1 if arg_count < 0\n\n      test_types.repeated_permutation(arg_count) do |args|\n        @filters.send(method, *args)\n      rescue Liquid::Error\n        nil\n      end\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1186,
    "raw_source": "def test_where_no_target_value\n    input = [\n      { \"foo\" => false },\n      { \"foo\" => true },\n      { \"foo\" => \"for sure\" },\n      { \"bar\" => true },\n    ]\n\n    assert_equal([{ \"foo\" => true }, { \"foo\" => \"for sure\" }], @filters.where(input, \"foo\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1197,
    "raw_source": "def test_sum_with_all_numbers\n    input = [1, 2]\n\n    assert_equal(3, @filters.sum(input))\n    assert_raises(Liquid::ArgumentError, \"cannot select the property 'quantity'\") do\n      @filters.sum(input, \"quantity\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1206,
    "raw_source": "def test_sum_with_numeric_strings\n    input = [1, 2, \"3\", \"4\"]\n\n    assert_equal(10, @filters.sum(input))\n    assert_raises(Liquid::ArgumentError, \"cannot select the property 'quantity'\") do\n      @filters.sum(input, \"quantity\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1215,
    "raw_source": "def test_sum_with_nested_arrays\n    input = [1, [2, [3, 4]]]\n\n    assert_equal(10, @filters.sum(input))\n    assert_raises(Liquid::ArgumentError, \"cannot select the property 'quantity'\") do\n      @filters.sum(input, \"quantity\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1224,
    "raw_source": "def test_sum_with_indexable_map_values\n    input = [{ \"quantity\" => 1 }, { \"quantity\" => 2, \"weight\" => 3 }, { \"weight\" => 4 }]\n\n    assert_equal(0, @filters.sum(input))\n    assert_equal(3, @filters.sum(input, \"quantity\"))\n    assert_equal(7, @filters.sum(input, \"weight\"))\n    assert_equal(0, @filters.sum(input, \"subtotal\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1233,
    "raw_source": "def test_sum_with_indexable_non_map_values\n    input = [1, [2], \"foo\", { \"quantity\" => 3 }]\n\n    assert_equal(3, @filters.sum(input))\n    assert_raises(Liquid::ArgumentError, \"cannot select the property 'quantity'\") do\n      @filters.sum(input, \"quantity\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1242,
    "raw_source": "def test_sum_with_unindexable_values\n    input = [1, true, nil, { \"quantity\" => 2 }]\n\n    assert_equal(1, @filters.sum(input))\n    assert_raises(Liquid::ArgumentError, \"cannot select the property 'quantity'\") do\n      @filters.sum(input, \"quantity\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1251,
    "raw_source": "def test_sum_without_property_calls_to_liquid\n    t = TestThing.new\n    Liquid::Template.parse('{{ foo | sum }}').render(\"foo\" => [t])\n    assert(t.foo > 0)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1257,
    "raw_source": "def test_sum_with_property_calls_to_liquid_on_property_values\n    t = TestThing.new\n    Liquid::Template.parse('{{ foo | sum: \"quantity\" }}').render(\"foo\" => [{ \"quantity\" => t }])\n    assert(t.foo > 0)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1263,
    "raw_source": "def test_sum_of_floats\n    input = [0.1, 0.2, 0.3]\n    assert_equal(0.6, @filters.sum(input))\n    assert_template_result(\"0.6\", \"{{ input | sum }}\", { \"input\" => input })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1269,
    "raw_source": "def test_sum_of_negative_floats\n    input = [0.1, 0.2, -0.3]\n    assert_equal(0.0, @filters.sum(input))\n    assert_template_result(\"0.0\", \"{{ input | sum }}\", { \"input\" => input })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1275,
    "raw_source": "def test_sum_with_float_strings\n    input = [0.1, \"0.2\", \"0.3\"]\n    assert_equal(0.6, @filters.sum(input))\n    assert_template_result(\"0.6\", \"{{ input | sum }}\", { \"input\" => input })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1281,
    "raw_source": "def test_sum_resulting_in_negative_float\n    input = [0.1, -0.2, -0.3]\n    assert_equal(-0.4, @filters.sum(input))\n    assert_template_result(\"-0.4\", \"{{ input | sum }}\", { \"input\" => input })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1287,
    "raw_source": "def test_sum_with_floats_and_indexable_map_values\n    input = [{ \"quantity\" => 1 }, { \"quantity\" => 0.2, \"weight\" => -0.3 }, { \"weight\" => 0.4 }]\n    assert_equal(0.0, @filters.sum(input))\n    assert_equal(1.2, @filters.sum(input, \"quantity\"))\n    assert_equal(0.1, @filters.sum(input, \"weight\"))\n    assert_equal(0.0, @filters.sum(input, \"subtotal\"))\n    assert_template_result(\"0\", \"{{ input | sum }}\", { \"input\" => input })\n    assert_template_result(\"1.2\", \"{{ input | sum: 'quantity' }}\", { \"input\" => input })\n    assert_template_result(\"0.1\", \"{{ input | sum: 'weight' }}\", { \"input\" => input })\n    assert_template_result(\"0\", \"{{ input | sum: 'subtotal' }}\", { \"input\" => input })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1299,
    "raw_source": "def test_sum_with_non_string_property\n    input = [{ true => 1 }, { 1.0 => 0.2, 1 => -0.3 }, { 1..5 => 0.4 }]\n\n    assert_equal(1, @filters.sum(input, true))\n    assert_equal(0.2, @filters.sum(input, 1.0))\n    assert_equal(-0.3, @filters.sum(input, 1))\n    assert_equal(0.4, @filters.sum(input, (1..5)))\n    assert_equal(0, @filters.sum(input, nil))\n    assert_equal(0, @filters.sum(input, \"\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1310,
    "raw_source": "def test_uniq_with_to_liquid_value\n    input = [StringDrop.new(\"foo\"), StringDrop.new(\"bar\"), \"foo\"]\n    expected = [StringDrop.new(\"foo\"), StringDrop.new(\"bar\")]\n    result = @filters.uniq(input)\n\n    assert_equal(expected, result)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1318,
    "raw_source": "def test_uniq_with_to_liquid_value_pick_correct_classes\n    input = [\"foo\", StringDrop.new(\"foo\"), StringDrop.new(\"bar\")]\n    expected = [String, StringDrop]\n    result = @filters.uniq(input).map(&:class)\n\n    assert_equal(expected, result)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/standard_filter_test.rb",
    "start_line": 1328,
    "raw_source": "def with_timezone(tz)\n    old_tz    = ENV['TZ']\n    ENV['TZ'] = tz\n    yield\n  ensure\n    ENV['TZ'] = old_tz\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tag/disableable_test.rb",
    "start_line": 9,
    "raw_source": "def render(_context)\n      tag_name\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tag/disableable_test.rb",
    "start_line": 32,
    "raw_source": "def test_block_tag_disabling_nested_tag\n    with_disableable_tags do\n      with_custom_tag('disable', DisableCustom) do\n        output = Template.parse('{% disable %}{% custom %};{% custom2 %}{% enddisable %}').render\n        assert_equal('Liquid error: custom usage is not allowed in this context;custom2', output)\n      end\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tag/disableable_test.rb",
    "start_line": 41,
    "raw_source": "def test_block_tag_disabling_multiple_nested_tags\n    with_disableable_tags do\n      with_custom_tag('disable', DisableBoth) do\n        output = Template.parse('{% disable %}{% custom %};{% custom2 %}{% enddisable %}').render\n        assert_equal('Liquid error: custom usage is not allowed in this context;Liquid error: custom2 usage is not allowed in this context', output)\n      end\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tag/disableable_test.rb",
    "start_line": 52,
    "raw_source": "def with_disableable_tags\n    with_custom_tag('custom', Custom) do\n      with_custom_tag('custom2', Custom2) do\n        yield\n      end\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tag_test.rb",
    "start_line": 8,
    "raw_source": "def test_custom_tags_have_a_default_render_to_output_buffer_method_for_backwards_compatibility\n    klass1 = Class.new(Tag) do\n      def render(*)\n        'hello'\n      end\n    end\n\n    with_custom_tag('blabla', klass1) do\n      template = Liquid::Template.parse(\"{% blabla %}\")\n\n      assert_equal('hello', template.render)\n\n      buf    = +''\n      output = template.render({}, output: buf)\n      assert_equal('hello', output)\n      assert_equal('hello', buf)\n      assert_equal(buf.object_id, output.object_id)\n    end\n\n    klass2 = Class.new(klass1) do\n      def render(*)\n        'foo' + super + 'bar'\n      end\n    end\n\n    with_custom_tag('blabla', klass2) do\n      template = Liquid::Template.parse(\"{% blabla %}\")\n\n      assert_equal('foohellobar', template.render)\n\n      buf    = +''\n      output = template.render({}, output: buf)\n      assert_equal('foohellobar', output)\n      assert_equal('foohellobar', buf)\n      assert_equal(buf.object_id, output.object_id)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tag_test.rb",
    "start_line": 10,
    "raw_source": "def render(*)\n        'hello'\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tag_test.rb",
    "start_line": 28,
    "raw_source": "def render(*)\n        'foo' + super + 'bar'\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/break_tag_test.rb",
    "start_line": 10,
    "raw_source": "def test_break_with_no_block\n    assigns  = { 'i' => 1 }\n    markup   = 'before{% break %}after'\n    expected = 'before'\n\n    assert_template_result(expected, markup, assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/continue_tag_test.rb",
    "start_line": 10,
    "raw_source": "def test_continue_with_no_block\n    assigns  = {}\n    markup   = '{% continue %}'\n    expected = ''\n\n    assert_template_result(expected, markup, assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/cycle_tag_test.rb",
    "start_line": 6,
    "raw_source": "def test_simple_cycle\n    template = <<~LIQUID\n      {%- cycle '1', '2', '3' -%}\n      {%- cycle '1', '2', '3' -%}\n      {%- cycle '1', '2', '3' -%}\n    LIQUID\n\n    assert_template_result(\"123\", template)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/cycle_tag_test.rb",
    "start_line": 16,
    "raw_source": "def test_simple_cycle_inside_for_loop\n    template = <<~LIQUID\n      {%- for i in (1..3) -%}\n        {% cycle '1', '2', '3' %}\n      {%- endfor -%}\n    LIQUID\n\n    assert_template_result(\"123\", template)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/cycle_tag_test.rb",
    "start_line": 26,
    "raw_source": "def test_cycle_with_variables_inside_for_loop\n    template = <<~LIQUID\n      {%- assign a = 1 -%}\n      {%- assign b = 2 -%}\n      {%- assign c = 3 -%}\n      {%- for i in (1..3) -%}\n        {% cycle a, b, c %}\n      {%- endfor -%}\n    LIQUID\n\n    assert_template_result(\"123\", template)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/cycle_tag_test.rb",
    "start_line": 39,
    "raw_source": "def test_cycle_tag_always_resets_cycle\n    template = <<~LIQUID\n      {%- assign a = \"1\" -%}\n      {%- cycle a, \"2\" -%}\n      {%- cycle a, \"2\" -%}\n    LIQUID\n\n    assert_template_result(\"11\", template)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/echo_test.rb",
    "start_line": 8,
    "raw_source": "def test_echo_outputs_its_input\n    assert_template_result('BAR', <<~LIQUID, { 'variable-name' => 'bar' })\n      {%- echo variable-name | upcase -%}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 6,
    "raw_source": "def value\n    3\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 14,
    "raw_source": "def test_for\n    assert_template_result(' yo  yo  yo  yo ', '{%for item in array%} yo {%endfor%}', { 'array' => [1, 2, 3, 4] })\n    assert_template_result('yoyo', '{%for item in array%}yo{%endfor%}', { 'array' => [1, 2] })\n    assert_template_result(' yo ', '{%for item in array%} yo {%endfor%}', { 'array' => [1] })\n    assert_template_result('', '{%for item in array%}{%endfor%}', { 'array' => [1, 2] })\n    expected = <<HERE\n\n  yo\n\n  yo\n\n  yo\n\nHERE\n    template = <<~HERE\n      {%for item in array%}\n        yo\n      {%endfor%}\n    HERE\n    assert_template_result(expected, template, { 'array' => [1, 2, 3] })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 36,
    "raw_source": "def test_for_reversed\n    assigns = { 'array' => [1, 2, 3] }\n    assert_template_result('321', '{%for item in array reversed %}{{item}}{%endfor%}', assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 41,
    "raw_source": "def test_for_with_range\n    assert_template_result(' 1  2  3 ', '{%for item in (1..3) %} {{item}} {%endfor%}')\n\n    assert_raises(Liquid::ArgumentError) do\n      Template.parse('{% for i in (a..2) %}{% endfor %}').render!(\"a\" => [1, 2])\n    end\n\n    assert_template_result(' 0  1  2  3 ', '{% for item in (a..3) %} {{item}} {% endfor %}', { \"a\" => \"invalid integer\" })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 51,
    "raw_source": "def test_for_with_variable_range\n    assert_template_result(' 1  2  3 ', '{%for item in (1..foobar) %} {{item}} {%endfor%}', { \"foobar\" => 3 })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 55,
    "raw_source": "def test_for_with_hash_value_range\n    foobar = { \"value\" => 3 }\n    assert_template_result(' 1  2  3 ', '{%for item in (1..foobar.value) %} {{item}} {%endfor%}', { \"foobar\" => foobar })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 60,
    "raw_source": "def test_for_with_drop_value_range\n    foobar = ThingWithValue.new\n    assert_template_result(' 1  2  3 ', '{%for item in (1..foobar.value) %} {{item}} {%endfor%}', { \"foobar\" => foobar })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 65,
    "raw_source": "def test_for_with_variable\n    assert_template_result(' 1  2  3 ', '{%for item in array%} {{item}} {%endfor%}', { 'array' => [1, 2, 3] })\n    assert_template_result('123', '{%for item in array%}{{item}}{%endfor%}', { 'array' => [1, 2, 3] })\n    assert_template_result('123', '{% for item in array %}{{item}}{% endfor %}', { 'array' => [1, 2, 3] })\n    assert_template_result('abcd', '{%for item in array%}{{item}}{%endfor%}', { 'array' => ['a', 'b', 'c', 'd'] })\n    assert_template_result('a b c', '{%for item in array%}{{item}}{%endfor%}', { 'array' => ['a', ' ', 'b', ' ', 'c'] })\n    assert_template_result('abc', '{%for item in array%}{{item}}{%endfor%}', { 'array' => ['a', '', 'b', '', 'c'] })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 74,
    "raw_source": "def test_for_helpers\n    assigns = { 'array' => [1, 2, 3] }\n    assert_template_result(\n      ' 1/3  2/3  3/3 ',\n      '{%for item in array%} {{forloop.index}}/{{forloop.length}} {%endfor%}',\n      assigns,\n    )\n    assert_template_result(' 1  2  3 ', '{%for item in array%} {{forloop.index}} {%endfor%}', assigns)\n    assert_template_result(' 0  1  2 ', '{%for item in array%} {{forloop.index0}} {%endfor%}', assigns)\n    assert_template_result(' 2  1  0 ', '{%for item in array%} {{forloop.rindex0}} {%endfor%}', assigns)\n    assert_template_result(' 3  2  1 ', '{%for item in array%} {{forloop.rindex}} {%endfor%}', assigns)\n    assert_template_result(' true  false  false ', '{%for item in array%} {{forloop.first}} {%endfor%}', assigns)\n    assert_template_result(' false  false  true ', '{%for item in array%} {{forloop.last}} {%endfor%}', assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 89,
    "raw_source": "def test_for_and_if\n    assigns = { 'array' => [1, 2, 3] }\n    assert_template_result(\n      '+--',\n      '{%for item in array%}{% if forloop.first %}+{% else %}-{% endif %}{%endfor%}',\n      assigns,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 98,
    "raw_source": "def test_for_else\n    assert_template_result('+++', '{%for item in array%}+{%else%}-{%endfor%}', { 'array' => [1, 2, 3] })\n    assert_template_result('-',   '{%for item in array%}+{%else%}-{%endfor%}', { 'array' => [] })\n    assert_template_result('-',   '{%for item in array%}+{%else%}-{%endfor%}', { 'array' => nil })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 104,
    "raw_source": "def test_limiting\n    assigns = { 'array' => [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] }\n    assert_template_result('12', '{%for i in array limit:2 %}{{ i }}{%endfor%}', assigns)\n    assert_template_result('1234', '{%for i in array limit:4 %}{{ i }}{%endfor%}', assigns)\n    assert_template_result('3456', '{%for i in array limit:4 offset:2 %}{{ i }}{%endfor%}', assigns)\n    assert_template_result('3456', '{%for i in array limit: 4 offset: 2 %}{{ i }}{%endfor%}', assigns)\n    assert_template_result('3456', '{%for i in array, limit: 4, offset: 2 %}{{ i }}{%endfor%}', assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 113,
    "raw_source": "def test_limiting_with_invalid_limit\n    assigns  = { 'array' => [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] }\n    template = <<-MKUP\n      {% for i in array limit: true offset: 1 %}\n        {{ i }}\n      {% endfor %}\n    MKUP\n\n    exception = assert_raises(Liquid::ArgumentError) do\n      Template.parse(template).render!(assigns)\n    end\n    assert_equal(\"Liquid error: invalid integer\", exception.message)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 127,
    "raw_source": "def test_limiting_with_invalid_offset\n    assigns  = { 'array' => [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] }\n    template = <<-MKUP\n      {% for i in array limit: 1 offset: true %}\n        {{ i }}\n      {% endfor %}\n    MKUP\n\n    exception = assert_raises(Liquid::ArgumentError) do\n      Template.parse(template).render!(assigns)\n    end\n    assert_equal(\"Liquid error: invalid integer\", exception.message)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 141,
    "raw_source": "def test_dynamic_variable_limiting\n    assigns           = { 'array' => [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] }\n    assigns['limit']  = 2\n    assigns['offset'] = 2\n\n    assert_template_result('34', '{%for i in array limit: limit offset: offset %}{{ i }}{%endfor%}', assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 149,
    "raw_source": "def test_nested_for\n    assigns = { 'array' => [[1, 2], [3, 4], [5, 6]] }\n    assert_template_result('123456', '{%for item in array%}{%for i in item%}{{ i }}{%endfor%}{%endfor%}', assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 154,
    "raw_source": "def test_offset_only\n    assigns = { 'array' => [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] }\n    assert_template_result('890', '{%for i in array offset:7 %}{{ i }}{%endfor%}', assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 159,
    "raw_source": "def test_pause_resume\n    assigns  = { 'array' => { 'items' => [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] } }\n    markup   = <<-MKUP\n      {%for i in array.items limit: 3 %}{{i}}{%endfor%}\n      next\n      {%for i in array.items offset:continue limit: 3 %}{{i}}{%endfor%}\n      next\n      {%for i in array.items offset:continue limit: 3 %}{{i}}{%endfor%}\n      MKUP\n    expected = <<-XPCTD\n      123\n      next\n      456\n      next\n      789\n      XPCTD\n    assert_template_result(expected, markup, assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 178,
    "raw_source": "def test_pause_resume_limit\n    assigns  = { 'array' => { 'items' => [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] } }\n    markup   = <<-MKUP\n      {%for i in array.items limit:3 %}{{i}}{%endfor%}\n      next\n      {%for i in array.items offset:continue limit:3 %}{{i}}{%endfor%}\n      next\n      {%for i in array.items offset:continue limit:1 %}{{i}}{%endfor%}\n      MKUP\n    expected = <<-XPCTD\n      123\n      next\n      456\n      next\n      7\n      XPCTD\n    assert_template_result(expected, markup, assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 197,
    "raw_source": "def test_pause_resume_big_limit\n    assigns  = { 'array' => { 'items' => [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] } }\n    markup   = <<-MKUP\n      {%for i in array.items limit:3 %}{{i}}{%endfor%}\n      next\n      {%for i in array.items offset:continue limit:3 %}{{i}}{%endfor%}\n      next\n      {%for i in array.items offset:continue limit:1000 %}{{i}}{%endfor%}\n      MKUP\n    expected = <<-XPCTD\n      123\n      next\n      456\n      next\n      7890\n      XPCTD\n    assert_template_result(expected, markup, assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 216,
    "raw_source": "def test_pause_resume_big_offset\n    assigns  = { 'array' => { 'items' => [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] } }\n    markup   = '{%for i in array.items limit:3 %}{{i}}{%endfor%}\n      next\n      {%for i in array.items offset:continue limit:3 %}{{i}}{%endfor%}\n      next\n      {%for i in array.items offset:continue limit:3 offset:1000 %}{{i}}{%endfor%}'\n    expected = '123\n      next\n      456\n      next\n      '\n    assert_template_result(expected, markup, assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 231,
    "raw_source": "def test_for_with_break\n    assigns = { 'array' => { 'items' => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] } }\n\n    markup   = '{% for i in array.items %}{% break %}{% endfor %}'\n    expected = \"\"\n    assert_template_result(expected, markup, assigns)\n\n    markup   = '{% for i in array.items %}{{ i }}{% break %}{% endfor %}'\n    expected = \"1\"\n    assert_template_result(expected, markup, assigns)\n\n    markup   = '{% for i in array.items %}{% break %}{{ i }}{% endfor %}'\n    expected = \"\"\n    assert_template_result(expected, markup, assigns)\n\n    markup   = '{% for i in array.items %}{{ i }}{% if i > 3 %}{% break %}{% endif %}{% endfor %}'\n    expected = \"1234\"\n    assert_template_result(expected, markup, assigns)\n\n    # tests to ensure it only breaks out of the local for loop\n    # and not all of them.\n    assigns  = { 'array' => [[1, 2], [3, 4], [5, 6]] }\n    markup   = '{% for item in array %}' \\\n               '{% for i in item %}' \\\n                 '{% if i == 1 %}' \\\n                   '{% break %}' \\\n                 '{% endif %}' \\\n                 '{{ i }}' \\\n               '{% endfor %}' \\\n             '{% endfor %}'\n    expected = '3456'\n    assert_template_result(expected, markup, assigns)\n\n    # test break does nothing when unreached\n    assigns  = { 'array' => { 'items' => [1, 2, 3, 4, 5] } }\n    markup   = '{% for i in array.items %}{% if i == 9999 %}{% break %}{% endif %}{{ i }}{% endfor %}'\n    expected = '12345'\n    assert_template_result(expected, markup, assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 271,
    "raw_source": "def test_for_with_break_after_nested_loop\n    source = <<~LIQUID.chomp\n      {% for i in (1..2) -%}\n        {% for j in (1..2) -%}\n          {{ i }}-{{ j }},\n        {%- endfor -%}\n        {% break -%}\n      {% endfor -%}\n      after\n    LIQUID\n    assert_template_result(\"1-1,1-2,after\", source)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 284,
    "raw_source": "def test_for_with_continue\n    assigns = { 'array' => { 'items' => [1, 2, 3, 4, 5] } }\n\n    markup   = '{% for i in array.items %}{% continue %}{% endfor %}'\n    expected = \"\"\n    assert_template_result(expected, markup, assigns)\n\n    markup   = '{% for i in array.items %}{{ i }}{% continue %}{% endfor %}'\n    expected = \"12345\"\n    assert_template_result(expected, markup, assigns)\n\n    markup   = '{% for i in array.items %}{% continue %}{{ i }}{% endfor %}'\n    expected = \"\"\n    assert_template_result(expected, markup, assigns)\n\n    markup   = '{% for i in array.items %}{% if i > 3 %}{% continue %}{% endif %}{{ i }}{% endfor %}'\n    expected = \"123\"\n    assert_template_result(expected, markup, assigns)\n\n    markup   = '{% for i in array.items %}{% if i == 3 %}{% continue %}{% else %}{{ i }}{% endif %}{% endfor %}'\n    expected = \"1245\"\n    assert_template_result(expected, markup, assigns)\n\n    # tests to ensure it only continues the local for loop and not all of them.\n    assigns  = { 'array' => [[1, 2], [3, 4], [5, 6]] }\n    markup   = '{% for item in array %}' \\\n               '{% for i in item %}' \\\n                 '{% if i == 1 %}' \\\n                   '{% continue %}' \\\n                 '{% endif %}' \\\n                 '{{ i }}' \\\n               '{% endfor %}' \\\n             '{% endfor %}'\n    expected = '23456'\n    assert_template_result(expected, markup, assigns)\n\n    # test continue does nothing when unreached\n    assigns  = { 'array' => { 'items' => [1, 2, 3, 4, 5] } }\n    markup   = '{% for i in array.items %}{% if i == 9999 %}{% continue %}{% endif %}{{ i }}{% endfor %}'\n    expected = '12345'\n    assert_template_result(expected, markup, assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 327,
    "raw_source": "def test_for_tag_string\n    # ruby 1.8.7 \"String\".each => Enumerator with single \"String\" element.\n    # ruby 1.9.3 no longer supports .each on String though we mimic\n    # the functionality for backwards compatibility\n\n    assert_template_result(\n      'test string',\n      '{%for val in string%}{{val}}{%endfor%}',\n      { 'string' => \"test string\" },\n    )\n\n    assert_template_result(\n      'test string',\n      '{%for val in string limit:1%}{{val}}{%endfor%}',\n      { 'string' => \"test string\" },\n    )\n\n    assert_template_result(\n      'val-string-1-1-0-1-0-true-true-test string',\n      '{%for val in string%}' \\\n      '{{forloop.name}}-' \\\n      '{{forloop.index}}-' \\\n      '{{forloop.length}}-' \\\n      '{{forloop.index0}}-' \\\n      '{{forloop.rindex}}-' \\\n      '{{forloop.rindex0}}-' \\\n      '{{forloop.first}}-' \\\n      '{{forloop.last}}-' \\\n      '{{val}}{%endfor%}',\n      { 'string' => \"test string\" },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 360,
    "raw_source": "def test_for_parentloop_references_parent_loop\n    assert_template_result(\n      '1.1 1.2 1.3 2.1 2.2 2.3 ',\n      '{% for inner in outer %}{% for k in inner %}' \\\n      '{{ forloop.parentloop.index }}.{{ forloop.index }} ' \\\n      '{% endfor %}{% endfor %}',\n      { 'outer' => [[1, 1, 1], [1, 1, 1]] },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 370,
    "raw_source": "def test_for_parentloop_nil_when_not_present\n    assert_template_result(\n      '.1 .2 ',\n      '{% for inner in outer %}' \\\n      '{{ forloop.parentloop.index }}.{{ forloop.index }} ' \\\n      '{% endfor %}',\n      { 'outer' => [[1, 1, 1], [1, 1, 1]] },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 380,
    "raw_source": "def test_inner_for_over_empty_input\n    assert_template_result('oo', '{% for a in (1..2) %}o{% for b in empty %}{% endfor %}{% endfor %}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 384,
    "raw_source": "def test_blank_string_not_iterable\n    assert_template_result('', \"{% for char in characters %}I WILL NOT BE OUTPUT{% endfor %}\", { 'characters' => '' })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 388,
    "raw_source": "def test_bad_variable_naming_in_for_loop\n    assert_raises(Liquid::SyntaxError) do\n      Liquid::Template.parse('{% for a/b in x %}{% endfor %}')\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 394,
    "raw_source": "def test_spacing_with_variable_naming_in_for_loop\n    expected = '12345'\n    template = '{% for       item   in   items %}{{item}}{% endfor %}'\n    assigns  = { 'items' => [1, 2, 3, 4, 5] }\n    assert_template_result(expected, template, assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 404,
    "raw_source": "def initialize(data)\n      @data = data\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 408,
    "raw_source": "def each\n      @each_called = true\n      @data.each { |el| yield el }\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 413,
    "raw_source": "def load_slice(from, to)\n      @load_slice_called = true\n      @data[(from..to - 1)]\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 419,
    "raw_source": "def test_iterate_with_each_when_no_limit_applied\n    loader   = LoaderDrop.new([1, 2, 3, 4, 5])\n    assigns  = { 'items' => loader }\n    expected = '12345'\n    template = '{% for item in items %}{{item}}{% endfor %}'\n    assert_template_result(expected, template, assigns)\n    assert(loader.each_called)\n    assert(!loader.load_slice_called)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 429,
    "raw_source": "def test_iterate_with_load_slice_when_limit_applied\n    loader   = LoaderDrop.new([1, 2, 3, 4, 5])\n    assigns  = { 'items' => loader }\n    expected = '1'\n    template = '{% for item in items limit:1 %}{{item}}{% endfor %}'\n    assert_template_result(expected, template, assigns)\n    assert(!loader.each_called)\n    assert(loader.load_slice_called)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 439,
    "raw_source": "def test_iterate_with_load_slice_when_limit_and_offset_applied\n    loader   = LoaderDrop.new([1, 2, 3, 4, 5])\n    assigns  = { 'items' => loader }\n    expected = '34'\n    template = '{% for item in items offset:2 limit:2 %}{{item}}{% endfor %}'\n    assert_template_result(expected, template, assigns)\n    assert(!loader.each_called)\n    assert(loader.load_slice_called)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 449,
    "raw_source": "def test_iterate_with_load_slice_returns_same_results_as_without\n    loader         = LoaderDrop.new([1, 2, 3, 4, 5])\n    loader_assigns = { 'items' => loader }\n    array_assigns  = { 'items' => [1, 2, 3, 4, 5] }\n    expected       = '34'\n    template       = '{% for item in items offset:2 limit:2 %}{{item}}{% endfor %}'\n    assert_template_result(expected, template, loader_assigns)\n    assert_template_result(expected, template, array_assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/for_tag_test.rb",
    "start_line": 459,
    "raw_source": "def test_for_cleans_up_registers\n    context = Context.new(ErrorDrop.new)\n\n    assert_raises(StandardError) do\n      Liquid::Template.parse('{% for i in (1..2) %}{{ standard_error }}{% endfor %}').render!(context)\n    end\n\n    assert(context.registers[:for_stack].empty?)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 8,
    "raw_source": "def test_if\n    assert_template_result('  ', ' {% if false %} this text should not go into the output {% endif %} ')\n    assert_template_result(\n      '  this text should go into the output  ',\n      ' {% if true %} this text should go into the output {% endif %} ',\n    )\n    assert_template_result('  you rock ?', '{% if false %} you suck {% endif %} {% if true %} you rock {% endif %}?')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 17,
    "raw_source": "def test_literal_comparisons\n    assert_template_result(' NO ', '{% assign v = false %}{% if v %} YES {% else %} NO {% endif %}')\n    assert_template_result(' YES ', '{% assign v = nil %}{% if v == nil %} YES {% else %} NO {% endif %}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 22,
    "raw_source": "def test_if_else\n    assert_template_result(' YES ', '{% if false %} NO {% else %} YES {% endif %}')\n    assert_template_result(' YES ', '{% if true %} YES {% else %} NO {% endif %}')\n    assert_template_result(' YES ', '{% if \"foo\" %} YES {% else %} NO {% endif %}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 28,
    "raw_source": "def test_if_boolean\n    assert_template_result(' YES ', '{% if var %} YES {% endif %}', { 'var' => true })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 32,
    "raw_source": "def test_if_or\n    assert_template_result(' YES ', '{% if a or b %} YES {% endif %}', { 'a' => true, 'b' => true })\n    assert_template_result(' YES ', '{% if a or b %} YES {% endif %}', { 'a' => true, 'b' => false })\n    assert_template_result(' YES ', '{% if a or b %} YES {% endif %}', { 'a' => false, 'b' => true })\n    assert_template_result('',      '{% if a or b %} YES {% endif %}', { 'a' => false, 'b' => false })\n\n    assert_template_result(' YES ', '{% if a or b or c %} YES {% endif %}', { 'a' => false, 'b' => false, 'c' => true })\n    assert_template_result('',      '{% if a or b or c %} YES {% endif %}', { 'a' => false, 'b' => false, 'c' => false })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 42,
    "raw_source": "def test_if_or_with_operators\n    assert_template_result(' YES ', '{% if a == true or b == true %} YES {% endif %}', { 'a' => true, 'b' => true })\n    assert_template_result(' YES ', '{% if a == true or b == false %} YES {% endif %}', { 'a' => true, 'b' => true })\n    assert_template_result('', '{% if a == false or b == false %} YES {% endif %}', { 'a' => true, 'b' => true })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 48,
    "raw_source": "def test_comparison_of_strings_containing_and_or_or\n    awful_markup = \"a == 'and' and b == 'or' and c == 'foo and bar' and d == 'bar or baz' and e == 'foo' and foo and bar\"\n    assigns      = { 'a' => 'and', 'b' => 'or', 'c' => 'foo and bar', 'd' => 'bar or baz', 'e' => 'foo', 'foo' => true, 'bar' => true }\n    assert_template_result(' YES ', \"{% if #{awful_markup} %} YES {% endif %}\", assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 54,
    "raw_source": "def test_comparison_of_expressions_starting_with_and_or_or\n    assigns = { 'order' => { 'items_count' => 0 }, 'android' => { 'name' => 'Roy' } }\n    assert_template_result(\n      \"YES\",\n      \"{% if android.name == 'Roy' %}YES{% endif %}\",\n      assigns,\n    )\n    assert_template_result(\n      \"YES\",\n      \"{% if order.items_count == 0 %}YES{% endif %}\",\n      assigns,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 68,
    "raw_source": "def test_if_and\n    assert_template_result(' YES ', '{% if true and true %} YES {% endif %}')\n    assert_template_result('', '{% if false and true %} YES {% endif %}')\n    assert_template_result('', '{% if true and false %} YES {% endif %}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 74,
    "raw_source": "def test_hash_miss_generates_false\n    assert_template_result('', '{% if foo.bar %} NO {% endif %}', { 'foo' => {} })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 78,
    "raw_source": "def test_if_from_variable\n    assert_template_result('', '{% if var %} NO {% endif %}', { 'var' => false })\n    assert_template_result('', '{% if var %} NO {% endif %}', { 'var' => nil })\n    assert_template_result('', '{% if foo.bar %} NO {% endif %}', { 'foo' => { 'bar' => false } })\n    assert_template_result('', '{% if foo.bar %} NO {% endif %}', { 'foo' => {} })\n    assert_template_result('', '{% if foo.bar %} NO {% endif %}', { 'foo' => nil })\n    assert_template_result('', '{% if foo.bar %} NO {% endif %}', { 'foo' => true })\n\n    assert_template_result(' YES ', '{% if var %} YES {% endif %}', { 'var' => \"text\" })\n    assert_template_result(' YES ', '{% if var %} YES {% endif %}', { 'var' => true })\n    assert_template_result(' YES ', '{% if var %} YES {% endif %}', { 'var' => 1 })\n    assert_template_result(' YES ', '{% if var %} YES {% endif %}', { 'var' => {} })\n    assert_template_result(' YES ', '{% if var %} YES {% endif %}', { 'var' => [] })\n    assert_template_result(' YES ', '{% if \"foo\" %} YES {% endif %}')\n    assert_template_result(' YES ', '{% if foo.bar %} YES {% endif %}', { 'foo' => { 'bar' => true } })\n    assert_template_result(' YES ', '{% if foo.bar %} YES {% endif %}', { 'foo' => { 'bar' => \"text\" } })\n    assert_template_result(' YES ', '{% if foo.bar %} YES {% endif %}', { 'foo' => { 'bar' => 1 } })\n    assert_template_result(' YES ', '{% if foo.bar %} YES {% endif %}', { 'foo' => { 'bar' => {} } })\n    assert_template_result(' YES ', '{% if foo.bar %} YES {% endif %}', { 'foo' => { 'bar' => [] } })\n\n    assert_template_result(' YES ', '{% if var %} NO {% else %} YES {% endif %}', { 'var' => false })\n    assert_template_result(' YES ', '{% if var %} NO {% else %} YES {% endif %}', { 'var' => nil })\n    assert_template_result(' YES ', '{% if var %} YES {% else %} NO {% endif %}', { 'var' => true })\n    assert_template_result(' YES ', '{% if \"foo\" %} YES {% else %} NO {% endif %}', { 'var' => \"text\" })\n\n    assert_template_result(' YES ', '{% if foo.bar %} NO {% else %} YES {% endif %}', { 'foo' => { 'bar' => false } })\n    assert_template_result(' YES ', '{% if foo.bar %} YES {% else %} NO {% endif %}', { 'foo' => { 'bar' => true } })\n    assert_template_result(' YES ', '{% if foo.bar %} YES {% else %} NO {% endif %}', { 'foo' => { 'bar' => \"text\" } })\n    assert_template_result(' YES ', '{% if foo.bar %} NO {% else %} YES {% endif %}', { 'foo' => { 'notbar' => true } })\n    assert_template_result(' YES ', '{% if foo.bar %} NO {% else %} YES {% endif %}', { 'foo' => {} })\n    assert_template_result(' YES ', '{% if foo.bar %} NO {% else %} YES {% endif %}', { 'notfoo' => { 'bar' => true } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 111,
    "raw_source": "def test_nested_if\n    assert_template_result('', '{% if false %}{% if false %} NO {% endif %}{% endif %}')\n    assert_template_result('', '{% if false %}{% if true %} NO {% endif %}{% endif %}')\n    assert_template_result('', '{% if true %}{% if false %} NO {% endif %}{% endif %}')\n    assert_template_result(' YES ', '{% if true %}{% if true %} YES {% endif %}{% endif %}')\n\n    assert_template_result(' YES ', '{% if true %}{% if true %} YES {% else %} NO {% endif %}{% else %} NO {% endif %}')\n    assert_template_result(' YES ', '{% if true %}{% if false %} NO {% else %} YES {% endif %}{% else %} NO {% endif %}')\n    assert_template_result(' YES ', '{% if false %}{% if true %} NO {% else %} NONO {% endif %}{% else %} YES {% endif %}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 122,
    "raw_source": "def test_comparisons_on_null\n    assert_template_result('', '{% if null < 10 %} NO {% endif %}')\n    assert_template_result('', '{% if null <= 10 %} NO {% endif %}')\n    assert_template_result('', '{% if null >= 10 %} NO {% endif %}')\n    assert_template_result('', '{% if null > 10 %} NO {% endif %}')\n\n    assert_template_result('', '{% if 10 < null %} NO {% endif %}')\n    assert_template_result('', '{% if 10 <= null %} NO {% endif %}')\n    assert_template_result('', '{% if 10 >= null %} NO {% endif %}')\n    assert_template_result('', '{% if 10 > null %} NO {% endif %}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 134,
    "raw_source": "def test_else_if\n    assert_template_result('0', '{% if 0 == 0 %}0{% elsif 1 == 1%}1{% else %}2{% endif %}')\n    assert_template_result('1', '{% if 0 != 0 %}0{% elsif 1 == 1%}1{% else %}2{% endif %}')\n    assert_template_result('2', '{% if 0 != 0 %}0{% elsif 1 != 1%}1{% else %}2{% endif %}')\n\n    assert_template_result('elsif', '{% if false %}if{% elsif true %}elsif{% endif %}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 142,
    "raw_source": "def test_syntax_error_no_variable\n    assert_raises(SyntaxError) { assert_template_result('', '{% if jerry == 1 %}') }\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 146,
    "raw_source": "def test_syntax_error_no_expression\n    assert_raises(SyntaxError) { assert_template_result('', '{% if %}') }\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 150,
    "raw_source": "def test_if_with_custom_condition\n    original_op = Condition.operators['contains']\n    Condition.operators['contains'] = :[]\n\n    assert_template_result('yes', %({% if 'bob' contains 'o' %}yes{% endif %}))\n    assert_template_result('no', %({% if 'bob' contains 'f' %}yes{% else %}no{% endif %}))\n  ensure\n    Condition.operators['contains'] = original_op\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 160,
    "raw_source": "def test_operators_are_ignored_unless_isolated\n    original_op = Condition.operators['contains']\n    Condition.operators['contains'] = :[]\n\n    assert_template_result(\n      'yes',\n      %({% if 'gnomeslab-and-or-liquid' contains 'gnomeslab-and-or-liquid' %}yes{% endif %}),\n    )\n  ensure\n    Condition.operators['contains'] = original_op\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 172,
    "raw_source": "def test_operators_are_whitelisted\n    assert_raises(SyntaxError) do\n      assert_template_result('', %({% if 1 or throw or or 1 %}yes{% endif %}))\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/if_else_tag_test.rb",
    "start_line": 178,
    "raw_source": "def test_multiple_conditions\n    tpl = \"{% if a or b and c %}true{% else %}false{% endif %}\"\n\n    tests = {\n      [true, true, true] => true,\n      [true, true, false] => true,\n      [true, false, true] => true,\n      [true, false, false] => true,\n      [false, true, true] => true,\n      [false, true, false] => false,\n      [false, false, true] => false,\n      [false, false, false] => false,\n    }\n\n    tests.each do |vals, expected|\n      a, b, c = vals\n      assigns = { 'a' => a, 'b' => b, 'c' => c }\n      assert_template_result(expected.to_s, tpl, assigns, message: assigns.to_s)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 11,
    "raw_source": "def read_template_file(template_path)\n    PARTIALS[template_path] || template_path\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 17,
    "raw_source": "def read_template_file(_template_path)\n    'from OtherFileSystem'\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 24,
    "raw_source": "def read_template_file(_template_path)\n    @count ||= 0\n    @count  += 1\n    'from CountingFileSystem'\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 34,
    "raw_source": "def initialize(tag_name, markup, tokens)\n    markup =~ Syntax\n    @template_name = Regexp.last_match(1)\n    super\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 40,
    "raw_source": "def parse(tokens)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 43,
    "raw_source": "def render_to_output_buffer(_context, output)\n    output << @template_name[1..-2]\n    output\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 52,
    "raw_source": "def test_include_tag_looks_for_file_system_in_registers_first\n    assert_equal(\n      'from OtherFileSystem',\n      Template.parse(\"{% include 'pick_a_source' %}\").render!({}, registers: { file_system: OtherFileSystem.new }),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 59,
    "raw_source": "def test_include_tag_with\n    assert_template_result(\n      \"Product: Draft 151cm \",\n      \"{% include 'product' with products[0] %}\",\n      { \"products\" => [{ 'title' => 'Draft 151cm' }, { 'title' => 'Element 155cm' }] },\n      partials: { \"product\" => \"Product: {{ product.title }} \" },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 68,
    "raw_source": "def test_include_tag_with_alias\n    assert_template_result(\n      \"Product: Draft 151cm \",\n      \"{% include 'product_alias' with products[0] as product %}\",\n      { \"products\" => [{ 'title' => 'Draft 151cm' }, { 'title' => 'Element 155cm' }] },\n      partials: { \"product_alias\" => \"Product: {{ product.title }} \" },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 77,
    "raw_source": "def test_include_tag_for_alias\n    assert_template_result(\n      \"Product: Draft 151cm Product: Element 155cm \",\n      \"{% include 'product_alias' for products as product %}\",\n      { \"products\" => [{ 'title' => 'Draft 151cm' }, { 'title' => 'Element 155cm' }] },\n      partials: { \"product_alias\" => \"Product: {{ product.title }} \" },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 86,
    "raw_source": "def test_include_tag_with_default_name\n    assert_template_result(\n      \"Product: Draft 151cm \",\n      \"{% include 'product' %}\",\n      { \"product\" => { 'title' => 'Draft 151cm' } },\n      partials: { \"product\" => \"Product: {{ product.title }} \" },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 95,
    "raw_source": "def test_include_tag_for\n    assert_template_result(\n      \"Product: Draft 151cm Product: Element 155cm \",\n      \"{% include 'product' for products %}\",\n      { \"products\" => [{ 'title' => 'Draft 151cm' }, { 'title' => 'Element 155cm' }] },\n      partials: { \"product\" => \"Product: {{ product.title }} \" },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 104,
    "raw_source": "def test_include_tag_with_local_variables\n    assert_template_result(\n      \"Locale: test123 \",\n      \"{% include 'locale_variables' echo1: 'test123' %}\",\n      partials: { \"locale_variables\" => \"Locale: {{echo1}} {{echo2}}\" },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 112,
    "raw_source": "def test_include_tag_with_multiple_local_variables\n    assert_template_result(\n      \"Locale: test123 test321\",\n      \"{% include 'locale_variables' echo1: 'test123', echo2: 'test321' %}\",\n      partials: { \"locale_variables\" => \"Locale: {{echo1}} {{echo2}}\" },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 120,
    "raw_source": "def test_include_tag_with_multiple_local_variables_from_context\n    assert_template_result(\n      \"Locale: test123 test321\",\n      \"{% include 'locale_variables' echo1: echo1, echo2: more_echos.echo2 %}\",\n      { 'echo1' => 'test123', 'more_echos' => { \"echo2\" => 'test321' } },\n      partials: { \"locale_variables\" => \"Locale: {{echo1}} {{echo2}}\" },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 129,
    "raw_source": "def test_included_templates_assigns_variables\n    assert_template_result(\n      \"bar\",\n      \"{% include 'assignments' %}{{ foo }}\",\n      partials: { 'assignments' => \"{% assign foo = 'bar' %}\" },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 137,
    "raw_source": "def test_nested_include_tag\n    partials = { \"body\" => \"body {% include 'body_detail' %}\", \"body_detail\" => \"body_detail\" }\n    assert_template_result(\"body body_detail\", \"{% include 'body' %}\", partials: partials)\n\n    partials = partials.merge({\n      \"nested_template\" => \"{% include 'header' %} {% include 'body' %} {% include 'footer' %}\",\n      \"header\" => \"header\",\n      \"footer\" => \"footer\",\n    })\n    assert_template_result(\"header body body_detail footer\", \"{% include 'nested_template' %}\", partials: partials)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 149,
    "raw_source": "def test_nested_include_with_variable\n    partials = {\n      \"nested_product_template\" => \"Product: {{ nested_product_template.title }} {%include 'details'%} \",\n      \"details\" => \"details\",\n    }\n\n    assert_template_result(\n      \"Product: Draft 151cm details \",\n      \"{% include 'nested_product_template' with product %}\",\n      { \"product\" => { \"title\" => 'Draft 151cm' } },\n      partials: partials,\n    )\n\n    assert_template_result(\n      \"Product: Draft 151cm details Product: Element 155cm details \",\n      \"{% include 'nested_product_template' for products %}\",\n      { \"products\" => [{ \"title\" => 'Draft 151cm' }, { \"title\" => 'Element 155cm' }] },\n      partials: partials,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 170,
    "raw_source": "def test_recursively_included_template_does_not_produce_endless_loop\n    infinite_file_system = Class.new do\n      def read_template_file(_template_path)\n        \"-{% include 'loop' %}\"\n      end\n    end\n\n    env = Liquid::Environment.build(file_system: infinite_file_system.new)\n\n    assert_raises(Liquid::StackLevelError) do\n      Template.parse(\"{% include 'loop' %}\", environment: env).render!\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 172,
    "raw_source": "def read_template_file(_template_path)\n        \"-{% include 'loop' %}\"\n      end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 184,
    "raw_source": "def test_dynamically_choosen_template\n    assert_template_result(\n      \"Test123\",\n      \"{% include template %}\",\n      { \"template\" => 'Test123' },\n      partials: { \"Test123\" => \"Test123\" },\n    )\n\n    assert_template_result(\n      \"Test321\",\n      \"{% include template %}\",\n      { \"template\" => 'Test321' },\n      partials: { \"Test321\" => \"Test321\" },\n    )\n\n    assert_template_result(\n      \"Product: Draft 151cm \",\n      \"{% include template for product %}\",\n      { \"template\" => 'product', 'product' => { 'title' => 'Draft 151cm' } },\n      partials: { \"product\" => \"Product: {{ product.title }} \" },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 207,
    "raw_source": "def test_include_tag_caches_second_read_of_same_partial\n    file_system = CountingFileSystem.new\n    environment = Liquid::Environment.build(file_system: file_system)\n    assert_equal(\n      'from CountingFileSystemfrom CountingFileSystem',\n      Template.parse(\"{% include 'pick_a_source' %}{% include 'pick_a_source' %}\", environment: environment).render!({}, registers: { file_system: file_system }),\n    )\n    assert_equal(1, file_system.count)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 217,
    "raw_source": "def test_include_tag_doesnt_cache_partials_across_renders\n    file_system = CountingFileSystem.new\n    assert_equal(\n      'from CountingFileSystem',\n      Template.parse(\"{% include 'pick_a_source' %}\").render!({}, registers: { file_system: file_system }),\n    )\n    assert_equal(1, file_system.count)\n\n    assert_equal(\n      'from CountingFileSystem',\n      Template.parse(\"{% include 'pick_a_source' %}\").render!({}, registers: { file_system: file_system }),\n    )\n    assert_equal(2, file_system.count)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 232,
    "raw_source": "def test_include_tag_within_if_statement\n    assert_template_result(\n      \"foo_if_true\",\n      \"{% if true %}{% include 'foo_if_true' %}{% endif %}\",\n      partials: { \"foo_if_true\" => \"foo_if_true\" },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 240,
    "raw_source": "def test_custom_include_tag\n    original_tag = Liquid::Template.tags['include']\n    Liquid::Template.tags['include'] = CustomInclude\n    begin\n      assert_equal(\n        \"custom_foo\",\n        Template.parse(\"{% include 'custom_foo' %}\").render!,\n      )\n    ensure\n      Liquid::Template.tags['include'] = original_tag\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 253,
    "raw_source": "def test_custom_include_tag_within_if_statement\n    original_tag = Liquid::Template.tags['include']\n    Liquid::Template.tags['include'] = CustomInclude\n    begin\n      assert_equal(\n        \"custom_foo_if_true\",\n        Template.parse(\"{% if true %}{% include 'custom_foo_if_true' %}{% endif %}\").render!,\n      )\n    ensure\n      Liquid::Template.tags['include'] = original_tag\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 266,
    "raw_source": "def test_does_not_add_error_in_strict_mode_for_missing_variable\n    env = Liquid::Environment.build(file_system: TestFileSystem.new)\n\n    a = Liquid::Template.parse(' {% include \"nested_template\" %}', environment: env)\n    a.render!\n    assert_empty(a.errors)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 274,
    "raw_source": "def test_passing_options_to_included_templates\n    env = Liquid::Environment.build(file_system: TestFileSystem.new)\n\n    assert_raises(Liquid::SyntaxError) do\n      Template.parse(\"{% include template %}\", error_mode: :strict, environment: env).render!(\"template\" => '{{ \"X\" || downcase }}')\n    end\n    with_error_mode(:lax) do\n      assert_equal('x', Template.parse(\"{% include template %}\", error_mode: :strict, include_options_blacklist: true, environment: env).render!(\"template\" => '{{ \"X\" || downcase }}'))\n    end\n    assert_raises(Liquid::SyntaxError) do\n      Template.parse(\"{% include template %}\", error_mode: :strict, include_options_blacklist: [:locale], environment: env).render!(\"template\" => '{{ \"X\" || downcase }}')\n    end\n    with_error_mode(:lax) do\n      assert_equal('x', Template.parse(\"{% include template %}\", error_mode: :strict, include_options_blacklist: [:error_mode], environment: env).render!(\"template\" => '{{ \"X\" || downcase }}'))\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 291,
    "raw_source": "def test_render_raise_argument_error_when_template_is_undefined\n    assert_template_result(\n      \"Liquid error (line 1): Argument error in tag 'include' - Illegal template name\",\n      \"{% include undefined_variable %}\",\n      render_errors: true,\n    )\n\n    assert_template_result(\n      \"Liquid error (line 1): Argument error in tag 'include' - Illegal template name\",\n      \"{% include nil %}\",\n      render_errors: true,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 305,
    "raw_source": "def test_render_raise_argument_error_when_template_is_not_a_string\n    assert_template_result(\n      \"Liquid error (line 1): Argument error in tag 'include' - Illegal template name\",\n      \"{% include 123 %}\",\n      render_errors: true,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 313,
    "raw_source": "def test_including_via_variable_value\n    assert_template_result(\n      \"from TestFileSystem\",\n      \"{% assign page = 'pick_a_source' %}{% include page %}\",\n      partials: { \"pick_a_source\" => \"from TestFileSystem\" },\n    )\n\n    partials = { \"product\" => \"Product: {{ product.title }} \" }\n\n    assert_template_result(\n      \"Product: Draft 151cm \",\n      \"{% assign page = 'product' %}{% include page %}\",\n      { \"product\" => { 'title' => 'Draft 151cm' } },\n      partials: partials,\n    )\n\n    assert_template_result(\n      \"Product: Draft 151cm \",\n      \"{% assign page = 'product' %}{% include page for foo %}\",\n      { \"foo\" => { 'title' => 'Draft 151cm' } },\n      partials: partials,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 337,
    "raw_source": "def test_including_with_strict_variables\n    env = Liquid::Environment.build(\n      file_system: StubFileSystem.new('simple' => 'simple'),\n    )\n\n    template = Liquid::Template.parse(\"{% include 'simple' %}\", error_mode: :warn, environment: env)\n    template.render(nil, strict_variables: true)\n\n    assert_equal([], template.errors)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 348,
    "raw_source": "def test_break_through_include\n    assert_template_result(\"1\", \"{% for i in (1..3) %}{{ i }}{% break %}{{ i }}{% endfor %}\")\n    assert_template_result(\n      \"1\",\n      \"{% for i in (1..3) %}{{ i }}{% include 'break' %}{{ i }}{% endfor %}\",\n      partials: { 'break' => \"{% break %}\" },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 357,
    "raw_source": "def test_render_tag_renders_error_with_template_name\n    assert_template_result(\n      'Liquid error (foo line 1): standard error',\n      \"{% include 'foo' with errors %}\",\n      { 'errors' => ErrorDrop.new },\n      partials: { 'foo' => '{{ foo.standard_error }}' },\n      render_errors: true,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/include_tag_test.rb",
    "start_line": 367,
    "raw_source": "def test_render_tag_renders_error_with_template_name_from_template_factory\n    assert_template_result(\n      'Liquid error (some/path/foo line 1): standard error',\n      \"{% include 'foo' with errors %}\",\n      { 'errors' => ErrorDrop.new },\n      partials: { 'foo' => '{{ foo.standard_error }}' },\n      template_factory: StubTemplateFactory.new,\n      render_errors: true,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/increment_tag_test.rb",
    "start_line": 8,
    "raw_source": "def test_inc\n    assert_template_result('0 1', '{%increment port %} {{ port }}')\n    assert_template_result(' 0 1 2', '{{port}} {%increment port %} {%increment port%} {{port}}')\n    assert_template_result(\n      '0 0 1 2 1',\n      '{%increment port %} {%increment starboard%} ' \\\n      '{%increment port %} {%increment port%} ' \\\n      '{%increment starboard %}',\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/increment_tag_test.rb",
    "start_line": 19,
    "raw_source": "def test_dec\n    assert_template_result('-1 -1', '{%decrement port %} {{ port }}', { 'port' => 10 })\n    assert_template_result(' -1 -2 -2', '{{port}} {%decrement port %} {%decrement port%} {{port}}')\n    assert_template_result(\n      '0 1 2 0 3 1 1 3',\n      '{%increment starboard %} {%increment starboard%} {%increment starboard%} ' \\\n      '{%increment port %} {%increment starboard%} ' \\\n      '{%increment port %} {%decrement port%} ' \\\n      '{%decrement starboard %}',\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/inline_comment_test.rb",
    "start_line": 8,
    "raw_source": "def test_inline_comment_returns_nothing\n    assert_template_result('', '{%- # this is an inline comment -%}')\n    assert_template_result('', '{%-# this is an inline comment -%}')\n    assert_template_result('', '{% # this is an inline comment %}')\n    assert_template_result('', '{%# this is an inline comment %}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/inline_comment_test.rb",
    "start_line": 15,
    "raw_source": "def test_inline_comment_does_not_require_a_space_after_the_pound_sign\n    assert_template_result('', '{%#this is an inline comment%}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/inline_comment_test.rb",
    "start_line": 19,
    "raw_source": "def test_liquid_inline_comment_returns_nothing\n    assert_template_result('Hey there, how are you doing today?', <<~LIQUID)\n      {%- liquid\n        # This is how you'd write a block comment in a liquid tag.\n        # It looks a lot like what you'd have in ruby.\n\n        # You can use it as inline documentation in your\n        # liquid blocks to explain why you're doing something.\n        echo \"Hey there, \"\n\n        # It won't affect the output.\n        echo \"how are you doing today?\"\n      -%}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/inline_comment_test.rb",
    "start_line": 35,
    "raw_source": "def test_inline_comment_can_be_written_on_multiple_lines\n    assert_template_result('', <<~LIQUID)\n      {%-\n        # That kind of block comment is also allowed.\n        # It would only be a stylistic difference.\n\n        # Much like JavaScript's /* */ comments and their\n        # leading * on new lines.\n      -%}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/inline_comment_test.rb",
    "start_line": 47,
    "raw_source": "def test_inline_comment_multiple_pound_signs\n    assert_template_result('', <<~LIQUID)\n      {%- liquid\n        ######################################\n        # We support comments like this too. #\n        ######################################\n      -%}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/inline_comment_test.rb",
    "start_line": 57,
    "raw_source": "def test_inline_comments_require_the_pound_sign_on_every_new_line\n    assert_match_syntax_error(\"Each line of comments must be prefixed by the '#' character\", <<~LIQUID)\n      {%-\n        # some comment\n        echo 'hello world'\n      -%}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/inline_comment_test.rb",
    "start_line": 66,
    "raw_source": "def test_inline_comment_does_not_support_nested_tags\n    assert_template_result(' -%}', \"{%- # {% echo 'hello world' %} -%}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/liquid_tag_test.rb",
    "start_line": 8,
    "raw_source": "def test_liquid_tag\n    assert_template_result('1 2 3', <<~LIQUID, { 'array' => [1, 2, 3] })\n      {%- liquid\n        echo array | join: \" \"\n      -%}\n    LIQUID\n\n    assert_template_result('1 2 3', <<~LIQUID, { 'array' => [1, 2, 3] })\n      {%- liquid\n        for value in array\n          echo value\n          unless forloop.last\n            echo \" \"\n          endunless\n        endfor\n      -%}\n    LIQUID\n\n    assert_template_result('4 8 12 6', <<~LIQUID, { 'array' => [1, 2, 3] })\n      {%- liquid\n        for value in array\n          assign double_value = value | times: 2\n          echo double_value | times: 2\n          unless forloop.last\n            echo \" \"\n          endunless\n        endfor\n\n        echo \" \"\n        echo double_value\n      -%}\n    LIQUID\n\n    assert_template_result('abc', <<~LIQUID)\n      {%- liquid echo \"a\" -%}\n      b\n      {%- liquid echo \"c\" -%}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/liquid_tag_test.rb",
    "start_line": 48,
    "raw_source": "def test_liquid_tag_errors\n    assert_match_syntax_error(\"syntax error (line 1): Unknown tag 'error'\", <<~LIQUID)\n      {%- liquid error no such tag -%}\n    LIQUID\n\n    assert_match_syntax_error(\"syntax error (line 7): Unknown tag 'error'\", <<~LIQUID)\n      {{ test }}\n\n      {%-\n      liquid\n        for value in array\n\n          error no such tag\n        endfor\n      -%}\n    LIQUID\n\n    assert_match_syntax_error(\"syntax error (line 2): Unknown tag '!!! the guards are vigilant'\", <<~LIQUID)\n      {%- liquid\n        !!! the guards are vigilant\n      -%}\n    LIQUID\n\n    assert_match_syntax_error(\"syntax error (line 4): 'for' tag was never closed\", <<~LIQUID)\n      {%- liquid\n        for value in array\n          echo 'forgot to close the for tag'\n      -%}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/liquid_tag_test.rb",
    "start_line": 79,
    "raw_source": "def test_line_number_is_correct_after_a_blank_token\n    assert_match_syntax_error(\"syntax error (line 3): Unknown tag 'error'\", \"{% liquid echo ''\\n\\n error %}\")\n    assert_match_syntax_error(\"syntax error (line 3): Unknown tag 'error'\", \"{% liquid echo ''\\n  \\n error %}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/liquid_tag_test.rb",
    "start_line": 84,
    "raw_source": "def test_nested_liquid_tag\n    assert_template_result('good', <<~LIQUID)\n      {%- if true %}\n        {%- liquid\n          echo \"good\"\n        %}\n      {%- endif -%}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/liquid_tag_test.rb",
    "start_line": 94,
    "raw_source": "def test_cannot_open_blocks_living_past_a_liquid_tag\n    assert_match_syntax_error(\"syntax error (line 3): 'if' tag was never closed\", <<~LIQUID)\n      {%- liquid\n        if true\n      -%}\n      {%- endif -%}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/liquid_tag_test.rb",
    "start_line": 103,
    "raw_source": "def test_cannot_close_blocks_created_before_a_liquid_tag\n    assert_match_syntax_error(\"syntax error (line 3): 'endif' is not a valid delimiter for liquid tags. use %}\", <<~LIQUID)\n      {%- if true -%}\n      42\n      {%- liquid endif -%}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/liquid_tag_test.rb",
    "start_line": 111,
    "raw_source": "def test_liquid_tag_in_raw\n    assert_template_result(\"{% liquid echo 'test' %}\\n\", <<~LIQUID)\n      {% raw %}{% liquid echo 'test' %}{% endraw %}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/liquid_tag_test.rb",
    "start_line": 117,
    "raw_source": "def test_nested_liquid_tags\n    assert_template_result('good', <<~LIQUID)\n      {%- liquid\n        liquid\n          if true\n            echo \"good\"\n          endif\n      -%}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/liquid_tag_test.rb",
    "start_line": 128,
    "raw_source": "def test_nested_liquid_tags_on_same_line\n    assert_template_result('good', <<~LIQUID)\n      {%- liquid liquid liquid echo \"good\" -%}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/liquid_tag_test.rb",
    "start_line": 134,
    "raw_source": "def test_nested_liquid_liquid_is_not_skipped_if_used_in_non_tag_position\n    assert_template_result('liquid', <<~LIQUID, { 'liquid' => 'liquid' })\n      {%- liquid liquid liquid echo liquid -%}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/liquid_tag_test.rb",
    "start_line": 140,
    "raw_source": "def test_next_liquid_with_unclosed_if_tag\n    assert_match_syntax_error(\"Liquid syntax error (line 2): 'if' tag was never closed\", <<~LIQUID)\n      {%- liquid\n        liquid if true\n          echo \"good\"\n        endif\n      -%}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/raw_tag_test.rb",
    "start_line": 8,
    "raw_source": "def test_tag_in_raw\n    assert_template_result(\n      '{% comment %} test {% endcomment %}',\n      '{% raw %}{% comment %} test {% endcomment %}{% endraw %}',\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/raw_tag_test.rb",
    "start_line": 15,
    "raw_source": "def test_output_in_raw\n    assert_template_result('>{{ test }}<', '> {%- raw -%}{{ test }}{%- endraw -%} <')\n    assert_template_result(\"> inner  <\", \"> {%- raw -%} inner {%- endraw %} <\")\n    assert_template_result(\"> inner <\", \"> {%- raw -%} inner {%- endraw -%} <\")\n    assert_template_result(\"{Hello}\", \"{% raw %}{{% endraw %}Hello{% raw %}}{% endraw %}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/raw_tag_test.rb",
    "start_line": 22,
    "raw_source": "def test_open_tag_in_raw\n    assert_template_result(' Foobar {% invalid ', '{% raw %} Foobar {% invalid {% endraw %}')\n    assert_template_result(' Foobar invalid %} ', '{% raw %} Foobar invalid %} {% endraw %}')\n    assert_template_result(' Foobar {{ invalid ', '{% raw %} Foobar {{ invalid {% endraw %}')\n    assert_template_result(' Foobar invalid }} ', '{% raw %} Foobar invalid }} {% endraw %}')\n    assert_template_result(' Foobar {% invalid {% {% endraw ', '{% raw %} Foobar {% invalid {% {% endraw {% endraw %}')\n    assert_template_result(' Foobar {% {% {% ', '{% raw %} Foobar {% {% {% {% endraw %}')\n    assert_template_result(' test {% raw %} {% endraw %}', '{% raw %} test {% raw %} {% {% endraw %}endraw %}')\n    assert_template_result(' Foobar {{ invalid 1', '{% raw %} Foobar {{ invalid {% endraw %}{{ 1 }}')\n    assert_template_result(' Foobar {% foo {% bar %}', '{% raw %} Foobar {% foo {% bar %}{% endraw %}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/raw_tag_test.rb",
    "start_line": 34,
    "raw_source": "def test_invalid_raw\n    assert_match_syntax_error(/tag was never closed/, '{% raw %} foo')\n    assert_match_syntax_error(/Valid syntax/, '{% raw } foo {% endraw %}')\n    assert_match_syntax_error(/Valid syntax/, '{% raw } foo %}{% endraw %}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 8,
    "raw_source": "def test_render_with_no_arguments\n    assert_template_result(\n      'rendered content',\n      '{% render \"source\" %}',\n      partials: { 'source' => 'rendered content' },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 16,
    "raw_source": "def test_render_tag_looks_for_file_system_in_registers_first\n    assert_template_result(\n      'from register file system',\n      '{% render \"pick_a_source\" %}',\n      partials: { 'pick_a_source' => 'from register file system' },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 24,
    "raw_source": "def test_render_passes_named_arguments_into_inner_scope\n    assert_template_result(\n      'My Product',\n      '{% render \"product\", inner_product: outer_product %}',\n      { 'outer_product' => { 'title' => 'My Product' } },\n      partials: { 'product' => '{{ inner_product.title }}' },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 33,
    "raw_source": "def test_render_accepts_literals_as_arguments\n    assert_template_result(\n      '123',\n      '{% render \"snippet\", price: 123 %}',\n      partials: { 'snippet' => '{{ price }}' },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 41,
    "raw_source": "def test_render_accepts_multiple_named_arguments\n    assert_template_result(\n      '1 2',\n      '{% render \"snippet\", one: 1, two: 2 %}',\n      partials: { 'snippet' => '{{ one }} {{ two }}' },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 49,
    "raw_source": "def test_render_does_not_inherit_parent_scope_variables\n    assert_template_result(\n      '',\n      '{% assign outer_variable = \"should not be visible\" %}{% render \"snippet\" %}',\n      partials: { 'snippet' => '{{ outer_variable }}' },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 57,
    "raw_source": "def test_render_does_not_inherit_variable_with_same_name_as_snippet\n    assert_template_result(\n      '',\n      \"{% assign snippet = 'should not be visible' %}{% render 'snippet' %}\",\n      partials: { 'snippet' => '{{ snippet }}' },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 65,
    "raw_source": "def test_render_does_not_mutate_parent_scope\n    assert_template_result(\n      '',\n      \"{% render 'snippet' %}{{ inner }}\",\n      partials: { 'snippet' => '{% assign inner = 1 %}' },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 73,
    "raw_source": "def test_nested_render_tag\n    assert_template_result(\n      'one two',\n      \"{% render 'one' %}\",\n      partials: {\n        'one' => \"one {% render 'two' %}\",\n        'two' => 'two',\n      },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 84,
    "raw_source": "def test_recursively_rendered_template_does_not_produce_endless_loop\n    env = Liquid::Environment.build(\n      file_system: StubFileSystem.new('loop' => '{% render \"loop\" %}'),\n    )\n\n    assert_raises(Liquid::StackLevelError) do\n      Template.parse('{% render \"loop\" %}', environment: env).render!\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 94,
    "raw_source": "def test_sub_contexts_count_towards_the_same_recursion_limit\n    env = Liquid::Environment.build(\n      file_system: StubFileSystem.new('loop_render' => '{% render \"loop_render\" %}'),\n    )\n\n    assert_raises(Liquid::StackLevelError) do\n      Template.parse('{% render \"loop_render\" %}', environment: env).render!\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 104,
    "raw_source": "def test_dynamically_choosen_templates_are_not_allowed\n    assert_syntax_error(\"{% assign name = 'snippet' %}{% render name %}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 108,
    "raw_source": "def test_include_tag_caches_second_read_of_same_partial\n    file_system = StubFileSystem.new('snippet' => 'echo')\n    assert_equal(\n      'echoecho',\n      Template.parse('{% render \"snippet\" %}{% render \"snippet\" %}')\n      .render!({}, registers: { file_system: file_system }),\n    )\n    assert_equal(1, file_system.file_read_count)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 118,
    "raw_source": "def test_render_tag_doesnt_cache_partials_across_renders\n    file_system = StubFileSystem.new('snippet' => 'my message')\n\n    assert_equal(\n      'my message',\n      Template.parse('{% include \"snippet\" %}').render!({}, registers: { file_system: file_system }),\n    )\n    assert_equal(1, file_system.file_read_count)\n\n    assert_equal(\n      'my message',\n      Template.parse('{% include \"snippet\" %}').render!({}, registers: { file_system: file_system }),\n    )\n    assert_equal(2, file_system.file_read_count)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 134,
    "raw_source": "def test_render_tag_within_if_statement\n    assert_template_result(\n      'my message',\n      '{% if true %}{% render \"snippet\" %}{% endif %}',\n      partials: { 'snippet' => 'my message' },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 142,
    "raw_source": "def test_break_through_render\n    options = { partials: { 'break' => '{% break %}' } }\n    assert_template_result('1', '{% for i in (1..3) %}{{ i }}{% break %}{{ i }}{% endfor %}', **options)\n    assert_template_result('112233', '{% for i in (1..3) %}{{ i }}{% render \"break\" %}{{ i }}{% endfor %}', **options)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 148,
    "raw_source": "def test_increment_is_isolated_between_renders\n    assert_template_result(\n      '010',\n      '{% increment %}{% increment %}{% render \"incr\" %}',\n      partials: { 'incr' => '{% increment %}' },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 156,
    "raw_source": "def test_decrement_is_isolated_between_renders\n    assert_template_result(\n      '-1-2-1',\n      '{% decrement %}{% decrement %}{% render \"decr\" %}',\n      partials: { 'decr' => '{% decrement %}' },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 164,
    "raw_source": "def test_includes_will_not_render_inside_render_tag\n    assert_template_result(\n      'Liquid error (test_include line 1): include usage is not allowed in this context',\n      '{% render \"test_include\" %}',\n      render_errors: true,\n      partials: {\n        'foo' => 'bar',\n        'test_include' => '{% include \"foo\" %}',\n      },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 176,
    "raw_source": "def test_includes_will_not_render_inside_nested_sibling_tags\n    assert_template_result(\n      \"Liquid error (test_include line 1): include usage is not allowed in this context\" \\\n        \"Liquid error (nested_render_with_sibling_include line 1): include usage is not allowed in this context\",\n      '{% render \"nested_render_with_sibling_include\" %}',\n      partials: {\n        'foo' => 'bar',\n        'nested_render_with_sibling_include' => '{% render \"test_include\" %}{% include \"foo\" %}',\n        'test_include' => '{% include \"foo\" %}',\n      },\n      render_errors: true,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 190,
    "raw_source": "def test_render_tag_with\n    assert_template_result(\n      \"Product: Draft 151cm \",\n      \"{% render 'product' with products[0] %}\",\n      { \"products\" => [{ 'title' => 'Draft 151cm' }, { 'title' => 'Element 155cm' }] },\n      partials: {\n        'product' => \"Product: {{ product.title }} \",\n        'product_alias' => \"Product: {{ product.title }} \",\n      },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 202,
    "raw_source": "def test_render_tag_with_alias\n    assert_template_result(\n      \"Product: Draft 151cm \",\n      \"{% render 'product_alias' with products[0] as product %}\",\n      { \"products\" => [{ 'title' => 'Draft 151cm' }, { 'title' => 'Element 155cm' }] },\n      partials: {\n        'product' => \"Product: {{ product.title }} \",\n        'product_alias' => \"Product: {{ product.title }} \",\n      },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 214,
    "raw_source": "def test_render_tag_for_alias\n    assert_template_result(\n      \"Product: Draft 151cm Product: Element 155cm \",\n      \"{% render 'product_alias' for products as product %}\",\n      { \"products\" => [{ 'title' => 'Draft 151cm' }, { 'title' => 'Element 155cm' }] },\n      partials: {\n        'product' => \"Product: {{ product.title }} \",\n        'product_alias' => \"Product: {{ product.title }} \",\n      },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 226,
    "raw_source": "def test_render_tag_for\n    assert_template_result(\n      \"Product: Draft 151cm Product: Element 155cm \",\n      \"{% render 'product' for products %}\",\n      { \"products\" => [{ 'title' => 'Draft 151cm' }, { 'title' => 'Element 155cm' }] },\n      partials: {\n        'product' => \"Product: {{ product.title }} \",\n        'product_alias' => \"Product: {{ product.title }} \",\n      },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 238,
    "raw_source": "def test_render_tag_forloop\n    assert_template_result(\n      \"Product: Draft 151cm first  index:1 Product: Element 155cm  last index:2 \",\n      \"{% render 'product' for products %}\",\n      { \"products\" => [{ 'title' => 'Draft 151cm' }, { 'title' => 'Element 155cm' }] },\n      partials: {\n        'product' => \"Product: {{ product.title }} {% if forloop.first %}first{% endif %} {% if forloop.last %}last{% endif %} index:{{ forloop.index }} \",\n      },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 249,
    "raw_source": "def test_render_tag_for_drop\n    assert_template_result(\n      \"123\",\n      \"{% render 'loop' for loop as value %}\",\n      { \"loop\" => TestEnumerable.new },\n      partials: {\n        'loop' => \"{{ value.foo }}\",\n      },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 260,
    "raw_source": "def test_render_tag_with_drop\n    assert_template_result(\n      \"TestEnumerable\",\n      \"{% render 'loop' with loop as value %}\",\n      { \"loop\" => TestEnumerable.new },\n      partials: {\n        'loop' => \"{{ value }}\",\n      },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 271,
    "raw_source": "def test_render_tag_renders_error_with_template_name\n    assert_template_result(\n      'Liquid error (foo line 1): standard error',\n      \"{% render 'foo' with errors %}\",\n      { 'errors' => ErrorDrop.new },\n      partials: { 'foo' => '{{ foo.standard_error }}' },\n      render_errors: true,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/render_tag_test.rb",
    "start_line": 281,
    "raw_source": "def test_render_tag_renders_error_with_template_name_from_template_factory\n    assert_template_result(\n      'Liquid error (some/path/foo line 1): standard error',\n      \"{% render 'foo' with errors %}\",\n      { 'errors' => ErrorDrop.new },\n      partials: { 'foo' => '{{ foo.standard_error }}' },\n      template_factory: StubTemplateFactory.new,\n      render_errors: true,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 8,
    "raw_source": "def test_no_transform\n    assert_template_result(\n      'this text should come out of the template without change...',\n      'this text should come out of the template without change...',\n    )\n\n    assert_template_result('blah', 'blah')\n    assert_template_result('<blah>', '<blah>')\n    assert_template_result('|,.:', '|,.:')\n    assert_template_result('', '')\n\n    text = %(this shouldnt see any transformation either but has multiple lines\n              as you can clearly see here ...)\n    assert_template_result(text, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 24,
    "raw_source": "def test_has_a_block_which_does_nothing\n    assert_template_result(\n      %(the comment block should be removed  .. right?),\n      %(the comment block should be removed {%comment%} be gone.. {%endcomment%} .. right?),\n    )\n\n    assert_template_result('', '{%comment%}{%endcomment%}')\n    assert_template_result('', '{%comment%}{% endcomment %}')\n    assert_template_result('', '{% comment %}{%endcomment%}')\n    assert_template_result('', '{% comment %}{% endcomment %}')\n    assert_template_result('', '{%comment%}comment{%endcomment%}')\n    assert_template_result('', '{% comment %}comment{% endcomment %}')\n    assert_template_result('', '{% comment %} 1 {% comment %} 2 {% endcomment %} 3 {% endcomment %}')\n\n    assert_template_result('', '{%comment%}{%blabla%}{%endcomment%}')\n    assert_template_result('', '{% comment %}{% blabla %}{% endcomment %}')\n    assert_template_result('', '{%comment%}{% endif %}{%endcomment%}')\n    assert_template_result('', '{% comment %}{% endwhatever %}{% endcomment %}')\n    assert_template_result('', '{% comment %}{% raw %} {{%%%%}}  }} { {% endcomment %} {% comment {% endraw %} {% endcomment %}')\n    assert_template_result('', '{% comment %}{% \" %}{% endcomment %}')\n    assert_template_result('', '{% comment %}{%%}{% endcomment %}')\n\n    assert_template_result('foobar', 'foo{%comment%}comment{%endcomment%}bar')\n    assert_template_result('foobar', 'foo{% comment %}comment{% endcomment %}bar')\n    assert_template_result('foobar', 'foo{%comment%} comment {%endcomment%}bar')\n    assert_template_result('foobar', 'foo{% comment %} comment {% endcomment %}bar')\n\n    assert_template_result('foo  bar', 'foo {%comment%} {%endcomment%} bar')\n    assert_template_result('foo  bar', 'foo {%comment%}comment{%endcomment%} bar')\n    assert_template_result('foo  bar', 'foo {%comment%} comment {%endcomment%} bar')\n\n    assert_template_result('foobar', 'foo{%comment%}\n                                     {%endcomment%}bar')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 59,
    "raw_source": "def test_hyphenated_assign\n    assigns = { 'a-b' => '1' }\n    assert_template_result('a-b:1 a-b:2', 'a-b:{{a-b}} {%assign a-b = 2 %}a-b:{{a-b}}', assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 64,
    "raw_source": "def test_assign_with_colon_and_spaces\n    assigns = { 'var' => { 'a:b c' => { 'paged' => '1' } } }\n    assert_template_result('var2: 1', '{%assign var2 = var[\"a:b c\"].paged %}var2: {{var2}}', assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 69,
    "raw_source": "def test_capture\n    assigns = { 'var' => 'content' }\n    assert_template_result(\n      'content foo content foo ',\n      '{{ var2 }}{% capture var2 %}{{ var }} foo {% endcapture %}{{ var2 }}{{ var2 }}',\n      assigns,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 78,
    "raw_source": "def test_capture_detects_bad_syntax\n    assert_raises(SyntaxError) do\n      assert_template_result(\n        'content foo content foo ',\n        '{{ var2 }}{% capture %}{{ var }} foo {% endcapture %}{{ var2 }}{{ var2 }}',\n        { 'var' => 'content' },\n      )\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 88,
    "raw_source": "def test_case\n    assigns = { 'condition' => 2 }\n    assert_template_result(\n      ' its 2 ',\n      '{% case condition %}{% when 1 %} its 1 {% when 2 %} its 2 {% endcase %}',\n      assigns,\n    )\n\n    assigns = { 'condition' => 1 }\n    assert_template_result(\n      ' its 1 ',\n      '{% case condition %}{% when 1 %} its 1 {% when 2 %} its 2 {% endcase %}',\n      assigns,\n    )\n\n    assigns = { 'condition' => 3 }\n    assert_template_result(\n      '',\n      '{% case condition %}{% when 1 %} its 1 {% when 2 %} its 2 {% endcase %}',\n      assigns,\n    )\n\n    assigns = { 'condition' => \"string here\" }\n    assert_template_result(\n      ' hit ',\n      '{% case condition %}{% when \"string here\" %} hit {% endcase %}',\n      assigns,\n    )\n\n    assigns = { 'condition' => \"bad string here\" }\n    assert_template_result(\n      '',\n      '{% case condition %}{% when \"string here\" %} hit {% endcase %}',\\\n      assigns,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 125,
    "raw_source": "def test_case_with_else\n    assigns = { 'condition' => 5 }\n    assert_template_result(\n      ' hit ',\n      '{% case condition %}{% when 5 %} hit {% else %} else {% endcase %}',\n      assigns,\n    )\n\n    assigns = { 'condition' => 6 }\n    assert_template_result(\n      ' else ',\n      '{% case condition %}{% when 5 %} hit {% else %} else {% endcase %}',\n      assigns,\n    )\n\n    assigns = { 'condition' => 6 }\n    assert_template_result(\n      ' else ',\n      '{% case condition %} {% when 5 %} hit {% else %} else {% endcase %}',\n      assigns,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 148,
    "raw_source": "def test_case_on_size\n    assert_template_result('',  '{% case a.size %}{% when 1 %}1{% when 2 %}2{% endcase %}', { 'a' => [] })\n    assert_template_result('1', '{% case a.size %}{% when 1 %}1{% when 2 %}2{% endcase %}', { 'a' => [1] })\n    assert_template_result('2', '{% case a.size %}{% when 1 %}1{% when 2 %}2{% endcase %}', { 'a' => [1, 1] })\n    assert_template_result('',  '{% case a.size %}{% when 1 %}1{% when 2 %}2{% endcase %}', { 'a' => [1, 1, 1] })\n    assert_template_result('',  '{% case a.size %}{% when 1 %}1{% when 2 %}2{% endcase %}', { 'a' => [1, 1, 1, 1] })\n    assert_template_result('',  '{% case a.size %}{% when 1 %}1{% when 2 %}2{% endcase %}', { 'a' => [1, 1, 1, 1, 1] })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 157,
    "raw_source": "def test_case_on_size_with_else\n    assert_template_result(\n      'else',\n      '{% case a.size %}{% when 1 %}1{% when 2 %}2{% else %}else{% endcase %}',\n      { 'a' => [] },\n    )\n\n    assert_template_result(\n      '1',\n      '{% case a.size %}{% when 1 %}1{% when 2 %}2{% else %}else{% endcase %}',\n      { 'a' => [1] },\n    )\n\n    assert_template_result(\n      '2',\n      '{% case a.size %}{% when 1 %}1{% when 2 %}2{% else %}else{% endcase %}',\n      { 'a' => [1, 1] },\n    )\n\n    assert_template_result(\n      'else',\n      '{% case a.size %}{% when 1 %}1{% when 2 %}2{% else %}else{% endcase %}',\n      { 'a' => [1, 1, 1] },\n    )\n\n    assert_template_result(\n      'else',\n      '{% case a.size %}{% when 1 %}1{% when 2 %}2{% else %}else{% endcase %}',\n      { 'a' => [1, 1, 1, 1] },\n    )\n\n    assert_template_result(\n      'else',\n      '{% case a.size %}{% when 1 %}1{% when 2 %}2{% else %}else{% endcase %}',\n      { 'a' => [1, 1, 1, 1, 1] },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 195,
    "raw_source": "def test_case_on_length_with_else\n    assert_template_result(\n      'else',\n      '{% case a.empty? %}{% when true %}true{% when false %}false{% else %}else{% endcase %}',\n      {},\n    )\n\n    assert_template_result(\n      'false',\n      '{% case false %}{% when true %}true{% when false %}false{% else %}else{% endcase %}',\n      {},\n    )\n\n    assert_template_result(\n      'true',\n      '{% case true %}{% when true %}true{% when false %}false{% else %}else{% endcase %}',\n      {},\n    )\n\n    assert_template_result(\n      'else',\n      '{% case NULL %}{% when true %}true{% when false %}false{% else %}else{% endcase %}',\n      {},\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 221,
    "raw_source": "def test_assign_from_case\n    # Example from the shopify forums\n    code = \"{% case collection.handle %}{% when 'menswear-jackets' %}{% assign ptitle = 'menswear' %}{% when 'menswear-t-shirts' %}{% assign ptitle = 'menswear' %}{% else %}{% assign ptitle = 'womenswear' %}{% endcase %}{{ ptitle }}\"\n    assert_template_result(\"menswear\",   code, { \"collection\" => { 'handle' => 'menswear-jackets' } })\n    assert_template_result(\"menswear\",   code, { \"collection\" => { 'handle' => 'menswear-t-shirts' } })\n    assert_template_result(\"womenswear\", code, { \"collection\" => { 'handle' => 'x' } })\n    assert_template_result(\"womenswear\", code, { \"collection\" => { 'handle' => 'y' } })\n    assert_template_result(\"womenswear\", code, { \"collection\" => { 'handle' => 'z' } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 231,
    "raw_source": "def test_case_when_or\n    code = '{% case condition %}{% when 1 or 2 or 3 %} its 1 or 2 or 3 {% when 4 %} its 4 {% endcase %}'\n    assert_template_result(' its 1 or 2 or 3 ', code, { 'condition' => 1 })\n    assert_template_result(' its 1 or 2 or 3 ', code, { 'condition' => 2 })\n    assert_template_result(' its 1 or 2 or 3 ', code, { 'condition' => 3 })\n    assert_template_result(' its 4 ', code, { 'condition' => 4 })\n    assert_template_result('', code, { 'condition' => 5 })\n\n    code = '{% case condition %}{% when 1 or \"string\" or null %} its 1 or 2 or 3 {% when 4 %} its 4 {% endcase %}'\n    assert_template_result(' its 1 or 2 or 3 ', code, { 'condition' => 1 })\n    assert_template_result(' its 1 or 2 or 3 ', code, { 'condition' => 'string' })\n    assert_template_result(' its 1 or 2 or 3 ', code, { 'condition' => nil })\n    assert_template_result('', code, { 'condition' => 'something else' })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 246,
    "raw_source": "def test_case_when_comma\n    code = '{% case condition %}{% when 1, 2, 3 %} its 1 or 2 or 3 {% when 4 %} its 4 {% endcase %}'\n    assert_template_result(' its 1 or 2 or 3 ', code, { 'condition' => 1 })\n    assert_template_result(' its 1 or 2 or 3 ', code, { 'condition' => 2 })\n    assert_template_result(' its 1 or 2 or 3 ', code, { 'condition' => 3 })\n    assert_template_result(' its 4 ', code, { 'condition' => 4 })\n    assert_template_result('', code, { 'condition' => 5 })\n\n    code = '{% case condition %}{% when 1, \"string\", null %} its 1 or 2 or 3 {% when 4 %} its 4 {% endcase %}'\n    assert_template_result(' its 1 or 2 or 3 ', code, { 'condition' => 1 })\n    assert_template_result(' its 1 or 2 or 3 ', code, { 'condition' => 'string' })\n    assert_template_result(' its 1 or 2 or 3 ', code, { 'condition' => nil })\n    assert_template_result('', code, { 'condition' => 'something else' })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 261,
    "raw_source": "def test_case_when_comma_and_blank_body\n    code = '{% case condition %}{% when 1, 2 %} {% assign r = \"result\" %} {% endcase %}{{ r }}'\n    assert_template_result('result', code, { 'condition' => 2 })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 266,
    "raw_source": "def test_assign\n    assert_template_result('variable', '{% assign a = \"variable\"%}{{a}}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 270,
    "raw_source": "def test_assign_unassigned\n    assigns = { 'var' => 'content' }\n    assert_template_result('var2:  var2:content', 'var2:{{var2}} {%assign var2 = var%} var2:{{var2}}', assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 275,
    "raw_source": "def test_assign_an_empty_string\n    assert_template_result('', '{% assign a = \"\"%}{{a}}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 279,
    "raw_source": "def test_assign_is_global\n    assert_template_result('variable', '{%for i in (1..2) %}{% assign a = \"variable\"%}{% endfor %}{{a}}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 283,
    "raw_source": "def test_case_detects_bad_syntax\n    assert_raises(SyntaxError) do\n      assert_template_result('',  '{% case false %}{% when %}true{% endcase %}', {})\n    end\n\n    assert_raises(SyntaxError) do\n      assert_template_result('',  '{% case false %}{% huh %}true{% endcase %}', {})\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 293,
    "raw_source": "def test_cycle\n    assert_template_result('one', '{%cycle \"one\", \"two\"%}')\n    assert_template_result('one two', '{%cycle \"one\", \"two\"%} {%cycle \"one\", \"two\"%}')\n    assert_template_result(' two', '{%cycle \"\", \"two\"%} {%cycle \"\", \"two\"%}')\n\n    assert_template_result('one two one', '{%cycle \"one\", \"two\"%} {%cycle \"one\", \"two\"%} {%cycle \"one\", \"two\"%}')\n\n    assert_template_result(\n      'text-align: left text-align: right',\n      '{%cycle \"text-align: left\", \"text-align: right\" %} {%cycle \"text-align: left\", \"text-align: right\"%}',\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 306,
    "raw_source": "def test_multiple_cycles\n    assert_template_result(\n      '1 2 1 1 2 3 1',\n      '{%cycle 1,2%} {%cycle 1,2%} {%cycle 1,2%} {%cycle 1,2,3%} {%cycle 1,2,3%} {%cycle 1,2,3%} {%cycle 1,2,3%}',\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 313,
    "raw_source": "def test_multiple_named_cycles\n    assert_template_result(\n      'one one two two one one',\n      '{%cycle 1: \"one\", \"two\" %} {%cycle 2: \"one\", \"two\" %} {%cycle 1: \"one\", \"two\" %} {%cycle 2: \"one\", \"two\" %} {%cycle 1: \"one\", \"two\" %} {%cycle 2: \"one\", \"two\" %}',\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 320,
    "raw_source": "def test_multiple_named_cycles_with_names_from_context\n    assigns = { \"var1\" => 1, \"var2\" => 2 }\n    assert_template_result(\n      'one one two two one one',\n      '{%cycle var1: \"one\", \"two\" %} {%cycle var2: \"one\", \"two\" %} {%cycle var1: \"one\", \"two\" %} {%cycle var2: \"one\", \"two\" %} {%cycle var1: \"one\", \"two\" %} {%cycle var2: \"one\", \"two\" %}',\n      assigns,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 329,
    "raw_source": "def test_size_of_array\n    assigns = { \"array\" => [1, 2, 3, 4] }\n    assert_template_result('array has 4 elements', \"array has {{ array.size }} elements\", assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 334,
    "raw_source": "def test_size_of_hash\n    assigns = { \"hash\" => { a: 1, b: 2, c: 3, d: 4 } }\n    assert_template_result('hash has 4 elements', \"hash has {{ hash.size }} elements\", assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 339,
    "raw_source": "def test_illegal_symbols\n    assert_template_result('', '{% if true == empty %}?{% endif %}', {})\n    assert_template_result('', '{% if true == null %}?{% endif %}', {})\n    assert_template_result('', '{% if empty == true %}?{% endif %}', {})\n    assert_template_result('', '{% if null == true %}?{% endif %}', {})\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 346,
    "raw_source": "def test_ifchanged\n    assigns = { 'array' => [1, 1, 2, 2, 3, 3] }\n    assert_template_result('123', '{%for item in array%}{%ifchanged%}{{item}}{% endifchanged %}{%endfor%}', assigns)\n\n    assigns = { 'array' => [1, 1, 1, 1] }\n    assert_template_result('1', '{%for item in array%}{%ifchanged%}{{item}}{% endifchanged %}{%endfor%}', assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/standard_tag_test.rb",
    "start_line": 354,
    "raw_source": "def test_multiline_tag\n    assert_template_result('0 1 2 3', \"0{%\\nfor i in (1..3)\\n%} {{\\ni\\n}}{%\\nendfor\\n%}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 8,
    "raw_source": "def test_true_eql_true\n    text = ' {% if true == true %} true {% else %} false {% endif %} '\n    assert_template_result('  true  ', text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 13,
    "raw_source": "def test_true_not_eql_true\n    text = ' {% if true != true %} true {% else %} false {% endif %} '\n    assert_template_result('  false  ', text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 18,
    "raw_source": "def test_true_lq_true\n    text = ' {% if 0 > 0 %} true {% else %} false {% endif %} '\n    assert_template_result('  false  ', text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 23,
    "raw_source": "def test_one_lq_zero\n    text = ' {% if 1 > 0 %} true {% else %} false {% endif %} '\n    assert_template_result('  true  ', text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 28,
    "raw_source": "def test_zero_lq_one\n    text = ' {% if 0 < 1 %} true {% else %} false {% endif %} '\n    assert_template_result('  true  ', text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 33,
    "raw_source": "def test_zero_lq_or_equal_one\n    text = ' {% if 0 <= 0 %} true {% else %} false {% endif %} '\n    assert_template_result('  true  ', text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 38,
    "raw_source": "def test_zero_lq_or_equal_one_involving_nil\n    text = ' {% if null <= 0 %} true {% else %} false {% endif %} '\n    assert_template_result('  false  ', text)\n\n    text = ' {% if 0 <= null %} true {% else %} false {% endif %} '\n    assert_template_result('  false  ', text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 46,
    "raw_source": "def test_zero_lqq_or_equal_one\n    text = ' {% if 0 >= 0 %} true {% else %} false {% endif %} '\n    assert_template_result('  true  ', text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 51,
    "raw_source": "def test_strings\n    text = \" {% if 'test' == 'test' %} true {% else %} false {% endif %} \"\n    assert_template_result('  true  ', text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 56,
    "raw_source": "def test_strings_not_equal\n    text = \" {% if 'test' != 'test' %} true {% else %} false {% endif %} \"\n    assert_template_result('  false  ', text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 61,
    "raw_source": "def test_var_strings_equal\n    text = ' {% if var == \"hello there!\" %} true {% else %} false {% endif %} '\n    assert_template_result('  true  ', text, { 'var' => 'hello there!' })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 66,
    "raw_source": "def test_var_strings_are_not_equal\n    text = ' {% if \"hello there!\" == var %} true {% else %} false {% endif %} '\n    assert_template_result('  true  ', text, { 'var' => 'hello there!' })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 71,
    "raw_source": "def test_var_and_long_string_are_equal\n    text = \" {% if var == 'hello there!' %} true {% else %} false {% endif %} \"\n    assert_template_result('  true  ', text, { 'var' => 'hello there!' })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 76,
    "raw_source": "def test_var_and_long_string_are_equal_backwards\n    text = \" {% if 'hello there!' == var %} true {% else %} false {% endif %} \"\n    assert_template_result('  true  ', text, { 'var' => 'hello there!' })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 88,
    "raw_source": "def test_is_collection_empty\n    text = ' {% if array == empty %} true {% else %} false {% endif %} '\n    assert_template_result('  true  ', text, { 'array' => [] })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 93,
    "raw_source": "def test_is_not_collection_empty\n    text = ' {% if array == empty %} true {% else %} false {% endif %} '\n    assert_template_result('  false  ', text, { 'array' => [1, 2, 3] })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 98,
    "raw_source": "def test_nil\n    text = ' {% if var == nil %} true {% else %} false {% endif %} '\n    assert_template_result('  true  ', text, { 'var' => nil })\n\n    text = ' {% if var == null %} true {% else %} false {% endif %} '\n    assert_template_result('  true  ', text, { 'var' => nil })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/statements_test.rb",
    "start_line": 106,
    "raw_source": "def test_not_nil\n    text = ' {% if var != nil %} true {% else %} false {% endif %} '\n    assert_template_result('  true  ', text, { 'var' => 1 })\n\n    text = ' {% if var != null %} true {% else %} false {% endif %} '\n    assert_template_result('  true  ', text, { 'var' => 1 })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 11,
    "raw_source": "def initialize(array)\n      @array = array\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 15,
    "raw_source": "def each(&block)\n      @array.each(&block)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 20,
    "raw_source": "def test_table_row\n    assert_template_result(\n      \"<tr class=\\\"row1\\\">\\n<td class=\\\"col1\\\"> 1 </td><td class=\\\"col2\\\"> 2 </td><td class=\\\"col3\\\"> 3 </td></tr>\\n<tr class=\\\"row2\\\"><td class=\\\"col1\\\"> 4 </td><td class=\\\"col2\\\"> 5 </td><td class=\\\"col3\\\"> 6 </td></tr>\\n\",\n      '{% tablerow n in numbers cols:3%} {{n}} {% endtablerow %}',\n      { 'numbers' => [1, 2, 3, 4, 5, 6] },\n    )\n\n    assert_template_result(\n      \"<tr class=\\\"row1\\\">\\n</tr>\\n\",\n      '{% tablerow n in numbers cols:3%} {{n}} {% endtablerow %}',\n      { 'numbers' => [] },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 34,
    "raw_source": "def test_table_row_with_different_cols\n    assert_template_result(\n      \"<tr class=\\\"row1\\\">\\n<td class=\\\"col1\\\"> 1 </td><td class=\\\"col2\\\"> 2 </td><td class=\\\"col3\\\"> 3 </td><td class=\\\"col4\\\"> 4 </td><td class=\\\"col5\\\"> 5 </td></tr>\\n<tr class=\\\"row2\\\"><td class=\\\"col1\\\"> 6 </td></tr>\\n\",\n      '{% tablerow n in numbers cols:5%} {{n}} {% endtablerow %}',\n      { 'numbers' => [1, 2, 3, 4, 5, 6] },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 42,
    "raw_source": "def test_table_col_counter\n    assert_template_result(\n      \"<tr class=\\\"row1\\\">\\n<td class=\\\"col1\\\">1</td><td class=\\\"col2\\\">2</td></tr>\\n<tr class=\\\"row2\\\"><td class=\\\"col1\\\">1</td><td class=\\\"col2\\\">2</td></tr>\\n<tr class=\\\"row3\\\"><td class=\\\"col1\\\">1</td><td class=\\\"col2\\\">2</td></tr>\\n\",\n      '{% tablerow n in numbers cols:2%}{{tablerowloop.col}}{% endtablerow %}',\n      { 'numbers' => [1, 2, 3, 4, 5, 6] },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 50,
    "raw_source": "def test_quoted_fragment\n    assert_template_result(\n      \"<tr class=\\\"row1\\\">\\n<td class=\\\"col1\\\"> 1 </td><td class=\\\"col2\\\"> 2 </td><td class=\\\"col3\\\"> 3 </td></tr>\\n<tr class=\\\"row2\\\"><td class=\\\"col1\\\"> 4 </td><td class=\\\"col2\\\"> 5 </td><td class=\\\"col3\\\"> 6 </td></tr>\\n\",\n      \"{% tablerow n in collections.frontpage cols:3%} {{n}} {% endtablerow %}\",\n      { 'collections' => { 'frontpage' => [1, 2, 3, 4, 5, 6] } },\n    )\n    assert_template_result(\n      \"<tr class=\\\"row1\\\">\\n<td class=\\\"col1\\\"> 1 </td><td class=\\\"col2\\\"> 2 </td><td class=\\\"col3\\\"> 3 </td></tr>\\n<tr class=\\\"row2\\\"><td class=\\\"col1\\\"> 4 </td><td class=\\\"col2\\\"> 5 </td><td class=\\\"col3\\\"> 6 </td></tr>\\n\",\n      \"{% tablerow n in collections['frontpage'] cols:3%} {{n}} {% endtablerow %}\",\n      { 'collections' => { 'frontpage' => [1, 2, 3, 4, 5, 6] } },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 63,
    "raw_source": "def test_enumerable_drop\n    assert_template_result(\n      \"<tr class=\\\"row1\\\">\\n<td class=\\\"col1\\\"> 1 </td><td class=\\\"col2\\\"> 2 </td><td class=\\\"col3\\\"> 3 </td></tr>\\n<tr class=\\\"row2\\\"><td class=\\\"col1\\\"> 4 </td><td class=\\\"col2\\\"> 5 </td><td class=\\\"col3\\\"> 6 </td></tr>\\n\",\n      '{% tablerow n in numbers cols:3%} {{n}} {% endtablerow %}',\n      { 'numbers' => ArrayDrop.new([1, 2, 3, 4, 5, 6]) },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 71,
    "raw_source": "def test_offset_and_limit\n    assert_template_result(\n      \"<tr class=\\\"row1\\\">\\n<td class=\\\"col1\\\"> 1 </td><td class=\\\"col2\\\"> 2 </td><td class=\\\"col3\\\"> 3 </td></tr>\\n<tr class=\\\"row2\\\"><td class=\\\"col1\\\"> 4 </td><td class=\\\"col2\\\"> 5 </td><td class=\\\"col3\\\"> 6 </td></tr>\\n\",\n      '{% tablerow n in numbers cols:3 offset:1 limit:6%} {{n}} {% endtablerow %}',\n      { 'numbers' => [0, 1, 2, 3, 4, 5, 6, 7] },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 79,
    "raw_source": "def test_blank_string_not_iterable\n    assert_template_result(\n      \"<tr class=\\\"row1\\\">\\n</tr>\\n\",\n      \"{% tablerow char in characters cols:3 %}I WILL NOT BE OUTPUT{% endtablerow %}\",\n      { 'characters' => '' },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 87,
    "raw_source": "def test_cols_nil_constant_same_as_evaluated_nil_expression\n    expect = \"<tr class=\\\"row1\\\">\\n\" \\\n      \"<td class=\\\"col1\\\">false</td>\" \\\n      \"<td class=\\\"col2\\\">false</td>\" \\\n      \"</tr>\\n\"\n\n    assert_template_result(\n      expect,\n      \"{% tablerow i in (1..2) cols:nil %}{{ tablerowloop.col_last }}{% endtablerow %}\",\n    )\n\n    assert_template_result(\n      expect,\n      \"{% tablerow i in (1..2) cols:var %}{{ tablerowloop.col_last }}{% endtablerow %}\",\n      { \"var\" => nil },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 105,
    "raw_source": "def test_nil_limit_is_treated_as_zero\n    expect = \"<tr class=\\\"row1\\\">\\n\" \\\n      \"</tr>\\n\"\n\n    assert_template_result(\n      expect,\n      \"{% tablerow i in (1..2) limit:nil %}{{ i }}{% endtablerow %}\",\n    )\n\n    assert_template_result(\n      expect,\n      \"{% tablerow i in (1..2) limit:var %}{{ i }}{% endtablerow %}\",\n      { \"var\" => nil },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 121,
    "raw_source": "def test_nil_offset_is_treated_as_zero\n    expect = \"<tr class=\\\"row1\\\">\\n\" \\\n      \"<td class=\\\"col1\\\">1:false</td>\" \\\n      \"<td class=\\\"col2\\\">2:true</td>\" \\\n      \"</tr>\\n\"\n\n    assert_template_result(\n      expect,\n      \"{% tablerow i in (1..2) offset:nil %}{{ i }}:{{ tablerowloop.col_last }}{% endtablerow %}\",\n    )\n\n    assert_template_result(\n      expect,\n      \"{% tablerow i in (1..2) offset:var %}{{ i }}:{{ tablerowloop.col_last }}{% endtablerow %}\",\n      { \"var\" => nil },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 139,
    "raw_source": "def test_tablerow_loop_drop_attributes\n    template = <<~LIQUID.chomp\n      {% tablerow i in (1...2) %}\n      col: {{ tablerowloop.col }}\n      col0: {{ tablerowloop.col0 }}\n      col_first: {{ tablerowloop.col_first }}\n      col_last: {{ tablerowloop.col_last }}\n      first: {{ tablerowloop.first }}\n      index: {{ tablerowloop.index }}\n      index0: {{ tablerowloop.index0 }}\n      last: {{ tablerowloop.last }}\n      length: {{ tablerowloop.length }}\n      rindex: {{ tablerowloop.rindex }}\n      rindex0: {{ tablerowloop.rindex0 }}\n      row: {{ tablerowloop.row }}\n      {% endtablerow %}\n    LIQUID\n\n    expected_output = <<~OUTPUT\n      <tr class=\"row1\">\n      <td class=\"col1\">\n      col: 1\n      col0: 0\n      col_first: true\n      col_last: false\n      first: true\n      index: 1\n      index0: 0\n      last: false\n      length: 2\n      rindex: 2\n      rindex0: 1\n      row: 1\n      </td><td class=\"col2\">\n      col: 2\n      col0: 1\n      col_first: false\n      col_last: true\n      first: false\n      index: 2\n      index0: 1\n      last: true\n      length: 2\n      rindex: 1\n      rindex0: 0\n      row: 1\n      </td></tr>\n    OUTPUT\n\n    assert_template_result(expected_output, template)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 191,
    "raw_source": "def test_table_row_renders_correct_error_message_for_invalid_parameters\n    assert_template_result(\n      \"Liquid error (line 1): invalid integer\",\n      '{% tablerow n in (1...10) limit:true %} {{n}} {% endtablerow %}',\n      render_errors: true,\n    )\n\n    assert_template_result(\n      \"Liquid error (line 1): invalid integer\",\n      '{% tablerow n in (1...10) offset:true %} {{n}} {% endtablerow %}',\n      render_errors: true,\n    )\n\n    assert_template_result(\n      \"Liquid error (line 1): invalid integer\",\n      '{% tablerow n in (1...10) cols:true %} {{n}} {% endtablerow %}',\n      render_errors: true,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 211,
    "raw_source": "def test_table_row_handles_interrupts\n    assert_template_result(\n      \"<tr class=\\\"row1\\\">\\n<td class=\\\"col1\\\"> 1 </td></tr>\\n\",\n      '{% tablerow n in (1...3) cols:2 %} {{n}} {% break %} {{n}} {% endtablerow %}',\n    )\n\n    assert_template_result(\n      \"<tr class=\\\"row1\\\">\\n<td class=\\\"col1\\\"> 1 </td><td class=\\\"col2\\\"> 2 </td></tr>\\n<tr class=\\\"row2\\\"><td class=\\\"col1\\\"> 3 </td></tr>\\n\",\n      '{% tablerow n in (1...3) cols:2 %} {{n}} {% continue %} {{n}} {% endtablerow %}',\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/table_row_test.rb",
    "start_line": 223,
    "raw_source": "def test_table_row_does_not_leak_interrupts\n    template = <<~LIQUID\n      {% for i in (1..2) -%}\n      {% for j in (1..2) -%}\n      {% tablerow k in (1..3) %}{% break %}{% endtablerow -%}\n      loop j={{ j }}\n      {% endfor -%}\n      loop i={{ i }}\n      {% endfor -%}\n      after loop\n    LIQUID\n\n    expected = <<~STR\n      <tr class=\"row1\">\n      <td class=\"col1\"></td></tr>\n      loop j=1\n      <tr class=\"row1\">\n      <td class=\"col1\"></td></tr>\n      loop j=2\n      loop i=1\n      <tr class=\"row1\">\n      <td class=\"col1\"></td></tr>\n      loop j=1\n      <tr class=\"row1\">\n      <td class=\"col1\"></td></tr>\n      loop j=2\n      loop i=2\n      after loop\n    STR\n\n    assert_template_result(\n      expected,\n      template,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/unless_else_tag_test.rb",
    "start_line": 8,
    "raw_source": "def test_unless\n    assert_template_result('  ', ' {% unless true %} this text should not go into the output {% endunless %} ')\n    assert_template_result(\n      '  this text should go into the output  ',\n      ' {% unless false %} this text should go into the output {% endunless %} ',\n    )\n    assert_template_result('  you rock ?', '{% unless true %} you suck {% endunless %} {% unless false %} you rock {% endunless %}?')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/unless_else_tag_test.rb",
    "start_line": 17,
    "raw_source": "def test_unless_else\n    assert_template_result(' YES ', '{% unless true %} NO {% else %} YES {% endunless %}')\n    assert_template_result(' YES ', '{% unless false %} YES {% else %} NO {% endunless %}')\n    assert_template_result(' YES ', '{% unless \"foo\" %} NO {% else %} YES {% endunless %}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/unless_else_tag_test.rb",
    "start_line": 23,
    "raw_source": "def test_unless_in_loop\n    assert_template_result('23', '{% for i in choices %}{% unless i %}{{ forloop.index }}{% endunless %}{% endfor %}', { 'choices' => [1, nil, false] })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/tags/unless_else_tag_test.rb",
    "start_line": 27,
    "raw_source": "def test_unless_else_in_loop\n    assert_template_result(' TRUE  2  3 ', '{% for i in choices %}{% unless i %} {{ forloop.index }} {% else %} TRUE {% endunless %}{% endfor %}', { 'choices' => [1, nil, false] })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 9,
    "raw_source": "def test_standard_output\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {{ 'John' }}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>\n          John\n        </p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 27,
    "raw_source": "def test_variable_output_with_multiple_blank_lines\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n\n\n          {{- 'John' -}}\n\n\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>John</p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 47,
    "raw_source": "def test_tag_output_with_multiple_blank_lines\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n\n\n          {%- if true -%}\n          yes\n          {%- endif -%}\n\n\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>yes</p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 70,
    "raw_source": "def test_standard_tags\n    whitespace = '          '\n    text       = <<-END_TEMPLATE\n      <div>\n        <p>\n          {% if true %}\n          yes\n          {% endif %}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<~END_EXPECTED\n            <div>\n              <p>\n      #{whitespace}\n                yes\n      #{whitespace}\n              </p>\n            </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {% if false %}\n          no\n          {% endif %}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<~END_EXPECTED\n            <div>\n              <p>\n      #{whitespace}\n              </p>\n            </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 112,
    "raw_source": "def test_no_trim_output\n    text     = '<p>{{- \\'John\\' -}}</p>'\n    expected = '<p>John</p>'\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 119,
    "raw_source": "def test_no_trim_tags\n    text     = '<p>{%- if true -%}yes{%- endif -%}</p>'\n    expected = '<p>yes</p>'\n    assert_template_result(expected, text)\n\n    text     = '<p>{%- if false -%}no{%- endif -%}</p>'\n    expected = '<p></p>'\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 129,
    "raw_source": "def test_single_line_outer_tag\n    text     = '<p> {%- if true %} yes {% endif -%} </p>'\n    expected = '<p> yes </p>'\n    assert_template_result(expected, text)\n\n    text     = '<p> {%- if false %} no {% endif -%} </p>'\n    expected = '<p></p>'\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 139,
    "raw_source": "def test_single_line_inner_tag\n    text     = '<p> {% if true -%} yes {%- endif %} </p>'\n    expected = '<p> yes </p>'\n    assert_template_result(expected, text)\n\n    text     = '<p> {% if false -%} no {%- endif %} </p>'\n    expected = '<p>  </p>'\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 149,
    "raw_source": "def test_single_line_post_tag\n    text     = '<p> {% if true -%} yes {% endif -%} </p>'\n    expected = '<p> yes </p>'\n    assert_template_result(expected, text)\n\n    text     = '<p> {% if false -%} no {% endif -%} </p>'\n    expected = '<p> </p>'\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 159,
    "raw_source": "def test_single_line_pre_tag\n    text     = '<p> {%- if true %} yes {%- endif %} </p>'\n    expected = '<p> yes </p>'\n    assert_template_result(expected, text)\n\n    text     = '<p> {%- if false %} no {%- endif %} </p>'\n    expected = '<p> </p>'\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 169,
    "raw_source": "def test_pre_trim_output\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {{- 'John' }}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>John\n        </p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 186,
    "raw_source": "def test_pre_trim_tags\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {%- if true %}\n          yes\n          {%- endif %}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>\n          yes\n        </p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {%- if false %}\n          no\n          {%- endif %}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>\n        </p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 223,
    "raw_source": "def test_post_trim_output\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {{ 'John' -}}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>\n          John</p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 240,
    "raw_source": "def test_post_trim_tags\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {% if true -%}\n          yes\n          {% endif -%}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>\n          yes\n          </p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {% if false -%}\n          no\n          {% endif -%}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>\n          </p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 277,
    "raw_source": "def test_pre_and_post_trim_tags\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {%- if true %}\n          yes\n          {% endif -%}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>\n          yes\n          </p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {%- if false %}\n          no\n          {% endif -%}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p></p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 313,
    "raw_source": "def test_post_and_pre_trim_tags\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {% if true -%}\n          yes\n          {%- endif %}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>\n          yes\n        </p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n\n    whitespace = '          '\n    text       = <<-END_TEMPLATE\n      <div>\n        <p>\n          {% if false -%}\n          no\n          {%- endif %}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<~END_EXPECTED\n            <div>\n              <p>\n      #{whitespace}\n              </p>\n            </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 352,
    "raw_source": "def test_trim_output\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {{- 'John' -}}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>John</p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 368,
    "raw_source": "def test_trim_tags\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {%- if true -%}\n          yes\n          {%- endif -%}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>yes</p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {%- if false -%}\n          no\n          {%- endif -%}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p></p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 402,
    "raw_source": "def test_whitespace_trim_output\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {{- 'John' -}},\n          {{- '30' -}}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>John,30</p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 419,
    "raw_source": "def test_whitespace_trim_tags\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {%- if true -%}\n          yes\n          {%- endif -%}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>yes</p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {%- if false -%}\n          no\n          {%- endif -%}\n        </p>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p></p>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 453,
    "raw_source": "def test_complex_trim_output\n    text = <<-END_TEMPLATE\n      <div>\n        <p>\n          {{- 'John' -}}\n          {{- '30' -}}\n        </p>\n        <b>\n          {{ 'John' -}}\n          {{- '30' }}\n        </b>\n        <i>\n          {{- 'John' }}\n          {{ '30' -}}\n        </i>\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div>\n        <p>John30</p>\n        <b>\n          John30\n        </b>\n        <i>John\n          30</i>\n      </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 483,
    "raw_source": "def test_complex_trim\n    text = <<-END_TEMPLATE\n      <div>\n        {%- if true -%}\n          {%- if true -%}\n            <p>\n              {{- 'John' -}}\n            </p>\n          {%- endif -%}\n        {%- endif -%}\n      </div>\n    END_TEMPLATE\n    expected = <<-END_EXPECTED\n      <div><p>John</p></div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 501,
    "raw_source": "def test_right_trim_followed_by_tag\n    assert_template_result('ab c', '{{ \"a\" -}}{{ \"b\" }} c')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 505,
    "raw_source": "def test_raw_output\n    whitespace = '        '\n    text       = <<-END_TEMPLATE\n      <div>\n        {% raw %}\n          {%- if true -%}\n            <p>\n              {{- 'John' -}}\n            </p>\n          {%- endif -%}\n        {% endraw %}\n      </div>\n    END_TEMPLATE\n    expected = <<~END_EXPECTED\n            <div>\n      #{whitespace}\n                {%- if true -%}\n                  <p>\n                    {{- 'John' -}}\n                  </p>\n                {%- endif -%}\n      #{whitespace}\n            </div>\n    END_EXPECTED\n    assert_template_result(expected, text)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 532,
    "raw_source": "def test_pre_trim_blank_preceding_text\n    assert_template_result(\"\", \"\\n{%- raw %}{% endraw %}\")\n    assert_template_result(\"\", \"\\n{%- if true %}{% endif %}\")\n    assert_template_result(\"BC\", \"{{ 'B' }} \\n{%- if true %}C{% endif %}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 538,
    "raw_source": "def test_bug_compatible_pre_trim\n    template = Liquid::Template.parse(\"\\n {%- raw %}{% endraw %}\", bug_compatible_whitespace_trimming: true)\n    assert_equal(\"\\n\", template.render)\n\n    template = Liquid::Template.parse(\"\\n {%- if true %}{% endif %}\", bug_compatible_whitespace_trimming: true)\n    assert_equal(\"\\n\", template.render)\n\n    template = Liquid::Template.parse(\"{{ 'B' }} \\n{%- if true %}C{% endif %}\", bug_compatible_whitespace_trimming: true)\n    assert_equal(\"B C\", template.render)\n\n    template = Liquid::Template.parse(\"B\\n {%- raw %}{% endraw %}\", bug_compatible_whitespace_trimming: true)\n    assert_equal(\"B\", template.render)\n\n    template = Liquid::Template.parse(\"B\\n {%- if true %}{% endif %}\", bug_compatible_whitespace_trimming: true)\n    assert_equal(\"B\", template.render)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/trim_mode_test.rb",
    "start_line": 555,
    "raw_source": "def test_trim_blank\n    assert_template_result('foobar', 'foo {{-}} bar')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 9,
    "raw_source": "def test_simple_variable\n    assert_template_result('worked', \"{{test}}\", { 'test' => 'worked' })\n    assert_template_result('worked wonderfully', \"{{test}}\", { 'test' => 'worked wonderfully' })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 14,
    "raw_source": "def test_variable_render_calls_to_liquid\n    assert_template_result('foobar', '{{ foo }}', { 'foo' => ThingWithToLiquid.new })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 18,
    "raw_source": "def test_variable_lookup_calls_to_liquid_value\n    assert_template_result('1', '{{ foo }}', { 'foo' => IntegerDrop.new('1') })\n    assert_template_result('2', '{{ list[foo] }}', { 'foo' => IntegerDrop.new('1'), 'list' => [1, 2, 3] })\n    assert_template_result('one', '{{ list[foo] }}', { 'foo' => IntegerDrop.new('1'), 'list' => { 1 => 'one' } })\n    assert_template_result('Yay', '{{ foo }}', { 'foo' => BooleanDrop.new(true) })\n    assert_template_result('YAY', '{{ foo | upcase }}', { 'foo' => BooleanDrop.new(true) })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 26,
    "raw_source": "def test_if_tag_calls_to_liquid_value\n    assert_template_result('one', '{% if foo == 1 %}one{% endif %}', { 'foo' => IntegerDrop.new('1') })\n    assert_template_result('one', '{% if foo == eqv %}one{% endif %}', { 'foo' => IntegerDrop.new(1), 'eqv' => IntegerDrop.new(1) })\n    assert_template_result('one', '{% if 0 < foo %}one{% endif %}', { 'foo' => IntegerDrop.new('1') })\n    assert_template_result('one', '{% if foo > 0 %}one{% endif %}', { 'foo' => IntegerDrop.new('1') })\n    assert_template_result('one', '{% if b > a %}one{% endif %}', { 'b' => IntegerDrop.new(1), 'a' => IntegerDrop.new(0) })\n    assert_template_result('true', '{% if foo == true %}true{% endif %}', { 'foo' => BooleanDrop.new(true) })\n    assert_template_result('true', '{% if foo %}true{% endif %}', { 'foo' => BooleanDrop.new(true) })\n\n    assert_template_result('', '{% if foo %}true{% endif %}', { 'foo' => BooleanDrop.new(false) })\n    assert_template_result('', '{% if foo == true %}True{% endif %}', { 'foo' => BooleanDrop.new(false) })\n    assert_template_result('', '{% if foo and true %}SHOULD NOT HAPPEN{% endif %}', { 'foo' => BooleanDrop.new(false) })\n\n    assert_template_result('one', '{% if a contains x %}one{% endif %}', { 'a' => [1], 'x' => IntegerDrop.new(1) })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 42,
    "raw_source": "def test_unless_tag_calls_to_liquid_value\n    assert_template_result('', '{% unless foo %}true{% endunless %}', { 'foo' => BooleanDrop.new(true) })\n    assert_template_result('true', '{% unless foo %}true{% endunless %}', { 'foo' => BooleanDrop.new(false) })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 47,
    "raw_source": "def test_case_tag_calls_to_liquid_value\n    assert_template_result('One', '{% case foo %}{% when 1 %}One{% endcase %}', { 'foo' => IntegerDrop.new('1') })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 51,
    "raw_source": "def test_simple_with_whitespaces\n    assert_template_result(\"  worked  \", \"  {{ test }}  \", { \"test\" => \"worked\" })\n    assert_template_result(\"  worked wonderfully  \", \"  {{ test }}  \", { \"test\" => \"worked wonderfully\" })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 56,
    "raw_source": "def test_expression_with_whitespace_in_square_brackets\n    assert_template_result('result', \"{{ a[ 'b' ] }}\", { 'a' => { 'b' => 'result' } })\n    assert_template_result('result', \"{{ a[ [ 'b' ] ] }}\", { 'b' => 'c', 'a' => { 'c' => 'result' } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 61,
    "raw_source": "def test_ignore_unknown\n    assert_template_result(\"\", \"{{ test }}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 65,
    "raw_source": "def test_using_blank_as_variable_name\n    assert_template_result(\"\", \"{% assign foo = blank %}{{ foo }}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 69,
    "raw_source": "def test_using_empty_as_variable_name\n    assert_template_result(\"\", \"{% assign foo = empty %}{{ foo }}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 73,
    "raw_source": "def test_hash_scoping\n    assert_template_result('worked', \"{{ test.test }}\", { 'test' => { 'test' => 'worked' } })\n    assert_template_result('worked', \"{{ test . test }}\", { 'test' => { 'test' => 'worked' } })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 78,
    "raw_source": "def test_false_renders_as_false\n    assert_template_result(\"false\", \"{{ foo }}\", { 'foo' => false })\n    assert_template_result(\"false\", \"{{ false }}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 83,
    "raw_source": "def test_nil_renders_as_empty_string\n    assert_template_result(\"\", \"{{ nil }}\")\n    assert_template_result(\"cat\", \"{{ nil | append: 'cat' }}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 88,
    "raw_source": "def test_preset_assigns\n    template                 = Template.parse(%({{ test }}))\n    template.assigns['test'] = 'worked'\n    assert_equal('worked', template.render!)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 94,
    "raw_source": "def test_reuse_parsed_template\n    template                     = Template.parse(%({{ greeting }} {{ name }}))\n    template.assigns['greeting'] = 'Goodbye'\n    assert_equal('Hello Tobi', template.render!('greeting' => 'Hello', 'name' => 'Tobi'))\n    assert_equal('Hello ', template.render!('greeting' => 'Hello', 'unknown' => 'Tobi'))\n    assert_equal('Hello Brian', template.render!('greeting' => 'Hello', 'name' => 'Brian'))\n    assert_equal('Goodbye Brian', template.render!('name' => 'Brian'))\n    assert_equal({ 'greeting' => 'Goodbye' }, template.assigns)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 104,
    "raw_source": "def test_assigns_not_polluted_from_template\n    template                 = Template.parse(%({{ test }}{% assign test = 'bar' %}{{ test }}))\n    template.assigns['test'] = 'baz'\n    assert_equal('bazbar', template.render!)\n    assert_equal('bazbar', template.render!)\n    assert_equal('foobar', template.render!('test' => 'foo'))\n    assert_equal('bazbar', template.render!)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 113,
    "raw_source": "def test_hash_with_default_proc\n    template        = Template.parse(%(Hello {{ test }}))\n    assigns         = Hash.new { |_h, k| raise \"Unknown variable '#{k}'\" }\n    assigns['test'] = 'Tobi'\n    assert_equal('Hello Tobi', template.render!(assigns))\n    assigns.delete('test')\n    e = assert_raises(RuntimeError) do\n      template.render!(assigns)\n    end\n    assert_equal(\"Unknown variable 'test'\", e.message)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 125,
    "raw_source": "def test_multiline_variable\n    assert_template_result(\"worked\", \"{{\\ntest\\n}}\", { \"test\" => \"worked\" })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 129,
    "raw_source": "def test_render_symbol\n    assert_template_result('bar', '{{ foo }}', { 'foo' => :bar })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 133,
    "raw_source": "def test_nested_array\n    assert_template_result('', '{{ foo }}', { 'foo' => [[nil]] })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 137,
    "raw_source": "def test_dynamic_find_var\n    assert_template_result('bar', '{{ [key] }}', { 'key' => 'foo', 'foo' => 'bar' })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 141,
    "raw_source": "def test_raw_value_variable\n    assert_template_result('bar', '{{ [key] }}', { 'key' => 'foo', 'foo' => 'bar' })\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 145,
    "raw_source": "def test_dynamic_find_var_with_drop\n    assert_template_result(\n      'bar',\n      '{{ [list[settings.zero]] }}',\n      {\n        'list' => ['foo'],\n        'settings' => SettingsDrop.new(\"zero\" => 0),\n        'foo' => 'bar',\n      },\n    )\n\n    assert_template_result(\n      'foo',\n      '{{ [list[settings.zero][\"foo\"]] }}',\n      {\n        'list' => [{ 'foo' => 'bar' }],\n        'settings' => SettingsDrop.new(\"zero\" => 0),\n        'bar' => 'foo',\n      },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 167,
    "raw_source": "def test_double_nested_variable_lookup\n    assert_template_result(\n      'bar',\n      '{{ list[list[settings.zero]][\"foo\"] }}',\n      {\n        'list' => [1, { 'foo' => 'bar' }],\n        'settings' => SettingsDrop.new(\"zero\" => 0),\n        'bar' => 'foo',\n      },\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/integration/variable_test.rb",
    "start_line": 179,
    "raw_source": "def test_variable_lookup_should_not_hang_with_invalid_syntax\n    Timeout.timeout(1) do\n      assert_template_result(\n        'bar',\n        \"{{['foo'}}\",\n        {\n          'foo' => 'bar',\n        },\n        error_mode: :lax,\n      )\n    end\n\n    very_long_key = \"1234567890\" * 100\n\n    template_list = [\n      \"{{['#{very_long_key}']}}\", # valid\n      \"{{['#{very_long_key}'}}\", # missing closing bracket\n      \"{{[['#{very_long_key}']}}\", # extra open bracket\n    ]\n\n    template_list.each do |template|\n      Timeout.timeout(1) do\n        assert_template_result(\n          'bar',\n          template,\n          {\n            very_long_key => 'bar',\n          },\n          error_mode: :lax,\n        )\n      end\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 27,
    "raw_source": "def fixture(name)\n      File.join(File.expand_path(__dir__), \"fixtures\", name)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 35,
    "raw_source": "def assert_template_result(\n      expected, template, assigns = {},\n      message: nil, partials: nil, error_mode: nil, render_errors: false,\n      template_factory: nil\n    )\n      file_system = StubFileSystem.new(partials || {})\n      environment = Liquid::Environment.build(file_system: file_system)\n      template = Liquid::Template.parse(template, line_numbers: true, error_mode: error_mode&.to_sym, environment: environment)\n      registers = Liquid::Registers.new(file_system: file_system, template_factory: template_factory)\n      context = Liquid::Context.build(static_environments: assigns, rethrow_errors: !render_errors, registers: registers, environment: environment)\n      output = template.render(context)\n      assert_equal(expected, output, message)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 49,
    "raw_source": "def assert_match_syntax_error(match, template, error_mode: nil)\n      exception = assert_raises(Liquid::SyntaxError) do\n        Template.parse(template, line_numbers: true, error_mode: error_mode&.to_sym).render\n      end\n      assert_match(match, exception.message)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 56,
    "raw_source": "def assert_syntax_error(template, error_mode: nil)\n      assert_match_syntax_error(\"\", template, error_mode: error_mode)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 60,
    "raw_source": "def assert_usage_increment(name, times: 1)\n      old_method = Liquid::Usage.method(:increment)\n      calls = 0\n      begin\n        Liquid::Usage.singleton_class.send(:remove_method, :increment)\n        Liquid::Usage.define_singleton_method(:increment) do |got_name|\n          calls += 1 if got_name == name\n          old_method.call(got_name)\n        end\n        yield\n      ensure\n        Liquid::Usage.singleton_class.send(:remove_method, :increment)\n        Liquid::Usage.define_singleton_method(:increment, old_method)\n      end\n      assert_equal(times, calls, \"Number of calls to Usage.increment with #{name.inspect}\")\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 77,
    "raw_source": "def with_global_filter(*globals, &blk)\n      environment = Liquid::Environment.build do |w|\n        w.register_filters(globals)\n      end\n\n      Environment.dangerously_override(environment, &blk)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 85,
    "raw_source": "def with_error_mode(mode)\n      old_mode = Liquid::Environment.default.error_mode\n      Liquid::Environment.default.error_mode = mode\n      yield\n    ensure\n      Liquid::Environment.default.error_mode = old_mode\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 93,
    "raw_source": "def with_custom_tag(tag_name, tag_class, &block)\n      environment = Liquid::Environment.default.dup\n      environment.register_tag(tag_name, tag_class)\n\n      Environment.dangerously_override(environment, &block)\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 103,
    "raw_source": "def to_liquid\n    'foobar'\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 109,
    "raw_source": "def initialize(settings)\n    super()\n    @settings = settings\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 114,
    "raw_source": "def liquid_method_missing(key)\n    @settings[key]\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 120,
    "raw_source": "def initialize(value)\n    super()\n    @value = value.to_i\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 125,
    "raw_source": "def to_s\n    @value.to_s\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 129,
    "raw_source": "def to_liquid_value\n    @value\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 135,
    "raw_source": "def initialize(value)\n    super()\n    @value = value\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 140,
    "raw_source": "def to_liquid_value\n    @value\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 144,
    "raw_source": "def to_s\n    @value ? \"Yay\" : \"Nay\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 152,
    "raw_source": "def initialize(value)\n    super()\n    @value = value\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 157,
    "raw_source": "def to_liquid_value\n    @value\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 161,
    "raw_source": "def to_s\n    @value\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 165,
    "raw_source": "def to_str\n    @value\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 169,
    "raw_source": "def inspect\n    \"#<StringDrop @value=#{@value.inspect}>\"\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 173,
    "raw_source": "def <=>(other)\n    to_liquid_value <=> Liquid::Utils.to_liquid_value(other)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 179,
    "raw_source": "def standard_error\n    raise Liquid::StandardError, 'standard error'\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 183,
    "raw_source": "def argument_error\n    raise Liquid::ArgumentError, 'argument error'\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 187,
    "raw_source": "def syntax_error\n    raise Liquid::SyntaxError, 'syntax error'\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 191,
    "raw_source": "def runtime_error\n    raise 'runtime error'\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 195,
    "raw_source": "def exception\n    raise Exception, 'exception'\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 203,
    "raw_source": "def initialize(values)\n    @file_read_count = 0\n    @values          = values\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 208,
    "raw_source": "def read_template_file(template_path)\n    @file_read_count += 1\n    @values.fetch(template_path)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 217,
    "raw_source": "def initialize\n    @count = 0\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/test_helper.rb",
    "start_line": 221,
    "raw_source": "def for(template_name)\n    @count += 1\n    template = Liquid::Template.new\n    template.name = \"some/path/\" + template_name\n    template\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/block_unit_test.rb",
    "start_line": 8,
    "raw_source": "def test_blankspace\n    template = Liquid::Template.parse(\"  \")\n    assert_equal([\"  \"], template.root.nodelist)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/block_unit_test.rb",
    "start_line": 13,
    "raw_source": "def test_variable_beginning\n    template = Liquid::Template.parse(\"{{funk}}  \")\n    assert_equal(2, template.root.nodelist.size)\n    assert_equal(Variable, template.root.nodelist[0].class)\n    assert_equal(String, template.root.nodelist[1].class)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/block_unit_test.rb",
    "start_line": 20,
    "raw_source": "def test_variable_end\n    template = Liquid::Template.parse(\"  {{funk}}\")\n    assert_equal(2, template.root.nodelist.size)\n    assert_equal(String, template.root.nodelist[0].class)\n    assert_equal(Variable, template.root.nodelist[1].class)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/block_unit_test.rb",
    "start_line": 27,
    "raw_source": "def test_variable_middle\n    template = Liquid::Template.parse(\"  {{funk}}  \")\n    assert_equal(3, template.root.nodelist.size)\n    assert_equal(String, template.root.nodelist[0].class)\n    assert_equal(Variable, template.root.nodelist[1].class)\n    assert_equal(String, template.root.nodelist[2].class)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/block_unit_test.rb",
    "start_line": 35,
    "raw_source": "def test_variable_with_multibyte_character\n    template = Liquid::Template.parse(\"{{ '❤️' }}\")\n    assert_equal(1, template.root.nodelist.size)\n    assert_equal(Variable, template.root.nodelist[0].class)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/block_unit_test.rb",
    "start_line": 41,
    "raw_source": "def test_variable_many_embedded_fragments\n    template = Liquid::Template.parse(\"  {{funk}} {{so}} {{brother}} \")\n    assert_equal(7, template.root.nodelist.size)\n    assert_equal(\n      [String, Variable, String, Variable, String, Variable, String],\n      block_types(template.root.nodelist),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/block_unit_test.rb",
    "start_line": 50,
    "raw_source": "def test_comment_tag_with_block\n    template = Liquid::Template.parse(\"  {% comment %} {% endcomment %} \")\n    assert_equal([String, Comment, String], block_types(template.root.nodelist))\n    assert_equal(3, template.root.nodelist.size)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/block_unit_test.rb",
    "start_line": 56,
    "raw_source": "def test_doc_tag_with_block\n    template = Liquid::Template.parse(\"  {% doc %} {% enddoc %} \")\n    assert_equal([String, Doc, String], block_types(template.root.nodelist))\n    assert_equal(3, template.root.nodelist.size)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/block_unit_test.rb",
    "start_line": 64,
    "raw_source": "def block_types(nodelist)\n    nodelist.collect(&:class)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 8,
    "raw_source": "def setup\n    @context = Liquid::Context.new\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 12,
    "raw_source": "def test_basic_condition\n    assert_equal(false, Condition.new(1, '==', 2).evaluate(Context.new))\n    assert_equal(true,  Condition.new(1, '==', 1).evaluate(Context.new))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 17,
    "raw_source": "def test_default_operators_evalute_true\n    assert_evaluates_true(1, '==', 1)\n    assert_evaluates_true(1, '!=', 2)\n    assert_evaluates_true(1, '<>', 2)\n    assert_evaluates_true(1, '<', 2)\n    assert_evaluates_true(2, '>', 1)\n    assert_evaluates_true(1, '>=', 1)\n    assert_evaluates_true(2, '>=', 1)\n    assert_evaluates_true(1, '<=', 2)\n    assert_evaluates_true(1, '<=', 1)\n    # negative numbers\n    assert_evaluates_true(1, '>', -1)\n    assert_evaluates_true(-1, '<', 1)\n    assert_evaluates_true(1.0, '>', -1.0)\n    assert_evaluates_true(-1.0, '<', 1.0)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 34,
    "raw_source": "def test_default_operators_evalute_false\n    assert_evaluates_false(1, '==', 2)\n    assert_evaluates_false(1, '!=', 1)\n    assert_evaluates_false(1, '<>', 1)\n    assert_evaluates_false(1, '<', 0)\n    assert_evaluates_false(2, '>', 4)\n    assert_evaluates_false(1, '>=', 3)\n    assert_evaluates_false(2, '>=', 4)\n    assert_evaluates_false(1, '<=', 0)\n    assert_evaluates_false(1, '<=', 0)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 46,
    "raw_source": "def test_contains_works_on_strings\n    assert_evaluates_true('bob', 'contains', 'o')\n    assert_evaluates_true('bob', 'contains', 'b')\n    assert_evaluates_true('bob', 'contains', 'bo')\n    assert_evaluates_true('bob', 'contains', 'ob')\n    assert_evaluates_true('bob', 'contains', 'bob')\n\n    assert_evaluates_false('bob', 'contains', 'bob2')\n    assert_evaluates_false('bob', 'contains', 'a')\n    assert_evaluates_false('bob', 'contains', '---')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 58,
    "raw_source": "def test_contains_binary_encoding_compatibility_with_utf8\n    assert_evaluates_true('🙈'.b, 'contains', '🙈')\n    assert_evaluates_true('🙈', 'contains', '🙈'.b)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 63,
    "raw_source": "def test_invalid_comparation_operator\n    assert_evaluates_argument_error(1, '~~', 0)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 67,
    "raw_source": "def test_comparation_of_int_and_str\n    assert_evaluates_argument_error('1', '>', 0)\n    assert_evaluates_argument_error('1', '<', 0)\n    assert_evaluates_argument_error('1', '>=', 0)\n    assert_evaluates_argument_error('1', '<=', 0)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 74,
    "raw_source": "def test_hash_compare_backwards_compatibility\n    assert_nil(Condition.new({}, '>', 2).evaluate(Context.new))\n    assert_nil(Condition.new(2, '>', {}).evaluate(Context.new))\n    assert_equal(false, Condition.new({}, '==', 2).evaluate(Context.new))\n    assert_equal(true, Condition.new({ 'a' => 1 }, '==', 'a' => 1).evaluate(Context.new))\n    assert_equal(true, Condition.new({ 'a' => 2 }, 'contains', 'a').evaluate(Context.new))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 82,
    "raw_source": "def test_contains_works_on_arrays\n    @context          = Liquid::Context.new\n    @context['array'] = [1, 2, 3, 4, 5]\n    array_expr        = VariableLookup.new(\"array\")\n\n    assert_evaluates_false(array_expr, 'contains', 0)\n    assert_evaluates_true(array_expr, 'contains', 1)\n    assert_evaluates_true(array_expr, 'contains', 2)\n    assert_evaluates_true(array_expr, 'contains', 3)\n    assert_evaluates_true(array_expr, 'contains', 4)\n    assert_evaluates_true(array_expr, 'contains', 5)\n    assert_evaluates_false(array_expr, 'contains', 6)\n    assert_evaluates_false(array_expr, 'contains', \"1\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 97,
    "raw_source": "def test_contains_returns_false_for_nil_operands\n    @context = Liquid::Context.new\n    assert_evaluates_false(VariableLookup.new('not_assigned'), 'contains', '0')\n    assert_evaluates_false(0, 'contains', VariableLookup.new('not_assigned'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 103,
    "raw_source": "def test_contains_return_false_on_wrong_data_type\n    assert_evaluates_false(1, 'contains', 0)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 107,
    "raw_source": "def test_contains_with_string_left_operand_coerces_right_operand_to_string\n    assert_evaluates_true(' 1 ', 'contains', 1)\n    assert_evaluates_false(' 1 ', 'contains', 2)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 112,
    "raw_source": "def test_or_condition\n    condition = Condition.new(1, '==', 2)\n    assert_equal(false, condition.evaluate(Context.new))\n\n    condition.or(Condition.new(2, '==', 1))\n\n    assert_equal(false, condition.evaluate(Context.new))\n\n    condition.or(Condition.new(1, '==', 1))\n\n    assert_equal(true, condition.evaluate(Context.new))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 125,
    "raw_source": "def test_and_condition\n    condition = Condition.new(1, '==', 1)\n\n    assert_equal(true, condition.evaluate(Context.new))\n\n    condition.and(Condition.new(2, '==', 2))\n\n    assert_equal(true, condition.evaluate(Context.new))\n\n    condition.and(Condition.new(2, '==', 1))\n\n    assert_equal(false, condition.evaluate(Context.new))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 139,
    "raw_source": "def test_should_allow_custom_proc_operator\n    Condition.operators['starts_with'] = proc { |_cond, left, right| left =~ /^#{right}/ }\n\n    assert_evaluates_true('bob', 'starts_with', 'b')\n    assert_evaluates_false('bob', 'starts_with', 'o')\n  ensure\n    Condition.operators.delete('starts_with')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 148,
    "raw_source": "def test_left_or_right_may_contain_operators\n    @context        = Liquid::Context.new\n    @context['one'] = @context['another'] = \"gnomeslab-and-or-liquid\"\n\n    assert_evaluates_true(VariableLookup.new(\"one\"), '==', VariableLookup.new(\"another\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 155,
    "raw_source": "def test_default_context_is_deprecated\n    if Gem::Version.new(Liquid::VERSION) >= Gem::Version.new('6.0.0')\n      flunk(\"Condition#evaluate without a context argument is to be removed\")\n    end\n\n    _out, err = capture_io do\n      assert_equal(true, Condition.new(1, '==', 1).evaluate)\n    end\n\n    expected = \"DEPRECATION WARNING: Condition#evaluate without a context argument is deprecated\" \\\n      \" and will be removed from Liquid 6.0.0.\"\n    assert_includes(err.lines.map(&:strip), expected)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 171,
    "raw_source": "def assert_evaluates_true(left, op, right)\n    assert(\n      Condition.new(left, op, right).evaluate(@context),\n      \"Evaluated false: #{left.inspect} #{op} #{right.inspect}\",\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 178,
    "raw_source": "def assert_evaluates_false(left, op, right)\n    assert(\n      !Condition.new(left, op, right).evaluate(@context),\n      \"Evaluated true: #{left.inspect} #{op} #{right.inspect}\",\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/condition_unit_test.rb",
    "start_line": 185,
    "raw_source": "def assert_evaluates_argument_error(left, op, right)\n    assert_raises(Liquid::ArgumentError) do\n      Condition.new(left, op, right).evaluate(@context)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/environment_filter_test.rb",
    "start_line": 9,
    "raw_source": "def public_filter\n      \"public\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/environment_filter_test.rb",
    "start_line": 13,
    "raw_source": "def private_filter\n      \"private\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/environment_filter_test.rb",
    "start_line": 20,
    "raw_source": "def late_added_filter(_input)\n      \"filtered\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/environment_filter_test.rb",
    "start_line": 25,
    "raw_source": "def setup\n    @environment = Liquid::Environment.build do |env|\n      env.register_filter(AccessScopeFilters)\n    end\n\n    @context = Context.build(environment: @environment)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/environment_filter_test.rb",
    "start_line": 33,
    "raw_source": "def test_strainer\n    strainer = @environment.create_strainer(@context)\n    assert_equal(5, strainer.invoke('size', 'input'))\n    assert_equal(\"public\", strainer.invoke(\"public_filter\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/environment_filter_test.rb",
    "start_line": 39,
    "raw_source": "def test_strainer_raises_argument_error\n    strainer = @environment.create_strainer(@context)\n    assert_raises(Liquid::ArgumentError) do\n      strainer.invoke(\"public_filter\", 1)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/environment_filter_test.rb",
    "start_line": 46,
    "raw_source": "def test_strainer_argument_error_contains_backtrace\n    strainer = @environment.create_strainer(@context)\n\n    exception = assert_raises(Liquid::ArgumentError) do\n      strainer.invoke(\"public_filter\", 1)\n    end\n\n    assert_match(\n      /\\ALiquid error: wrong number of arguments \\((1 for 0|given 1, expected 0)\\)\\z/,\n      exception.message,\n    )\n\n    source = AccessScopeFilters.instance_method(:public_filter).source_location\n    assert_equal(source[0..1].map(&:to_s), exception.backtrace[0].split(':')[0..1])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/environment_filter_test.rb",
    "start_line": 62,
    "raw_source": "def test_strainer_only_invokes_public_filter_methods\n    strainer = @environment.create_strainer(@context)\n    assert_equal(false, strainer.class.invokable?('__test__'))\n    assert_equal(false, strainer.class.invokable?('test'))\n    assert_equal(false, strainer.class.invokable?('instance_eval'))\n    assert_equal(false, strainer.class.invokable?('__send__'))\n    assert_equal(true, strainer.class.invokable?('size')) # from the standard lib\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/environment_filter_test.rb",
    "start_line": 71,
    "raw_source": "def test_strainer_returns_nil_if_no_filter_method_found\n    strainer = @environment.create_strainer(@context)\n    assert_nil(strainer.invoke(\"private_filter\"))\n    assert_nil(strainer.invoke(\"undef_the_filter\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/environment_filter_test.rb",
    "start_line": 77,
    "raw_source": "def test_strainer_returns_first_argument_if_no_method_and_arguments_given\n    strainer = @environment.create_strainer(@context)\n    assert_equal(\"password\", strainer.invoke(\"undef_the_method\", \"password\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/environment_filter_test.rb",
    "start_line": 82,
    "raw_source": "def test_strainer_only_allows_methods_defined_in_filters\n    strainer = @environment.create_strainer(@context)\n    assert_equal(\"1 + 1\", strainer.invoke(\"instance_eval\", \"1 + 1\"))\n    assert_equal(\"puts\",  strainer.invoke(\"__send__\", \"puts\", \"Hi Mom\"))\n    assert_equal(\"has_method?\", strainer.invoke(\"invoke\", \"has_method?\", \"invoke\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/environment_filter_test.rb",
    "start_line": 89,
    "raw_source": "def test_strainer_uses_a_class_cache_to_avoid_method_cache_invalidation\n    a = Module.new\n    b = Module.new\n\n    strainer = @environment.create_strainer(@context, [a, b])\n\n    assert_kind_of(StrainerTemplate, strainer)\n    assert_kind_of(a, strainer)\n    assert_kind_of(b, strainer)\n    assert_kind_of(Liquid::StandardFilters, strainer)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/environment_filter_test.rb",
    "start_line": 101,
    "raw_source": "def test_add_global_filter_clears_cache\n    assert_equal('input', @environment.create_strainer(@context).invoke('late_added_filter', 'input'))\n\n    @environment.register_filter(LateAddedFilter)\n\n    assert_equal('filtered', @environment.create_strainer(nil).invoke('late_added_filter', 'input'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/environment_test.rb",
    "start_line": 9,
    "raw_source": "def render(_context)\n      'Unsubscribe Footer'\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/environment_test.rb",
    "start_line": 14,
    "raw_source": "def test_custom_tag\n    email_environment = Liquid::Environment.build do |environment|\n      environment.register_tag(\"unsubscribe_footer\", UnsubscribeFooter)\n    end\n\n    assert(email_environment.tags[\"unsubscribe_footer\"])\n    assert(email_environment.tag_for_name(\"unsubscribe_footer\"))\n    template = Liquid::Template.parse(\"{% unsubscribe_footer %}\", environment: email_environment)\n\n    assert_equal('Unsubscribe Footer', template.render)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/file_system_unit_test.rb",
    "start_line": 8,
    "raw_source": "def test_default\n    assert_raises(FileSystemError) do\n      BlankFileSystem.new.read_template_file(\"dummy\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/file_system_unit_test.rb",
    "start_line": 14,
    "raw_source": "def test_local\n    file_system = Liquid::LocalFileSystem.new(\"/some/path\")\n    assert_equal(\"/some/path/_mypartial.liquid\", file_system.full_path(\"mypartial\"))\n    assert_equal(\"/some/path/dir/_mypartial.liquid\", file_system.full_path(\"dir/mypartial\"))\n\n    assert_raises(FileSystemError) do\n      file_system.full_path(\"../dir/mypartial\")\n    end\n\n    assert_raises(FileSystemError) do\n      file_system.full_path(\"/dir/../../dir/mypartial\")\n    end\n\n    assert_raises(FileSystemError) do\n      file_system.full_path(\"/etc/passwd\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/file_system_unit_test.rb",
    "start_line": 32,
    "raw_source": "def test_custom_template_filename_patterns\n    file_system = Liquid::LocalFileSystem.new(\"/some/path\", \"%s.html\")\n    assert_equal(\"/some/path/mypartial.html\", file_system.full_path(\"mypartial\"))\n    assert_equal(\"/some/path/dir/mypartial.html\", file_system.full_path(\"dir/mypartial\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/i18n_unit_test.rb",
    "start_line": 8,
    "raw_source": "def setup\n    @i18n = I18n.new(fixture(\"en_locale.yml\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/i18n_unit_test.rb",
    "start_line": 12,
    "raw_source": "def test_simple_translate_string\n    assert_equal(\"less is more\", @i18n.translate(\"simple\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/i18n_unit_test.rb",
    "start_line": 16,
    "raw_source": "def test_nested_translate_string\n    assert_equal(\"something wasn't right\", @i18n.translate(\"errors.syntax.oops\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/i18n_unit_test.rb",
    "start_line": 20,
    "raw_source": "def test_single_string_interpolation\n    assert_equal(\"something different\", @i18n.translate(\"whatever\", something: \"different\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/i18n_unit_test.rb",
    "start_line": 30,
    "raw_source": "def test_raises_unknown_translation\n    assert_raises(I18n::TranslationError) do\n      @i18n.translate(\"doesnt_exist\")\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/i18n_unit_test.rb",
    "start_line": 36,
    "raw_source": "def test_sets_default_path_to_en\n    assert_equal(I18n::DEFAULT_LOCALE, I18n.new.path)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 8,
    "raw_source": "def test_variable\n    assert_equal(\n      [\"test\"],\n      visit(%({{ test }})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 15,
    "raw_source": "def test_varible_with_filter\n    assert_equal(\n      [\"test\", \"infilter\"],\n      visit(%({{ test | split: infilter }})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 22,
    "raw_source": "def test_dynamic_variable\n    assert_equal(\n      [\"test\", \"inlookup\"],\n      visit(%({{ test[inlookup] }})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 29,
    "raw_source": "def test_echo\n    assert_equal(\n      [\"test\"],\n      visit(%({% echo test %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 36,
    "raw_source": "def test_if_condition\n    assert_equal(\n      [\"test\"],\n      visit(%({% if test %}{% endif %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 43,
    "raw_source": "def test_complex_if_condition\n    assert_equal(\n      [\"test\"],\n      visit(%({% if 1 == 1 and 2 == test %}{% endif %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 50,
    "raw_source": "def test_if_body\n    assert_equal(\n      [\"test\"],\n      visit(%({% if 1 == 1 %}{{ test }}{% endif %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 57,
    "raw_source": "def test_unless_condition\n    assert_equal(\n      [\"test\"],\n      visit(%({% unless test %}{% endunless %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 64,
    "raw_source": "def test_complex_unless_condition\n    assert_equal(\n      [\"test\"],\n      visit(%({% unless 1 == 1 and 2 == test %}{% endunless %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 71,
    "raw_source": "def test_unless_body\n    assert_equal(\n      [\"test\"],\n      visit(%({% unless 1 == 1 %}{{ test }}{% endunless %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 78,
    "raw_source": "def test_elsif_condition\n    assert_equal(\n      [\"test\"],\n      visit(%({% if 1 == 1 %}{% elsif test %}{% endif %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 85,
    "raw_source": "def test_complex_elsif_condition\n    assert_equal(\n      [\"test\"],\n      visit(%({% if 1 == 1 %}{% elsif 1 == 1 and 2 == test %}{% endif %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 92,
    "raw_source": "def test_elsif_body\n    assert_equal(\n      [\"test\"],\n      visit(%({% if 1 == 1 %}{% elsif 2 == 2 %}{{ test }}{% endif %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 99,
    "raw_source": "def test_else_body\n    assert_equal(\n      [\"test\"],\n      visit(%({% if 1 == 1 %}{% else %}{{ test }}{% endif %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 106,
    "raw_source": "def test_case_left\n    assert_equal(\n      [\"test\"],\n      visit(%({% case test %}{% endcase %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 113,
    "raw_source": "def test_case_condition\n    assert_equal(\n      [\"test\"],\n      visit(%({% case 1 %}{% when test %}{% endcase %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 120,
    "raw_source": "def test_case_when_body\n    assert_equal(\n      [\"test\"],\n      visit(%({% case 1 %}{% when 2 %}{{ test }}{% endcase %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 127,
    "raw_source": "def test_case_else_body\n    assert_equal(\n      [\"test\"],\n      visit(%({% case 1 %}{% else %}{{ test }}{% endcase %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 134,
    "raw_source": "def test_for_in\n    assert_equal(\n      [\"test\"],\n      visit(%({% for x in test %}{% endfor %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 141,
    "raw_source": "def test_for_limit\n    assert_equal(\n      [\"test\"],\n      visit(%({% for x in (1..5) limit: test %}{% endfor %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 148,
    "raw_source": "def test_for_offset\n    assert_equal(\n      [\"test\"],\n      visit(%({% for x in (1..5) offset: test %}{% endfor %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 155,
    "raw_source": "def test_for_body\n    assert_equal(\n      [\"test\"],\n      visit(%({% for x in (1..5) %}{{ test }}{% endfor %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 162,
    "raw_source": "def test_for_range\n    assert_equal(\n      [\"test\"],\n      visit(%({% for x in (1..test) %}{% endfor %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 169,
    "raw_source": "def test_tablerow_in\n    assert_equal(\n      [\"test\"],\n      visit(%({% tablerow x in test %}{% endtablerow %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 176,
    "raw_source": "def test_tablerow_limit\n    assert_equal(\n      [\"test\"],\n      visit(%({% tablerow x in (1..5) limit: test %}{% endtablerow %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 183,
    "raw_source": "def test_tablerow_offset\n    assert_equal(\n      [\"test\"],\n      visit(%({% tablerow x in (1..5) offset: test %}{% endtablerow %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 190,
    "raw_source": "def test_tablerow_body\n    assert_equal(\n      [\"test\"],\n      visit(%({% tablerow x in (1..5) %}{{ test }}{% endtablerow %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 197,
    "raw_source": "def test_cycle\n    assert_equal(\n      [\"test\"],\n      visit(%({% cycle test %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 204,
    "raw_source": "def test_assign\n    assert_equal(\n      [\"test\"],\n      visit(%({% assign x = test %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 211,
    "raw_source": "def test_capture\n    assert_equal(\n      [\"test\"],\n      visit(%({% capture x %}{{ test }}{% endcapture %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 218,
    "raw_source": "def test_include\n    assert_equal(\n      [\"test\"],\n      visit(%({% include test %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 225,
    "raw_source": "def test_include_with\n    assert_equal(\n      [\"test\"],\n      visit(%({% include \"hai\" with test %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 232,
    "raw_source": "def test_include_for\n    assert_equal(\n      [\"test\"],\n      visit(%({% include \"hai\" for test %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 239,
    "raw_source": "def test_render_with\n    assert_equal(\n      [\"test\"],\n      visit(%({% render \"hai\" with test %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 246,
    "raw_source": "def test_render_for\n    assert_equal(\n      [\"test\"],\n      visit(%({% render \"hai\" for test %})),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 253,
    "raw_source": "def test_preserve_tree_structure\n    assert_equal(\n      [[nil, [\n        [nil, [[nil, [[\"other\", []]]]]],\n        [\"test\", []],\n        [\"xs\", []],\n      ]]],\n      traversal(%({% for x in xs offset: test %}{{ other }}{% endfor %})).visit,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 266,
    "raw_source": "def traversal(template)\n    ParseTreeVisitor\n      .for(Template.parse(template).root)\n      .add_callback_for(VariableLookup) { |node| node.name } # rubocop:disable Style/SymbolProc\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parse_tree_visitor_test.rb",
    "start_line": 272,
    "raw_source": "def visit(template)\n    traversal(template).visit.flatten.compact\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parser_unit_test.rb",
    "start_line": 8,
    "raw_source": "def test_consume\n    p = new_parser(\"wat: 7\")\n    assert_equal('wat', p.consume(:id))\n    assert_equal(':', p.consume(:colon))\n    assert_equal('7', p.consume(:number))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parser_unit_test.rb",
    "start_line": 15,
    "raw_source": "def test_jump\n    p = new_parser(\"wat: 7\")\n    p.jump(2)\n    assert_equal('7', p.consume(:number))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parser_unit_test.rb",
    "start_line": 21,
    "raw_source": "def test_consume?\n    p = new_parser(\"wat: 7\")\n    assert_equal('wat', p.consume?(:id))\n    assert_equal(false, p.consume?(:dot))\n    assert_equal(':', p.consume(:colon))\n    assert_equal('7', p.consume?(:number))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parser_unit_test.rb",
    "start_line": 29,
    "raw_source": "def test_id?\n    p = new_parser(\"wat 6 Peter Hegemon\")\n    assert_equal('wat', p.id?('wat'))\n    assert_equal(false, p.id?('endgame'))\n    assert_equal('6', p.consume(:number))\n    assert_equal('Peter', p.id?('Peter'))\n    assert_equal(false, p.id?('Achilles'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parser_unit_test.rb",
    "start_line": 38,
    "raw_source": "def test_look\n    p = new_parser(\"wat 6 Peter Hegemon\")\n    assert_equal(true, p.look(:id))\n    assert_equal('wat', p.consume(:id))\n    assert_equal(false, p.look(:comparison))\n    assert_equal(true, p.look(:number))\n    assert_equal(true, p.look(:id, 1))\n    assert_equal(false, p.look(:number, 1))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parser_unit_test.rb",
    "start_line": 48,
    "raw_source": "def test_expressions\n    p = new_parser(\"hi.there hi?[5].there? hi.there.bob\")\n    assert_equal('hi.there', p.expression)\n    assert_equal('hi?[5].there?', p.expression)\n    assert_equal('hi.there.bob', p.expression)\n\n    p = new_parser(\"567 6.0 'lol' \\\"wut\\\"\")\n    assert_equal('567', p.expression)\n    assert_equal('6.0', p.expression)\n    assert_equal(\"'lol'\", p.expression)\n    assert_equal('\"wut\"', p.expression)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parser_unit_test.rb",
    "start_line": 61,
    "raw_source": "def test_ranges\n    p = new_parser(\"(5..7) (1.5..9.6) (young..old) (hi[5].wat..old)\")\n    assert_equal('(5..7)', p.expression)\n    assert_equal('(1.5..9.6)', p.expression)\n    assert_equal('(young..old)', p.expression)\n    assert_equal('(hi[5].wat..old)', p.expression)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parser_unit_test.rb",
    "start_line": 69,
    "raw_source": "def test_arguments\n    p = new_parser(\"filter: hi.there[5], keyarg: 7\")\n    assert_equal('filter', p.consume(:id))\n    assert_equal(':', p.consume(:colon))\n    assert_equal('hi.there[5]', p.argument)\n    assert_equal(',', p.consume(:comma))\n    assert_equal('keyarg: 7', p.argument)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parser_unit_test.rb",
    "start_line": 78,
    "raw_source": "def test_invalid_expression\n    assert_raises(SyntaxError) do\n      p = new_parser(\"==\")\n      p.expression\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/parser_unit_test.rb",
    "start_line": 87,
    "raw_source": "def new_parser(str)\n    Parser.new(StringScanner.new(str))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/partial_cache_unit_test.rb",
    "start_line": 6,
    "raw_source": "def test_uses_the_file_system_register_if_present\n    context = Liquid::Context.build(\n      registers: {\n        file_system: StubFileSystem.new('my_partial' => 'my partial body'),\n      },\n    )\n\n    partial = Liquid::PartialCache.load(\n      'my_partial',\n      context: context,\n      parse_context: Liquid::ParseContext.new,\n    )\n\n    assert_equal('my partial body', partial.render)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/partial_cache_unit_test.rb",
    "start_line": 22,
    "raw_source": "def test_reads_from_the_file_system_only_once_per_file\n    file_system = StubFileSystem.new('my_partial' => 'some partial body')\n    context     = Liquid::Context.build(\n      registers: { file_system: file_system },\n    )\n\n    2.times do\n      Liquid::PartialCache.load(\n        'my_partial',\n        context: context,\n        parse_context: Liquid::ParseContext.new,\n      )\n    end\n\n    assert_equal(1, file_system.file_read_count)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/partial_cache_unit_test.rb",
    "start_line": 39,
    "raw_source": "def test_cache_state_is_stored_per_context\n    parse_context      = Liquid::ParseContext.new\n    shared_file_system = StubFileSystem.new(\n      'my_partial' => 'my shared value',\n    )\n    context_one = Liquid::Context.build(\n      registers: {\n        file_system: shared_file_system,\n      },\n    )\n    context_two = Liquid::Context.build(\n      registers: {\n        file_system: shared_file_system,\n      },\n    )\n\n    2.times do\n      Liquid::PartialCache.load(\n        'my_partial',\n        context: context_one,\n        parse_context: parse_context,\n      )\n    end\n\n    Liquid::PartialCache.load(\n      'my_partial',\n      context: context_two,\n      parse_context: parse_context,\n    )\n\n    assert_equal(2, shared_file_system.file_read_count)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/partial_cache_unit_test.rb",
    "start_line": 72,
    "raw_source": "def test_cache_is_not_broken_when_a_different_parse_context_is_used\n    file_system = StubFileSystem.new('my_partial' => 'some partial body')\n    context     = Liquid::Context.build(\n      registers: { file_system: file_system },\n    )\n\n    Liquid::PartialCache.load(\n      'my_partial',\n      context: context,\n      parse_context: Liquid::ParseContext.new(my_key: 'value one'),\n    )\n    Liquid::PartialCache.load(\n      'my_partial',\n      context: context,\n      parse_context: Liquid::ParseContext.new(my_key: 'value two'),\n    )\n\n    # Technically what we care about is that the file was parsed twice,\n    # but measuring file reads is an OK proxy for this.\n    assert_equal(1, file_system.file_read_count)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/partial_cache_unit_test.rb",
    "start_line": 94,
    "raw_source": "def test_uses_default_template_factory_when_no_template_factory_found_in_register\n    context = Liquid::Context.build(\n      registers: {\n        file_system: StubFileSystem.new('my_partial' => 'my partial body'),\n      },\n    )\n\n    partial = Liquid::PartialCache.load(\n      'my_partial',\n      context: context,\n      parse_context: Liquid::ParseContext.new,\n    )\n\n    assert_equal('my partial body', partial.render)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/partial_cache_unit_test.rb",
    "start_line": 110,
    "raw_source": "def test_uses_template_factory_register_if_present\n    template_factory = StubTemplateFactory.new\n    context = Liquid::Context.build(\n      registers: {\n        file_system: StubFileSystem.new('my_partial' => 'my partial body'),\n        template_factory: template_factory,\n      },\n    )\n\n    partial = Liquid::PartialCache.load(\n      'my_partial',\n      context: context,\n      parse_context: Liquid::ParseContext.new,\n    )\n\n    assert_equal('my partial body', partial.render)\n    assert_equal(1, template_factory.count)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/partial_cache_unit_test.rb",
    "start_line": 129,
    "raw_source": "def test_cache_state_is_shared_for_subcontexts\n    parse_context      = Liquid::ParseContext.new\n    shared_file_system = StubFileSystem.new(\n      'my_partial' => 'my shared value',\n    )\n    context = Liquid::Context.build(\n      registers: Liquid::Registers.new(\n        file_system: shared_file_system,\n      ),\n    )\n    subcontext = context.new_isolated_subcontext\n\n    assert_equal(subcontext.registers[:cached_partials].object_id, context.registers[:cached_partials].object_id)\n\n    2.times do\n      Liquid::PartialCache.load(\n        'my_partial',\n        context: context,\n        parse_context: parse_context,\n      )\n\n      Liquid::PartialCache.load(\n        'my_partial',\n        context: subcontext,\n        parse_context: parse_context,\n      )\n    end\n\n    assert_equal(1, shared_file_system.file_read_count)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/partial_cache_unit_test.rb",
    "start_line": 160,
    "raw_source": "def test_uses_template_name_from_template_factory\n    template_factory = StubTemplateFactory.new\n    context = Liquid::Context.build(\n      registers: {\n        file_system: StubFileSystem.new('my_partial' => 'my partial body'),\n        template_factory: template_factory,\n      },\n    )\n\n    partial = Liquid::PartialCache.load(\n      'my_partial',\n      context: context,\n      parse_context: Liquid::ParseContext.new,\n    )\n\n    assert_equal('some/path/my_partial', partial.name)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/partial_cache_unit_test.rb",
    "start_line": 178,
    "raw_source": "def test_includes_error_mode_into_template_cache\n    template_factory = StubTemplateFactory.new\n    context = Liquid::Context.build(\n      registers: {\n        file_system: StubFileSystem.new('my_partial' => 'my partial body'),\n        template_factory: template_factory,\n      },\n    )\n\n    [:lax, :warn, :strict].each do |error_mode|\n      Liquid::PartialCache.load(\n        'my_partial',\n        context: context,\n        parse_context: Liquid::ParseContext.new(error_mode: error_mode),\n      )\n    end\n\n    assert_equal(\n      [\"my_partial:lax\", \"my_partial:warn\", \"my_partial:strict\"],\n      context.registers[:cached_partials].keys,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/regexp_unit_test.rb",
    "start_line": 9,
    "raw_source": "def test_empty\n    assert_equal([], ''.scan(QuotedFragment))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/regexp_unit_test.rb",
    "start_line": 13,
    "raw_source": "def test_quote\n    assert_equal(['\"arg 1\"'], '\"arg 1\"'.scan(QuotedFragment))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/regexp_unit_test.rb",
    "start_line": 17,
    "raw_source": "def test_words\n    assert_equal(['arg1', 'arg2'], 'arg1 arg2'.scan(QuotedFragment))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/regexp_unit_test.rb",
    "start_line": 21,
    "raw_source": "def test_tags\n    assert_equal(['<tr>', '</tr>'], '<tr> </tr>'.scan(QuotedFragment))\n    assert_equal(['<tr></tr>'], '<tr></tr>'.scan(QuotedFragment))\n    assert_equal(['<style', 'class=\"hello\">', '</style>'], %(<style class=\"hello\">' </style>).scan(QuotedFragment))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/regexp_unit_test.rb",
    "start_line": 27,
    "raw_source": "def test_double_quoted_words\n    assert_equal(['arg1', 'arg2', '\"arg 3\"'], 'arg1 arg2 \"arg 3\"'.scan(QuotedFragment))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/regexp_unit_test.rb",
    "start_line": 31,
    "raw_source": "def test_single_quoted_words\n    assert_equal(['arg1', 'arg2', \"'arg 3'\"], 'arg1 arg2 \\'arg 3\\''.scan(QuotedFragment))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/regexp_unit_test.rb",
    "start_line": 35,
    "raw_source": "def test_quoted_words_in_the_middle\n    assert_equal(['arg1', 'arg2', '\"arg 3\"', 'arg4'], 'arg1 arg2 \"arg 3\" arg4   '.scan(QuotedFragment))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/regexp_unit_test.rb",
    "start_line": 39,
    "raw_source": "def test_variable_parser\n    assert_equal(['var'],                               'var'.scan(VariableParser))\n    assert_equal(['[var]'],                             '[var]'.scan(VariableParser))\n    assert_equal(['var', 'method'],                     'var.method'.scan(VariableParser))\n    assert_equal(['var', '[method]'],                   'var[method]'.scan(VariableParser))\n    assert_equal(['var', '[method]', '[0]'],            'var[method][0]'.scan(VariableParser))\n    assert_equal(['var', '[\"method\"]', '[0]'],          'var[\"method\"][0]'.scan(VariableParser))\n    assert_equal(['var', '[method]', '[0]', 'method'],  'var[method][0].method'.scan(VariableParser))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/regexp_unit_test.rb",
    "start_line": 49,
    "raw_source": "def test_variable_parser_with_large_input\n    Timeout.timeout(1) { assert_equal(['[var]'], '[var]'.scan(VariableParser)) }\n\n    very_long_string = \"foo\" * 1000\n\n    # valid dynamic lookup\n    Timeout.timeout(1) { assert_equal([\"[#{very_long_string}]\"], \"[#{very_long_string}]\".scan(VariableParser)) }\n    # invalid dynamic lookup with missing closing bracket\n    Timeout.timeout(1) { assert_equal([very_long_string], \"[#{very_long_string}\".scan(VariableParser)) }\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/registers_unit_test.rb",
    "start_line": 8,
    "raw_source": "def test_set\n    static_register = Registers.new(a: 1, b: 2)\n    static_register[:b] = 22\n    static_register[:c] = 33\n\n    assert_equal(1, static_register[:a])\n    assert_equal(22, static_register[:b])\n    assert_equal(33, static_register[:c])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/registers_unit_test.rb",
    "start_line": 18,
    "raw_source": "def test_get_missing_key\n    static_register = Registers.new\n\n    assert_nil(static_register[:missing])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/registers_unit_test.rb",
    "start_line": 24,
    "raw_source": "def test_delete\n    static_register = Registers.new(a: 1, b: 2)\n    static_register[:b] = 22\n    static_register[:c] = 33\n\n    assert_nil(static_register.delete(:a))\n\n    assert_equal(22, static_register.delete(:b))\n\n    assert_equal(33, static_register.delete(:c))\n    assert_nil(static_register[:c])\n\n    assert_nil(static_register.delete(:d))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/registers_unit_test.rb",
    "start_line": 39,
    "raw_source": "def test_fetch\n    static_register = Registers.new(a: 1, b: 2)\n    static_register[:b] = 22\n    static_register[:c] = 33\n\n    assert_equal(1, static_register.fetch(:a))\n    assert_equal(1, static_register.fetch(:a, \"default\"))\n    assert_equal(22, static_register.fetch(:b))\n    assert_equal(22, static_register.fetch(:b, \"default\"))\n    assert_equal(33, static_register.fetch(:c))\n    assert_equal(33, static_register.fetch(:c, \"default\"))\n\n    assert_raises(KeyError) do\n      static_register.fetch(:d)\n    end\n    assert_equal(\"default\", static_register.fetch(:d, \"default\"))\n\n    result = static_register.fetch(:d) { \"default\" }\n    assert_equal(\"default\", result)\n\n    result = static_register.fetch(:d, \"default 1\") { \"default 2\" }\n    assert_equal(\"default 2\", result)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/registers_unit_test.rb",
    "start_line": 63,
    "raw_source": "def test_key\n    static_register = Registers.new(a: 1, b: 2)\n    static_register[:b] = 22\n    static_register[:c] = 33\n\n    assert_equal(true, static_register.key?(:a))\n    assert_equal(true, static_register.key?(:b))\n    assert_equal(true, static_register.key?(:c))\n    assert_equal(false, static_register.key?(:d))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/registers_unit_test.rb",
    "start_line": 74,
    "raw_source": "def test_static_register_can_be_frozen\n    static_register = Registers.new(a: 1)\n\n    static_register.static.freeze\n\n    assert_raises(RuntimeError) do\n      static_register.static[:a] = \"foo\"\n    end\n\n    assert_raises(RuntimeError) do\n      static_register.static[:b] = \"foo\"\n    end\n\n    assert_raises(RuntimeError) do\n      static_register.static.delete(:a)\n    end\n\n    assert_raises(RuntimeError) do\n      static_register.static.delete(:c)\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/registers_unit_test.rb",
    "start_line": 96,
    "raw_source": "def test_new_static_retains_static\n    static_register = Registers.new(a: 1, b: 2)\n    static_register[:b] = 22\n    static_register[:c] = 33\n\n    new_static_register = Registers.new(static_register)\n    new_static_register[:b] = 222\n\n    newest_static_register = Registers.new(new_static_register)\n    newest_static_register[:c] = 333\n\n    assert_equal(1, static_register[:a])\n    assert_equal(22, static_register[:b])\n    assert_equal(33, static_register[:c])\n\n    assert_equal(1, new_static_register[:a])\n    assert_equal(222, new_static_register[:b])\n    assert_nil(new_static_register[:c])\n\n    assert_equal(1, newest_static_register[:a])\n    assert_equal(2, newest_static_register[:b])\n    assert_equal(333, newest_static_register[:c])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/registers_unit_test.rb",
    "start_line": 120,
    "raw_source": "def test_multiple_instances_are_unique\n    static_register_1 = Registers.new(a: 1, b: 2)\n    static_register_1[:b] = 22\n    static_register_1[:c] = 33\n\n    static_register_2 = Registers.new(a: 10, b: 20)\n    static_register_2[:b] = 220\n    static_register_2[:c] = 330\n\n    assert_equal({ a: 1, b: 2 }, static_register_1.static)\n    assert_equal(1, static_register_1[:a])\n    assert_equal(22, static_register_1[:b])\n    assert_equal(33, static_register_1[:c])\n\n    assert_equal({ a: 10, b: 20 }, static_register_2.static)\n    assert_equal(10, static_register_2[:a])\n    assert_equal(220, static_register_2[:b])\n    assert_equal(330, static_register_2[:c])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/registers_unit_test.rb",
    "start_line": 140,
    "raw_source": "def test_initialization_reused_static_same_memory_object\n    static_register_1 = Registers.new(a: 1, b: 2)\n    static_register_1[:b] = 22\n    static_register_1[:c] = 33\n\n    static_register_2 = Registers.new(static_register_1)\n\n    assert_equal(1, static_register_2[:a])\n    assert_equal(2, static_register_2[:b])\n    assert_nil(static_register_2[:c])\n\n    static_register_1.static[:b] = 222\n    static_register_1.static[:c] = 333\n\n    assert_same(static_register_1.static, static_register_2.static)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/strainer_template_unit_test.rb",
    "start_line": 8,
    "raw_source": "def test_add_filter_when_wrong_filter_class\n    c = Context.new\n    s = c.strainer\n    wrong_filter = ->(v) { v.reverse }\n\n    exception = assert_raises(TypeError) do\n      s.class.add_filter(wrong_filter)\n    end\n    assert_equal(exception.message, \"wrong argument type Proc (expected Module)\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/strainer_template_unit_test.rb",
    "start_line": 22,
    "raw_source": "def public_filter\n      \"overriden as private\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/strainer_template_unit_test.rb",
    "start_line": 27,
    "raw_source": "def test_add_filter_raises_when_module_privately_overrides_registered_public_methods\n    error = assert_raises(Liquid::MethodOverrideError) do\n      Liquid::Environment.build do |env|\n        env.register_filter(PublicMethodOverrideFilter)\n        env.register_filter(PrivateMethodOverrideFilter)\n      end\n    end\n\n    assert_equal('Liquid error: Filter overrides registered public methods as non public: public_filter', error.message)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/strainer_template_unit_test.rb",
    "start_line": 41,
    "raw_source": "def public_filter\n      \"overriden as protected\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/strainer_template_unit_test.rb",
    "start_line": 46,
    "raw_source": "def test_add_filter_raises_when_module_overrides_registered_public_method_as_protected\n    error = assert_raises(Liquid::MethodOverrideError) do\n      Liquid::Environment.build do |env|\n        env.register_filter(PublicMethodOverrideFilter)\n        env.register_filter(ProtectedMethodOverrideFilter)\n      end\n    end\n\n    assert_equal('Liquid error: Filter overrides registered public methods as non public: public_filter', error.message)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/strainer_template_unit_test.rb",
    "start_line": 58,
    "raw_source": "def public_filter\n      \"public\"\n    end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/strainer_template_unit_test.rb",
    "start_line": 63,
    "raw_source": "def test_add_filter_does_not_raise_when_module_overrides_previously_registered_method\n    with_global_filter do\n      context = Context.new\n      context.add_filters([PublicMethodOverrideFilter])\n      strainer = context.strainer\n      assert(strainer.class.send(:filter_methods).include?('public_filter'))\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/strainer_template_unit_test.rb",
    "start_line": 72,
    "raw_source": "def test_add_filter_does_not_include_already_included_module\n    mod = Module.new do\n      class << self\n        attr_accessor :include_count\n        def included(_mod)\n          self.include_count += 1\n        end\n      end\n      self.include_count = 0\n    end\n    strainer = Context.new.strainer\n    strainer.class.add_filter(mod)\n    strainer.class.add_filter(mod)\n    assert_equal(1, mod.include_count)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/strainer_template_unit_test.rb",
    "start_line": 76,
    "raw_source": "def included(_mod)\n          self.include_count += 1\n        end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tag_unit_test.rb",
    "start_line": 8,
    "raw_source": "def test_tag\n    tag = Tag.parse('tag', \"\", new_tokenizer, ParseContext.new)\n    assert_equal('liquid::tag', tag.name)\n    assert_equal('', tag.render(Context.new))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tag_unit_test.rb",
    "start_line": 14,
    "raw_source": "def test_return_raw_text_of_tag\n    tag = Tag.parse(\"long_tag\", \"param1, param2, param3\", new_tokenizer, ParseContext.new)\n    assert_equal(\"long_tag param1, param2, param3\", tag.raw)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tag_unit_test.rb",
    "start_line": 19,
    "raw_source": "def test_tag_name_should_return_name_of_the_tag\n    tag = Tag.parse(\"some_tag\", \"\", new_tokenizer, ParseContext.new)\n    assert_equal('some_tag', tag.tag_name)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tag_unit_test.rb",
    "start_line": 25,
    "raw_source": "def render(_context); end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tag_unit_test.rb",
    "start_line": 28,
    "raw_source": "def test_tag_render_to_output_buffer_nil_value\n    custom_tag = CustomTag.parse(\"some_tag\", \"\", new_tokenizer, ParseContext.new)\n    assert_equal('some string', custom_tag.render_to_output_buffer(Context.new, \"some string\"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tag_unit_test.rb",
    "start_line": 35,
    "raw_source": "def new_tokenizer\n    Tokenizer.new(\n      source: \"\",\n      string_scanner: StringScanner.new(\"\"),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/case_tag_unit_test.rb",
    "start_line": 8,
    "raw_source": "def test_case_nodelist\n    template = Liquid::Template.parse('{% case var %}{% when true %}WHEN{% else %}ELSE{% endcase %}')\n    assert_equal(['WHEN', 'ELSE'], template.root.nodelist[0].nodelist.map(&:nodelist).flatten)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/comment_tag_unit_test.rb",
    "start_line": 6,
    "raw_source": "def test_comment_inside_liquid_tag\n    assert_template_result(\"\", <<~LIQUID.chomp)\n      {% liquid\n        if 1 != 1\n        comment\n        else\n          echo 123\n        endcomment\n        endif\n      %}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/comment_tag_unit_test.rb",
    "start_line": 19,
    "raw_source": "def test_does_not_parse_nodes_inside_a_comment\n    assert_template_result(\"\", <<~LIQUID.chomp)\n      {% comment %}\n        {% if true %}\n        {% if ... %}\n        {%- for ? -%}\n        {% while true %}\n        {%\n          unless if\n        %}\n        {% endcase %}\n      {% endcomment %}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/comment_tag_unit_test.rb",
    "start_line": 34,
    "raw_source": "def test_allows_unclosed_tags\n    assert_template_result('', <<~LIQUID.chomp)\n      {% comment %}\n        {% if true %}\n      {% endcomment %}\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/comment_tag_unit_test.rb",
    "start_line": 42,
    "raw_source": "def test_open_tags_in_comment\n    assert_template_result('', <<~LIQUID.chomp)\n      {% comment %}\n        {% assign a = 123 {% comment %}\n      {% endcomment %}\n    LIQUID\n\n    assert_raises(Liquid::SyntaxError) do\n      assert_template_result(\"\", <<~LIQUID.chomp)\n        {% comment %}\n          {% assign foo = \"1\"\n        {% endcomment %}\n      LIQUID\n    end\n\n    assert_raises(Liquid::SyntaxError) do\n      assert_template_result(\"\", <<~LIQUID.chomp)\n        {% comment %}\n          {% comment %}\n            {% invalid\n          {% endcomment %}\n        {% endcomment %}\n      LIQUID\n    end\n\n    assert_raises(Liquid::SyntaxError) do\n      assert_template_result(\"\", <<~LIQUID.chomp)\n        {% comment %}\n        {% {{ {%- endcomment %}\n      LIQUID\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/comment_tag_unit_test.rb",
    "start_line": 75,
    "raw_source": "def test_child_comment_tags_need_to_be_closed\n    assert_template_result(\"\", <<~LIQUID.chomp)\n      {% comment %}\n        {% comment %}\n          {% comment %}{%    endcomment     %}\n        {% endcomment %}\n      {% endcomment %}\n    LIQUID\n\n    assert_raises(Liquid::SyntaxError) do\n      assert_template_result(\"\", <<~LIQUID.chomp)\n        {% comment %}\n          {% comment %}\n            {% comment %}\n          {% endcomment %}\n        {% endcomment %}\n      LIQUID\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/comment_tag_unit_test.rb",
    "start_line": 95,
    "raw_source": "def test_child_raw_tags_need_to_be_closed\n    assert_template_result(\"\", <<~LIQUID.chomp)\n      {% comment %}\n        {% raw %}\n          {% endcomment %}\n        {% endraw %}\n      {% endcomment %}\n    LIQUID\n\n    assert_raises(Liquid::SyntaxError) do\n      Liquid::Template.parse(<<~LIQUID.chomp)\n        {% comment %}\n          {% raw %}\n          {% endcomment %}\n        {% endcomment %}\n      LIQUID\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/comment_tag_unit_test.rb",
    "start_line": 114,
    "raw_source": "def test_error_line_number_is_correct\n    template = Liquid::Template.parse(<<~LIQUID.chomp, line_numbers: true)\n      {% comment %}\n        {% if true %}\n      {% endcomment %}\n      {{ errors.standard_error }}\n    LIQUID\n\n    output = template.render('errors' => ErrorDrop.new)\n    expected = <<~TEXT.chomp\n\n      Liquid error (line 4): standard error\n    TEXT\n\n    assert_equal(expected, output)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/comment_tag_unit_test.rb",
    "start_line": 131,
    "raw_source": "def test_comment_tag_delimiter_with_extra_strings\n    assert_template_result(\n      '',\n      <<~LIQUID.chomp,\n        {% comment %}\n          {% comment %}\n          {% endcomment\n          {% if true %}\n          {% endif %}\n        {% endcomment %}\n      LIQUID\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/comment_tag_unit_test.rb",
    "start_line": 145,
    "raw_source": "def test_nested_comment_tag_with_extra_strings\n    assert_template_result(\n      '',\n      <<~LIQUID.chomp,\n        {% comment %}\n          {% comment\n            {% assign foo = 1 %}\n          {% endcomment\n          {% assign foo = 1 %}\n        {% endcomment %}\n      LIQUID\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/comment_tag_unit_test.rb",
    "start_line": 159,
    "raw_source": "def test_ignores_delimiter_with_extra_strings\n    assert_template_result(\n      '',\n      <<~LIQUID.chomp,\n        {% if true %}\n          {% comment %}\n            {% commentXXXXX %}wut{% endcommentXXXXX %}\n          {% endcomment %}\n        {% endif %}\n      LIQUID\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/comment_tag_unit_test.rb",
    "start_line": 172,
    "raw_source": "def test_delimiter_can_have_extra_strings\n    assert_template_result('', \"{% comment %}123{% endcomment xyz %}\")\n    assert_template_result('', \"{% comment %}123{% endcomment\\txyz %}\")\n    assert_template_result('', \"{% comment %}123{% endcomment\\nxyz %}\")\n    assert_template_result('', \"{% comment %}123{% endcomment\\n   xyz  endcomment %}\")\n    assert_template_result('', \"{%comment}{% assign a = 1 %}{%endcomment}{% endif %}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/comment_tag_unit_test.rb",
    "start_line": 180,
    "raw_source": "def test_with_whitespace_control\n    assert_template_result(\"Hello!\", \"      {%- comment -%}123{%- endcomment -%}Hello!\")\n    assert_template_result(\"Hello!\", \"{%- comment -%}123{%- endcomment -%}     Hello!\")\n    assert_template_result(\"Hello!\", \"      {%- comment -%}123{%- endcomment -%}     Hello!\")\n\n    assert_template_result(\"Hello!\", <<~LIQUID.chomp)\n      {%- comment %}Whitespace control!{% endcomment -%}\n      Hello!\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/comment_tag_unit_test.rb",
    "start_line": 191,
    "raw_source": "def test_dont_override_liquid_tag_whitespace_control\n    assert_template_result(\"Hello!World!\", <<~LIQUID.chomp)\n      Hello!\n      {%- liquid\n        comment\n         this is inside a liquid tag\n        endcomment\n      -%}\n      World!\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 6,
    "raw_source": "def test_doc_tag\n    template = <<~LIQUID.chomp\n      {% doc %}\n        Renders loading-spinner.\n\n        @param {string} foo - some foo\n        @param {string} [bar] - optional bar\n\n        @example\n        {% render 'loading-spinner', foo: 'foo' %}\n        {% render 'loading-spinner', foo: 'foo', bar: 'bar' %}\n      {% enddoc %}\n    LIQUID\n\n    assert_template_result('', template)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 23,
    "raw_source": "def test_doc_tag_body_content\n    doc_content = \"  Documentation content\\n  @param {string} foo - test\\n\"\n    template_source = \"{% doc %}#{doc_content}{% enddoc %}\"\n\n    doc_tag = nil\n    ParseTreeVisitor\n      .for(Template.parse(template_source).root)\n      .add_callback_for(Liquid::Doc) do |tag|\n        doc_tag = tag\n      end\n      .visit\n\n    assert_equal(doc_content, doc_tag.nodelist.first.to_s)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 38,
    "raw_source": "def test_doc_tag_does_not_support_extra_arguments\n    error = assert_raises(Liquid::SyntaxError) do\n      template = <<~LIQUID.chomp\n        {% doc extra %}\n        {% enddoc %}\n      LIQUID\n\n      Liquid::Template.parse(template)\n    end\n\n    exp_error = \"Liquid syntax error: Syntax Error in 'doc' - Valid syntax: {% doc %}{% enddoc %}\"\n    act_error = error.message\n\n    assert_equal(exp_error, act_error)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 54,
    "raw_source": "def test_doc_tag_must_support_valid_tags\n    assert_match_syntax_error(\"Liquid syntax error (line 1): 'doc' tag was never closed\", '{% doc %} foo')\n    assert_match_syntax_error(\"Liquid syntax error (line 1): Syntax Error in 'doc' - Valid syntax: {% doc %}{% enddoc %}\", '{% doc } foo {% enddoc %}')\n    assert_match_syntax_error(\"Liquid syntax error (line 1): Syntax Error in 'doc' - Valid syntax: {% doc %}{% enddoc %}\", '{% doc } foo %}{% enddoc %}')\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 60,
    "raw_source": "def test_doc_tag_ignores_liquid_nodes\n    template = <<~LIQUID.chomp\n      {% doc %}\n        {% if true %}\n        {% if ... %}\n        {%- for ? -%}\n        {% while true %}\n        {%\n          unless if\n        %}\n        {% endcase %}\n      {% enddoc %}\n    LIQUID\n\n    assert_template_result('', template)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 77,
    "raw_source": "def test_doc_tag_ignores_unclosed_liquid_tags\n    template = <<~LIQUID.chomp\n      {% doc %}\n        {% if true %}\n      {% enddoc %}\n    LIQUID\n\n    assert_template_result('', template)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 87,
    "raw_source": "def test_doc_tag_does_not_allow_nested_docs\n    error = assert_raises(Liquid::SyntaxError) do\n      template = <<~LIQUID.chomp\n        {% doc %}\n          {% doc %}\n            {% doc %}\n        {% enddoc %}\n      LIQUID\n\n      Liquid::Template.parse(template)\n    end\n\n    exp_error = \"Liquid syntax error: Syntax Error in 'doc' - Nested doc tags are not allowed\"\n    act_error = error.message\n\n    assert_equal(exp_error, act_error)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 105,
    "raw_source": "def test_doc_tag_ignores_nested_raw_tags\n    template = <<~LIQUID.chomp\n      {% doc %}\n        {% raw %}\n      {% enddoc %}\n    LIQUID\n\n    assert_template_result('', template)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 115,
    "raw_source": "def test_doc_tag_ignores_unclosed_assign\n    template = <<~LIQUID.chomp\n      {% doc %}\n        {% assign foo = \"1\"\n      {% enddoc %}\n    LIQUID\n\n    assert_template_result('', template)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 125,
    "raw_source": "def test_doc_tag_ignores_malformed_syntax\n    template = <<~LIQUID.chomp\n      {% doc %}\n      {% {{ {%- enddoc %}\n    LIQUID\n\n    assert_template_result('', template)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 134,
    "raw_source": "def test_doc_tag_captures_token_before_enddoc\n    template_source = \"{% doc %}{{ incomplete{% enddoc %}\"\n\n    doc_tag = nil\n    ParseTreeVisitor\n      .for(Template.parse(template_source).root)\n      .add_callback_for(Liquid::Doc) do |tag|\n        doc_tag = tag\n      end\n      .visit\n\n    assert_equal(\"{{ incomplete\", doc_tag.nodelist.first.to_s)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 148,
    "raw_source": "def test_doc_tag_preserves_error_line_numbers\n    template = Liquid::Template.parse(<<~LIQUID.chomp, line_numbers: true)\n      {% doc %}\n        {% if true %}\n      {% enddoc %}\n      {{ errors.standard_error }}\n    LIQUID\n\n    expected = <<~TEXT.chomp\n\n      Liquid error (line 4): standard error\n    TEXT\n\n    assert_equal(expected, template.render('errors' => ErrorDrop.new))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 164,
    "raw_source": "def test_doc_tag_whitespace_control\n    # Basic whitespace control\n    assert_template_result(\"Hello!\", \"      {%- doc -%}123{%- enddoc -%}Hello!\")\n    assert_template_result(\"Hello!\", \"{%- doc -%}123{%- enddoc -%}     Hello!\")\n    assert_template_result(\"Hello!\", \"      {%- doc -%}123{%- enddoc -%}     Hello!\")\n    assert_template_result(\"Hello!\", <<~LIQUID.chomp)\n      {%- doc %}Whitespace control!{% enddoc -%}\n      Hello!\n    LIQUID\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 175,
    "raw_source": "def test_doc_tag_delimiter_handling\n    assert_template_result('', <<~LIQUID.chomp)\n      {%- if true -%}\n        {%- doc -%}\n          {%- docEXTRA -%}wut{% enddocEXTRA -%}xyz\n        {%- enddoc -%}\n      {%- endif -%}\n    LIQUID\n\n    assert_template_result('', \"{% doc %}123{% enddoc xyz %}\")\n    assert_template_result('', \"{% doc %}123{% enddoc\\txyz %}\")\n    assert_template_result('', \"{% doc %}123{% enddoc\\nxyz %}\")\n    assert_template_result('', \"{% doc %}123{% enddoc\\n   xyz  enddoc %}\")\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 190,
    "raw_source": "def test_doc_tag_visitor\n    template_source = '{% doc %}{% enddoc %}'\n\n    assert_equal(\n      [Liquid::Doc],\n      visit(template_source),\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 199,
    "raw_source": "def test_doc_tag_blank_with_empty_content\n    template_source = \"{% doc %}{% enddoc %}\"\n\n    doc_tag = nil\n    ParseTreeVisitor\n      .for(Template.parse(template_source).root)\n      .add_callback_for(Liquid::Doc) do |tag|\n        doc_tag = tag\n      end\n      .visit\n\n    assert_equal(true, doc_tag.blank?)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 213,
    "raw_source": "def test_doc_tag_blank_with_content\n    template_source = \"{% doc %}Some documentation{% enddoc %}\"\n\n    doc_tag = nil\n    ParseTreeVisitor\n      .for(Template.parse(template_source).root)\n      .add_callback_for(Liquid::Doc) do |tag|\n        doc_tag = tag\n      end\n      .visit\n\n    assert_equal(false, doc_tag.blank?)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 227,
    "raw_source": "def test_doc_tag_blank_with_whitespace_only\n    template_source = \"{% doc %}    {% enddoc %}\"\n\n    doc_tag = nil\n    ParseTreeVisitor\n      .for(Template.parse(template_source).root)\n      .add_callback_for(Liquid::Doc) do |tag|\n        doc_tag = tag\n      end\n      .visit\n\n    assert_equal(false, doc_tag.blank?)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 241,
    "raw_source": "def test_doc_tag_nodelist_returns_array_with_body\n    doc_content = \"Documentation content\\n@param {string} foo\"\n    template_source = \"{% doc %}#{doc_content}{% enddoc %}\"\n\n    doc_tag = nil\n    ParseTreeVisitor\n      .for(Template.parse(template_source).root)\n      .add_callback_for(Liquid::Doc) do |tag|\n        doc_tag = tag\n      end\n      .visit\n\n    assert_equal([doc_content], doc_tag.nodelist)\n    assert_equal(1, doc_tag.nodelist.length)\n    assert_equal(doc_content, doc_tag.nodelist.first)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 258,
    "raw_source": "def test_doc_tag_nodelist_with_empty_content\n    template_source = \"{% doc %}{% enddoc %}\"\n\n    doc_tag = nil\n    ParseTreeVisitor\n      .for(Template.parse(template_source).root)\n      .add_callback_for(Liquid::Doc) do |tag|\n        doc_tag = tag\n      end\n      .visit\n\n    assert_equal([\"\"], doc_tag.nodelist)\n    assert_equal(1, doc_tag.nodelist.length)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 275,
    "raw_source": "def traversal(template)\n    ParseTreeVisitor\n      .for(Template.parse(template).root)\n      .add_callback_for(Liquid::Doc) do |tag|\n        tag_class = tag.class\n        tag_class\n      end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/doc_tag_unit_test.rb",
    "start_line": 284,
    "raw_source": "def visit(template)\n    traversal(template).visit.flatten.compact\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/for_tag_unit_test.rb",
    "start_line": 6,
    "raw_source": "def test_for_nodelist\n    template = Liquid::Template.parse('{% for item in items %}FOR{% endfor %}')\n    assert_equal(['FOR'], template.root.nodelist[0].nodelist.map(&:nodelist).flatten)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/for_tag_unit_test.rb",
    "start_line": 11,
    "raw_source": "def test_for_else_nodelist\n    template = Liquid::Template.parse('{% for item in items %}FOR{% else %}ELSE{% endfor %}')\n    assert_equal(['FOR', 'ELSE'], template.root.nodelist[0].nodelist.map(&:nodelist).flatten)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tags/if_tag_unit_test.rb",
    "start_line": 6,
    "raw_source": "def test_if_nodelist\n    template = Liquid::Template.parse('{% if true %}IF{% else %}ELSE{% endif %}')\n    assert_equal(['IF', 'ELSE'], template.root.nodelist[0].nodelist.map(&:nodelist).flatten)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/template_factory_unit_test.rb",
    "start_line": 8,
    "raw_source": "def test_for_returns_liquid_template_instance\n    template = TemplateFactory.new.for(\"anything\")\n    assert_instance_of(Liquid::Template, template)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/template_unit_test.rb",
    "start_line": 8,
    "raw_source": "def test_sets_default_localization_in_document\n    t = Template.new\n    t.parse('{%comment%}{%endcomment%}')\n    assert_instance_of(I18n, t.root.nodelist[0].options[:locale])\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/template_unit_test.rb",
    "start_line": 14,
    "raw_source": "def test_sets_default_localization_in_context_with_quick_initialization\n    t = Template.new\n    t.parse('{%comment%}{%endcomment%}', locale: I18n.new(fixture(\"en_locale.yml\")))\n\n    locale = t.root.nodelist[0].options[:locale]\n    assert_instance_of(I18n, locale)\n    assert_equal(fixture(\"en_locale.yml\"), locale.path)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/template_unit_test.rb",
    "start_line": 25,
    "raw_source": "def test_tags_can_be_looped_over\n    with_custom_tag('fake', FakeTag) do\n      result = Template.tags.map { |name, klass| [name, klass] }\n      assert(result.include?([\"fake\", TemplateUnitTest::FakeTag]))\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/template_unit_test.rb",
    "start_line": 35,
    "raw_source": "def test_template_inheritance\n    assert_equal(\"foo\", TemplateSubclass.parse(\"foo\").render)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/template_unit_test.rb",
    "start_line": 39,
    "raw_source": "def test_invalid_utf8\n    input = \"\\xff\\x00\"\n    error = assert_raises(SyntaxError) do\n      Liquid::Tokenizer.new(source: input, string_scanner: StringScanner.new(input))\n    end\n    assert_equal(\n      'Liquid syntax error: Invalid byte sequence in UTF-8',\n      error.message,\n    )\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tokenizer_unit_test.rb",
    "start_line": 6,
    "raw_source": "def test_tokenize_strings\n    assert_equal([' '], tokenize(' '))\n    assert_equal(['hello world'], tokenize('hello world'))\n    assert_equal(['{}'], tokenize('{}'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tokenizer_unit_test.rb",
    "start_line": 12,
    "raw_source": "def test_tokenize_variables\n    assert_equal(['{{funk}}'], tokenize('{{funk}}'))\n    assert_equal([' ', '{{funk}}', ' '], tokenize(' {{funk}} '))\n    assert_equal([' ', '{{funk}}', ' ', '{{so}}', ' ', '{{brother}}', ' '], tokenize(' {{funk}} {{so}} {{brother}} '))\n    assert_equal([' ', '{{  funk  }}', ' '], tokenize(' {{  funk  }} '))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tokenizer_unit_test.rb",
    "start_line": 19,
    "raw_source": "def test_tokenize_blocks\n    assert_equal(['{%comment%}'], tokenize('{%comment%}'))\n    assert_equal([' ', '{%comment%}', ' '], tokenize(' {%comment%} '))\n\n    assert_equal([' ', '{%comment%}', ' ', '{%endcomment%}', ' '], tokenize(' {%comment%} {%endcomment%} '))\n    assert_equal(['  ', '{% comment %}', ' ', '{% endcomment %}', ' '], tokenize(\"  {% comment %} {% endcomment %} \"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tokenizer_unit_test.rb",
    "start_line": 27,
    "raw_source": "def test_calculate_line_numbers_per_token_with_profiling\n    assert_equal([1],       tokenize_line_numbers(\"{{funk}}\"))\n    assert_equal([1, 1, 1], tokenize_line_numbers(\" {{funk}} \"))\n    assert_equal([1, 2, 2], tokenize_line_numbers(\"\\n{{funk}}\\n\"))\n    assert_equal([1, 1, 3], tokenize_line_numbers(\" {{\\n funk \\n}} \"))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tokenizer_unit_test.rb",
    "start_line": 34,
    "raw_source": "def test_tokenize_with_nil_source_returns_empty_array\n    assert_equal([], tokenize(nil))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tokenizer_unit_test.rb",
    "start_line": 38,
    "raw_source": "def test_incomplete_curly_braces\n    assert_equal([\"{{.}\", \" \"], tokenize('{{.} '))\n    assert_equal([\"{{}\", \"%}\"], tokenize('{{}%}'))\n    assert_equal([\"{{}}\", \"}\"], tokenize('{{}}}'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tokenizer_unit_test.rb",
    "start_line": 44,
    "raw_source": "def test_unmatching_start_and_end\n    assert_equal([\"{{%}\"], tokenize('{{%}'))\n    assert_equal([\"{{%%%}}\"], tokenize('{{%%%}}'))\n    assert_equal([\"{%\", \"}}\"], tokenize('{%}}'))\n    assert_equal([\"{%%}\", \"}\"], tokenize('{%%}}'))\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tokenizer_unit_test.rb",
    "start_line": 53,
    "raw_source": "def new_tokenizer(source, parse_context: Liquid::ParseContext.new, start_line_number: nil)\n    parse_context.new_tokenizer(source, start_line_number: start_line_number)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tokenizer_unit_test.rb",
    "start_line": 57,
    "raw_source": "def tokenize(source)\n    tokenizer = new_tokenizer(source)\n    tokens    = []\n    # shift is private in Liquid::C::Tokenizer, since it is only for unit testing\n    while (t = tokenizer.send(:shift))\n      tokens << t\n    end\n    tokens\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/tokenizer_unit_test.rb",
    "start_line": 67,
    "raw_source": "def tokenize_line_numbers(source)\n    tokenizer    = new_tokenizer(source, start_line_number: 1)\n    line_numbers = []\n    loop do\n      line_number = tokenizer.line_number\n      if tokenizer.send(:shift)\n        line_numbers << line_number\n      else\n        break\n      end\n    end\n    line_numbers\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 8,
    "raw_source": "def test_variable\n    var = create_variable('hello')\n    assert_equal(VariableLookup.new('hello'), var.name)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 13,
    "raw_source": "def test_filters\n    var = create_variable('hello | textileze')\n    assert_equal(VariableLookup.new('hello'), var.name)\n    assert_equal([['textileze', []]], var.filters)\n\n    var = create_variable('hello | textileze | paragraph')\n    assert_equal(VariableLookup.new('hello'), var.name)\n    assert_equal([['textileze', []], ['paragraph', []]], var.filters)\n\n    var = create_variable(%( hello | strftime: '%Y'))\n    assert_equal(VariableLookup.new('hello'), var.name)\n    assert_equal([['strftime', ['%Y']]], var.filters)\n\n    var = create_variable(%( 'typo' | link_to: 'Typo', true ))\n    assert_equal('typo', var.name)\n    assert_equal([['link_to', ['Typo', true]]], var.filters)\n\n    var = create_variable(%( 'typo' | link_to: 'Typo', false ))\n    assert_equal('typo', var.name)\n    assert_equal([['link_to', ['Typo', false]]], var.filters)\n\n    var = create_variable(%( 'foo' | repeat: 3 ))\n    assert_equal('foo', var.name)\n    assert_equal([['repeat', [3]]], var.filters)\n\n    var = create_variable(%( 'foo' | repeat: 3, 3 ))\n    assert_equal('foo', var.name)\n    assert_equal([['repeat', [3, 3]]], var.filters)\n\n    var = create_variable(%( 'foo' | repeat: 3, 3, 3 ))\n    assert_equal('foo', var.name)\n    assert_equal([['repeat', [3, 3, 3]]], var.filters)\n\n    var = create_variable(%( hello | strftime: '%Y, okay?'))\n    assert_equal(VariableLookup.new('hello'), var.name)\n    assert_equal([['strftime', ['%Y, okay?']]], var.filters)\n\n    var = create_variable(%( hello | things: \"%Y, okay?\", 'the other one'))\n    assert_equal(VariableLookup.new('hello'), var.name)\n    assert_equal([['things', ['%Y, okay?', 'the other one']]], var.filters)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 55,
    "raw_source": "def test_filter_with_date_parameter\n    var = create_variable(%( '2006-06-06' | date: \"%m/%d/%Y\"))\n    assert_equal('2006-06-06', var.name)\n    assert_equal([['date', ['%m/%d/%Y']]], var.filters)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 61,
    "raw_source": "def test_filters_without_whitespace\n    var = create_variable('hello | textileze | paragraph')\n    assert_equal(VariableLookup.new('hello'), var.name)\n    assert_equal([['textileze', []], ['paragraph', []]], var.filters)\n\n    var = create_variable('hello|textileze|paragraph')\n    assert_equal(VariableLookup.new('hello'), var.name)\n    assert_equal([['textileze', []], ['paragraph', []]], var.filters)\n\n    var = create_variable(\"hello|replace:'foo','bar'|textileze\")\n    assert_equal(VariableLookup.new('hello'), var.name)\n    assert_equal([['replace', ['foo', 'bar']], ['textileze', []]], var.filters)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 75,
    "raw_source": "def test_symbol\n    var = create_variable(\"http://disney.com/logo.gif | image: 'med' \", error_mode: :lax)\n    assert_equal(VariableLookup.new('http://disney.com/logo.gif'), var.name)\n    assert_equal([['image', ['med']]], var.filters)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 81,
    "raw_source": "def test_string_to_filter\n    var = create_variable(\"'http://disney.com/logo.gif' | image: 'med' \")\n    assert_equal('http://disney.com/logo.gif', var.name)\n    assert_equal([['image', ['med']]], var.filters)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 87,
    "raw_source": "def test_string_single_quoted\n    var = create_variable(%( \"hello\" ))\n    assert_equal('hello', var.name)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 92,
    "raw_source": "def test_string_double_quoted\n    var = create_variable(%( 'hello' ))\n    assert_equal('hello', var.name)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 97,
    "raw_source": "def test_integer\n    var = create_variable(%( 1000 ))\n    assert_equal(1000, var.name)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 102,
    "raw_source": "def test_float\n    var = create_variable(%( 1000.01 ))\n    assert_equal(1000.01, var.name)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 107,
    "raw_source": "def test_dashes\n    assert_equal(VariableLookup.new('foo-bar'), create_variable('foo-bar').name)\n    assert_equal(VariableLookup.new('foo-bar-2'), create_variable('foo-bar-2').name)\n\n    with_error_mode(:strict) do\n      assert_raises(Liquid::SyntaxError) { create_variable('foo - bar') }\n      assert_raises(Liquid::SyntaxError) { create_variable('-foo') }\n      assert_raises(Liquid::SyntaxError) { create_variable('2foo') }\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 118,
    "raw_source": "def test_string_with_special_chars\n    var = create_variable(%( 'hello! $!@.;\"ddasd\" ' ))\n    assert_equal('hello! $!@.;\"ddasd\" ', var.name)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 123,
    "raw_source": "def test_string_dot\n    var = create_variable(%( test.test ))\n    assert_equal(VariableLookup.new('test.test'), var.name)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 128,
    "raw_source": "def test_filter_with_keyword_arguments\n    var = create_variable(%( hello | things: greeting: \"world\", farewell: 'goodbye'))\n    assert_equal(VariableLookup.new('hello'), var.name)\n    assert_equal([['things', [], { 'greeting' => 'world', 'farewell' => 'goodbye' }]], var.filters)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 134,
    "raw_source": "def test_lax_filter_argument_parsing\n    var = create_variable(%( number_of_comments | pluralize: 'comment': 'comments' ), error_mode: :lax)\n    assert_equal(VariableLookup.new('number_of_comments'), var.name)\n    assert_equal([['pluralize', ['comment', 'comments']]], var.filters)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 140,
    "raw_source": "def test_strict_filter_argument_parsing\n    with_error_mode(:strict) do\n      assert_raises(SyntaxError) do\n        create_variable(%( number_of_comments | pluralize: 'comment': 'comments' ))\n      end\n    end\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 148,
    "raw_source": "def test_output_raw_source_of_variable\n    var = create_variable(%( name_of_variable | upcase ))\n    assert_equal(\" name_of_variable | upcase \", var.raw)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 153,
    "raw_source": "def test_variable_lookup_interface\n    lookup = VariableLookup.new('a.b.c')\n    assert_equal('a', lookup.name)\n    assert_equal(['b', 'c'], lookup.lookups)\n  end"
  },
  {
    "repo_name": "liquid",
    "file_path": "./repos/liquid/test/unit/variable_unit_test.rb",
    "start_line": 161,
    "raw_source": "def create_variable(markup, options = {})\n    Variable.new(markup, ParseContext.new(options))\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 36,
    "raw_source": "def accept\n      @env['sinatra.accept'] ||= if @env.include?('HTTP_ACCEPT') && (@env['HTTP_ACCEPT'].to_s != '')\n                                   @env['HTTP_ACCEPT']\n                                     .to_s\n                                     .scan(HEADER_VALUE_WITH_PARAMS)\n                                     .map! { |e| AcceptEntry.new(e) }\n                                     .sort\n                                 else\n                                   [AcceptEntry.new('*/*')]\n                                 end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 48,
    "raw_source": "def accept?(type)\n      preferred_type(type).to_s.include?(type)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 52,
    "raw_source": "def preferred_type(*types)\n      return accept.first if types.empty?\n\n      types.flatten!\n      return types.first if accept.empty?\n\n      accept.detect do |accept_header|\n        type = types.detect { |t| MimeTypeEntry.new(t).accepts?(accept_header) }\n        return type if type\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 66,
    "raw_source": "def forwarded?\n      !forwarded_authority.nil?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 70,
    "raw_source": "def safe?\n      get? || head? || options? || trace?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 74,
    "raw_source": "def idempotent?\n      safe? || put? || delete? || link? || unlink?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 78,
    "raw_source": "def link?\n      request_method == 'LINK'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 82,
    "raw_source": "def unlink?\n      request_method == 'UNLINK'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 86,
    "raw_source": "def params\n      super\n    rescue Rack::Utils::ParameterTypeError, Rack::Utils::InvalidParameterError => e\n      raise BadRequest, \"Invalid query parameters: #{Rack::Utils.escape_html(e.message)}\"\n    rescue EOFError => e\n      raise BadRequest, \"Invalid multipart/form-data: #{Rack::Utils.escape_html(e.message)}\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 98,
    "raw_source": "def initialize(entry)\n        params = entry.scan(HEADER_PARAM).map! do |s|\n          key, value = s.strip.split('=', 2)\n          value = value[1..-2].gsub(/\\\\(.)/, '\\1') if value.start_with?('\"')\n          [key, value]\n        end\n\n        @entry  = entry\n        @type   = entry[/[^;]+/].delete(' ')\n        @params = params.to_h\n        @q      = @params.delete('q') { 1.0 }.to_f\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 111,
    "raw_source": "def <=>(other)\n        other.priority <=> priority\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 115,
    "raw_source": "def priority\n        # We sort in descending order; better matches should be higher.\n        [@q, -@type.count('*'), @params.size]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 120,
    "raw_source": "def to_str\n        @type\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 124,
    "raw_source": "def to_s(full = false)\n        full ? entry : to_str\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 128,
    "raw_source": "def respond_to?(*args)\n        super || to_str.respond_to?(*args)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 132,
    "raw_source": "def method_missing(*args, &block)\n        to_str.send(*args, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 140,
    "raw_source": "def initialize(entry)\n        params = entry.scan(HEADER_PARAM).map! do |s|\n          key, value = s.strip.split('=', 2)\n          value = value[1..-2].gsub(/\\\\(.)/, '\\1') if value.start_with?('\"')\n          [key, value]\n        end\n\n        @type   = entry[/[^;]+/].delete(' ')\n        @params = params.to_h\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 151,
    "raw_source": "def accepts?(entry)\n        File.fnmatch(entry, self) && matches_params?(entry.params)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 155,
    "raw_source": "def to_str\n        @type\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 159,
    "raw_source": "def matches_params?(params)\n        return true if @params.empty?\n\n        params.all? { |k, v| !@params.key?(k) || @params[k] == v }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 174,
    "raw_source": "def body=(value)\n      value = value.body while Rack::Response === value\n      @body = String === value ? [value.to_str] : value\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 179,
    "raw_source": "def each\n      block_given? ? super : enum_for(:each)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 183,
    "raw_source": "def finish\n      result = body\n\n      if drop_content_info?\n        headers.delete 'content-length'\n        headers.delete 'content-type'\n      end\n\n      if drop_body?\n        close\n        result = []\n      end\n\n      if calculate_content_length?\n        # if some other code has already set content-length, don't muck with it\n        # currently, this would be the static file-handler\n        headers['content-length'] = body.map(&:bytesize).reduce(0, :+).to_s\n      end\n\n      [status, headers, result]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 207,
    "raw_source": "def calculate_content_length?\n      headers['content-type'] && !headers['content-length'] && (Array === body)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 211,
    "raw_source": "def drop_content_info?\n      informational? || drop_body?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 215,
    "raw_source": "def drop_body?\n      DROP_BODY_RESPONSES.include?(status)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 226,
    "raw_source": "def call(env)\n      result = app.call(env)\n      callback = env['async.callback']\n      return result unless callback && async?(*result)\n\n      after_response { callback.call result }\n      setup_close(env, *result)\n      throw :async\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 238,
    "raw_source": "def setup_close(env, _status, _headers, body)\n      return unless body.respond_to?(:close) && env.include?('async.close')\n\n      env['async.close'].callback { body.close }\n      env['async.close'].errback { body.close }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 245,
    "raw_source": "def after_response(&block)\n      raise NotImplementedError, 'only supports EventMachine at the moment' unless defined? EventMachine\n\n      EventMachine.next_tick(&block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 251,
    "raw_source": "def async?(status, _headers, body)\n      return true if status == -1\n\n      body.respond_to?(:callback) && body.respond_to?(:errback)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 261,
    "raw_source": "def call(env)\n      env['sinatra.commonlogger'] ? @app.call(env) : super\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 267,
    "raw_source": "def call(env)\n        env['sinatra.commonlogger'] = true\n        call_without_check(env)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 278,
    "raw_source": "def http_status; 400 end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 282,
    "raw_source": "def http_status; 404 end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 288,
    "raw_source": "def status(value = nil)\n      response.status = Rack::Utils.status_code(value) if value\n      response.status\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 295,
    "raw_source": "def body(value = nil, &block)\n      if block_given?\n        def block.each; yield(call) end\n        response.body = block\n      elsif value\n        unless request.head? || value.is_a?(Rack::Files::BaseIterator) || value.is_a?(Stream)\n          headers.delete 'content-length'\n        end\n        response.body = value\n      else\n        response.body\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 297,
    "raw_source": "def block.each; yield(call) end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 310,
    "raw_source": "def redirect(uri, *args)\n      # SERVER_PROTOCOL is required in Rack 3, fall back to HTTP_VERSION\n      # for servers not updated for Rack 3 (like Puma 5)\n      http_version = env['SERVER_PROTOCOL'] || env['HTTP_VERSION']\n      if (http_version == 'HTTP/1.1') && (env['REQUEST_METHOD'] != 'GET')\n        status 303\n      else\n        status 302\n      end\n\n      # According to RFC 2616 section 14.30, \"the field value consists of a\n      # single absolute URI\"\n      response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?)\n      halt(*args)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 328,
    "raw_source": "def uri(addr = nil, absolute = true, add_script_name = true)\n      return addr if addr.to_s =~ /\\A[a-z][a-z0-9+.\\-]*:/i\n\n      uri = [host = String.new]\n      if absolute\n        host << \"http#{'s' if request.secure?}://\"\n        host << if request.forwarded? || (request.port != (request.secure? ? 443 : 80))\n                  request.host_with_port\n                else\n                  request.host\n                end\n      end\n      uri << request.script_name.to_s if add_script_name\n      uri << (addr || request.path_info).to_s\n      File.join uri\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 349,
    "raw_source": "def error(code, body = nil)\n      if code.respond_to? :to_str\n        body = code.to_str\n        code = 500\n      end\n      response.body = body unless body.nil?\n      halt code\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 359,
    "raw_source": "def not_found(body = nil)\n      error 404, body\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 364,
    "raw_source": "def headers(hash = nil)\n      response.headers.merge! hash if hash\n      response.headers\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 370,
    "raw_source": "def session\n      request.session\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 375,
    "raw_source": "def logger\n      request.logger\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 380,
    "raw_source": "def mime_type(type)\n      Base.mime_type(type)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 386,
    "raw_source": "def content_type(type = nil, params = {})\n      return response['content-type'] unless type\n\n      default = params.delete :default\n      mime_type = mime_type(type) || default\n      raise format('Unknown media type: %p', type) if mime_type.nil?\n\n      mime_type = mime_type.dup\n      unless params.include?(:charset) || settings.add_charset.all? { |p| !(p === mime_type) }\n        params[:charset] = params.delete('charset') || settings.default_encoding\n      end\n      params.delete :charset if mime_type.include? 'charset'\n      unless params.empty?\n        mime_type << ';'\n        mime_type << params.map do |key, val|\n          val = val.inspect if val.to_s =~ /[\";,]/\n          \"#{key}=#{val}\"\n        end.join(';')\n      end\n      response['content-type'] = mime_type\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 417,
    "raw_source": "def attachment(filename = nil, disposition = :attachment)\n      response['Content-Disposition'] = disposition.to_s.dup\n      return unless filename\n\n      params = format('; filename=\"%s\"', File.basename(filename).gsub(/[\"\\r\\n]/, MULTIPART_FORM_DATA_REPLACEMENT_TABLE))\n      response['Content-Disposition'] << params\n      ext = File.extname(filename)\n      content_type(ext) unless response['content-type'] || ext.empty?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 428,
    "raw_source": "def send_file(path, opts = {})\n      if opts[:type] || !response['content-type']\n        content_type opts[:type] || File.extname(path), default: 'application/octet-stream'\n      end\n\n      disposition = opts[:disposition]\n      filename    = opts[:filename]\n      disposition = :attachment if disposition.nil? && filename\n      filename    = path        if filename.nil?\n      attachment(filename, disposition) if disposition\n\n      last_modified opts[:last_modified] if opts[:last_modified]\n\n      file   = Rack::Files.new(File.dirname(settings.app_file))\n      result = file.serving(request, path)\n\n      result[1].each { |k, v| headers[k] ||= v }\n      headers['content-length'] = result[1]['content-length']\n      opts[:status] &&= Integer(opts[:status])\n      halt (opts[:status] || result[0]), result[2]\n    rescue Errno::ENOENT\n      not_found\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 461,
    "raw_source": "def self.schedule(*) yield end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 462,
    "raw_source": "def self.defer(*)    yield end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 464,
    "raw_source": "def initialize(scheduler = self.class, keep_open = false, &back)\n        @back = back.to_proc\n        @scheduler = scheduler\n        @keep_open = keep_open\n        @callbacks = []\n        @closed = false\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 472,
    "raw_source": "def close\n        return if closed?\n\n        @closed = true\n        @scheduler.schedule { @callbacks.each { |c| c.call } }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 479,
    "raw_source": "def each(&front)\n        @front = front\n        @scheduler.defer do\n          begin\n            @back.call(self)\n          rescue Exception => e\n            @scheduler.schedule { raise e }\n          ensure\n            close unless @keep_open\n          end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 492,
    "raw_source": "def <<(data)\n        @scheduler.schedule { @front.call(data.to_s) }\n        self\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 497,
    "raw_source": "def callback(&block)\n        return yield if closed?\n\n        @callbacks << block\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 505,
    "raw_source": "def closed?\n        @closed\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 515,
    "raw_source": "def stream(keep_open = false)\n      scheduler = env['async.callback'] ? EventMachine : Stream\n      current   = @params.dup\n      stream = if scheduler == Stream  && keep_open\n        Stream.new(scheduler, false) do |out|\n          until out.closed?\n            with_params(current) { yield(out) }\n          end\n        end\n      else\n        Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } }\n      end\n      body stream\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 540,
    "raw_source": "def cache_control(*values)\n      if values.last.is_a?(Hash)\n        hash = values.pop\n        hash.reject! { |_k, v| v == false }\n        hash.reject! { |k, v| values << k if v == true }\n      else\n        hash = {}\n      end\n\n      values.map! { |value| value.to_s.tr('_', '-') }\n      hash.each do |key, value|\n        key = key.to_s.tr('_', '-')\n        value = value.to_i if %w[max-age s-maxage].include? key\n        values << \"#{key}=#{value}\"\n      end\n\n      response['Cache-Control'] = values.join(', ') if values.any?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 568,
    "raw_source": "def expires(amount, *values)\n      values << {} unless values.last.is_a?(Hash)\n\n      if amount.is_a? Integer\n        time    = Time.now + amount.to_i\n        max_age = amount\n      else\n        time    = time_for amount\n        max_age = time - Time.now\n      end\n\n      values.last.merge!(max_age: max_age) { |_key, v1, v2| v1 || v2 }\n      cache_control(*values)\n\n      response['Expires'] = time.httpdate\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 592,
    "raw_source": "def last_modified(time)\n      return unless time\n\n      time = time_for time\n      response['Last-Modified'] = time.httpdate\n      return if env['HTTP_IF_NONE_MATCH']\n\n      if (status == 200) && env['HTTP_IF_MODIFIED_SINCE']\n        # compare based on seconds since epoch\n        since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i\n        halt 304 if since >= time.to_i\n      end\n\n      if (success? || (status == 412)) && env['HTTP_IF_UNMODIFIED_SINCE']\n        # compare based on seconds since epoch\n        since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i\n        halt 412 if since < time.to_i\n      end\n    rescue ArgumentError\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 623,
    "raw_source": "def etag(value, options = {})\n      # Before touching this code, please double check RFC 2616 14.24 and 14.26.\n      options      = { kind: options } unless Hash === options\n      kind         = options[:kind] || :strong\n      new_resource = options.fetch(:new_resource) { request.post? }\n\n      unless ETAG_KINDS.include?(kind)\n        raise ArgumentError, ':strong or :weak expected'\n      end\n\n      value = format('\"%s\"', value)\n      value = \"W/#{value}\" if kind == :weak\n      response['ETag'] = value\n\n      return unless success? || status == 304\n\n      if etag_matches?(env['HTTP_IF_NONE_MATCH'], new_resource)\n        halt(request.safe? ? 304 : 412)\n      end\n\n      if env['HTTP_IF_MATCH']\n        return if etag_matches?(env['HTTP_IF_MATCH'], new_resource)\n\n        halt 412\n      end\n\n      nil\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 653,
    "raw_source": "def back\n      request.referer\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 658,
    "raw_source": "def informational?\n      status.between? 100, 199\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 663,
    "raw_source": "def success?\n      status.between? 200, 299\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 668,
    "raw_source": "def redirect?\n      status.between? 300, 399\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 673,
    "raw_source": "def client_error?\n      status.between? 400, 499\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 678,
    "raw_source": "def server_error?\n      status.between? 500, 599\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 683,
    "raw_source": "def not_found?\n      status == 404\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 688,
    "raw_source": "def bad_request?\n      status == 400\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 694,
    "raw_source": "def time_for(value)\n      if value.is_a? Numeric\n        Time.at value\n      elsif value.respond_to? :to_s\n        Time.parse value.to_s\n      else\n        value.to_time\n      end\n    rescue ArgumentError => e\n      raise e\n    rescue Exception\n      raise ArgumentError, \"unable to convert #{value.inspect} to a Time object\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 711,
    "raw_source": "def etag_matches?(list, new_resource = request.post?)\n      return !new_resource if list == '*'\n\n      list.to_s.split(/\\s*,\\s*/).include? response['ETag']\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 717,
    "raw_source": "def with_params(temp_params)\n      original = @params\n      @params = temp_params\n      yield\n    ensure\n      @params = original if original\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 749,
    "raw_source": "def initialize\n      super\n      @default_layout = :layout\n      @preferred_extension = nil\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 755,
    "raw_source": "def erb(template, options = {}, locals = {}, &block)\n      render(:erb, template, options, locals, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 759,
    "raw_source": "def haml(template, options = {}, locals = {}, &block)\n      render(:haml, template, options, locals, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 763,
    "raw_source": "def sass(template, options = {}, locals = {})\n      options[:default_content_type] = :css\n      options[:exclude_outvar] = true\n      options[:layout] = nil\n      render :sass, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 770,
    "raw_source": "def scss(template, options = {}, locals = {})\n      options[:default_content_type] = :css\n      options[:exclude_outvar] = true\n      options[:layout] = nil\n      render :scss, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 777,
    "raw_source": "def builder(template = nil, options = {}, locals = {}, &block)\n      options[:default_content_type] = :xml\n      render_ruby(:builder, template, options, locals, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 782,
    "raw_source": "def liquid(template, options = {}, locals = {}, &block)\n      render(:liquid, template, options, locals, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 786,
    "raw_source": "def markdown(template, options = {}, locals = {})\n      options[:exclude_outvar] = true\n      render :markdown, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 791,
    "raw_source": "def rdoc(template, options = {}, locals = {})\n      render :rdoc, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 795,
    "raw_source": "def asciidoc(template, options = {}, locals = {})\n      render :asciidoc, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 799,
    "raw_source": "def markaby(template = nil, options = {}, locals = {}, &block)\n      render_ruby(:mab, template, options, locals, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 803,
    "raw_source": "def nokogiri(template = nil, options = {}, locals = {}, &block)\n      options[:default_content_type] = :xml\n      render_ruby(:nokogiri, template, options, locals, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 808,
    "raw_source": "def slim(template, options = {}, locals = {}, &block)\n      render(:slim, template, options, locals, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 812,
    "raw_source": "def yajl(template, options = {}, locals = {})\n      options[:default_content_type] = :json\n      render :yajl, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 817,
    "raw_source": "def rabl(template, options = {}, locals = {})\n      Rabl.register!\n      render :rabl, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 824,
    "raw_source": "def find_template(views, name, engine)\n      yield ::File.join(views, \"#{name}.#{@preferred_extension}\")\n\n      Tilt.default_mapping.extensions_for(engine).each do |ext|\n        yield ::File.join(views, \"#{name}.#{ext}\") unless ext == @preferred_extension\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 835,
    "raw_source": "def render_ruby(engine, template, options = {}, locals = {}, &block)\n      if template.is_a?(Hash)\n        options = template\n        template = nil\n      end\n      template = proc { block } if template.nil?\n      render engine, template, options, locals\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 844,
    "raw_source": "def render(engine, data, options = {}, locals = {}, &block)\n      # merge app-level options\n      engine_options = settings.respond_to?(engine) ? settings.send(engine) : {}\n      options.merge!(engine_options) { |_key, v1, _v2| v1 }\n\n      # extract generic options\n      locals          = options.delete(:locals) || locals         || {}\n      views           = options.delete(:views)  || settings.views || './views'\n      layout          = options[:layout]\n      layout          = false if layout.nil? && options.include?(:layout)\n      eat_errors      = layout.nil?\n      layout          = engine_options[:layout] if layout.nil? || (layout == true && engine_options[:layout] != false)\n      layout          = @default_layout         if layout.nil? || (layout == true)\n      layout_options  = options.delete(:layout_options) || {}\n      content_type    = options.delete(:default_content_type)\n      content_type    = options.delete(:content_type)   || content_type\n      layout_engine   = options.delete(:layout_engine)  || engine\n      scope           = options.delete(:scope)          || self\n      exclude_outvar  = options.delete(:exclude_outvar)\n      options.delete(:layout)\n\n      # set some defaults\n      options[:outvar] ||= '@_out_buf' unless exclude_outvar\n      options[:default_encoding] ||= settings.default_encoding\n\n      # compile and render template\n      begin\n        layout_was      = @default_layout\n        @default_layout = false\n        template        = compile_template(engine, data, options, views)\n        output          = template.render(scope, locals, &block)\n      ensure\n        @default_layout = layout_was\n      end\n\n      # render layout\n      if layout\n        extra_options = { views: views, layout: false, eat_errors: eat_errors, scope: scope }\n        options = options.merge(extra_options).merge!(layout_options)\n\n        catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } }\n      end\n\n      if content_type\n        # sass-embedded returns a frozen string\n        output = +output\n        output.extend(ContentTyped).content_type = content_type\n      end\n      output\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 895,
    "raw_source": "def compile_template(engine, data, options, views)\n      eat_errors = options.delete :eat_errors\n      template = Tilt[engine]\n      raise \"Template engine not found: #{engine}\" if template.nil?\n\n      case data\n      when Symbol\n        template_cache.fetch engine, data, options, views do\n          body, path, line = settings.templates[data]\n          if body\n            body = body.call if body.respond_to?(:call)\n            template.new(path, line.to_i, options) { body }\n          else\n            found = false\n            @preferred_extension = engine.to_s\n            find_template(views, data, template) do |file|\n              path ||= file # keep the initial path rather than the last one\n              found = File.exist?(file)\n              if found\n                path = file\n                break\n              end\n            end\n            throw :layout_missing if eat_errors && !found\n            template.new(path, 1, options)\n          end\n        end\n      when Proc\n        compile_block_template(template, options, &data)\n      when String\n        template_cache.fetch engine, data, options, views do\n          compile_block_template(template, options) { data }\n        end\n      else\n        raise ArgumentError, \"Sorry, don't know how to render #{data.inspect}.\"\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 933,
    "raw_source": "def compile_block_template(template, options, &body)\n      first_location = caller_locations.first\n      path = first_location.path\n      line = first_location.lineno\n      path = options[:path] || path\n      line = options[:line] || line\n      template.new(path, line.to_i, options, &body)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 952,
    "raw_source": "def initialize\n      @cache = {}\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 960,
    "raw_source": "def fetch(*key)\n      @cache.fetch(key) do\n        @cache[key] = yield\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 967,
    "raw_source": "def clear\n      @cache = {}\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 983,
    "raw_source": "def initialize(app = nil, **_kwargs)\n      super()\n      @app = app\n      @template_cache = TemplateCache.new\n      @pinned_response = nil # whether a before! filter pinned the content-type\n      yield self if block_given?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 992,
    "raw_source": "def call(env)\n      dup.call!(env)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 996,
    "raw_source": "def call!(env) # :nodoc:\n      @env      = env\n      @params   = IndifferentHash.new\n      @request  = Request.new(env)\n      @response = Response.new\n      @pinned_response = nil\n      template_cache.clear if settings.reload_templates\n\n      invoke { dispatch! }\n      invoke { error_block!(response.status) } unless @env['sinatra.error']\n\n      unless @response['content-type']\n        if Array === body && body[0].respond_to?(:content_type)\n          content_type body[0].content_type\n        elsif (default = settings.default_content_type)\n          content_type default\n        end\n      end\n\n      @response.finish\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1019,
    "raw_source": "def self.settings\n      self\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1024,
    "raw_source": "def settings\n      self.class.settings\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1030,
    "raw_source": "def halt(*response)\n      response = response.first if response.length == 1\n      throw :halt, response\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1038,
    "raw_source": "def pass(&block)\n      throw :pass, block\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1043,
    "raw_source": "def forward\n      raise 'downstream app not set' unless @app.respond_to? :call\n\n      status, headers, body = @app.call env\n      @response.status = status\n      @response.body = body\n      @response.headers.merge! headers\n      nil\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1057,
    "raw_source": "def filter!(type, base = settings, &block)\n      filter!(type, base.superclass, &block) if base.superclass.respond_to?(:filters)\n      base.filters[type].each do |args|\n        result = process_route(*args)\n        block.call(result) if block_given?\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1066,
    "raw_source": "def route!(base = settings, pass_block = nil)\n      routes = base.routes[@request.request_method]\n\n      routes&.each do |pattern, conditions, block|\n        response.delete_header('content-type') unless @pinned_response\n\n        returned_pass_block = process_route(pattern, conditions) do |*args|\n          env['sinatra.route'] = \"#{@request.request_method} #{pattern}\"\n          route_eval { block[*args] }\n        end\n\n        # don't wipe out pass_block in superclass\n        pass_block = returned_pass_block if returned_pass_block\n      end\n\n      # Run routes defined in superclass.\n      if base.superclass.respond_to?(:routes)\n        return route!(base.superclass, pass_block)\n      end\n\n      route_eval(&pass_block) if pass_block\n      route_missing\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1091,
    "raw_source": "def route_eval\n      throw :halt, yield\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1100,
    "raw_source": "def process_route(pattern, conditions, block = nil, values = [])\n      route = @request.path_info\n      route = '/' if route.empty? && !settings.empty_path_info?\n      route = route[0..-2] if !settings.strict_paths? && route != '/' && route.end_with?('/')\n\n      params = pattern.params(route)\n      return unless params\n\n      params.delete('ignore') # TODO: better params handling, maybe turn it into \"smart\" object or detect changes\n      force_encoding(params)\n      @params = @params.merge(params) { |_k, v1, v2| v2 || v1 } if params.any?\n\n      regexp_exists = pattern.is_a?(Mustermann::Regular) || (pattern.respond_to?(:patterns) && pattern.patterns.any? { |subpattern| subpattern.is_a?(Mustermann::Regular) })\n      if regexp_exists\n        captures           = pattern.match(route).captures.map { |c| URI_INSTANCE.unescape(c) if c }\n        values            += captures\n        @params[:captures] = force_encoding(captures) unless captures.nil? || captures.empty?\n      else\n        values += params.values.flatten\n      end\n\n      catch(:pass) do\n        conditions.each { |c| throw :pass if c.bind(self).call == false }\n        block ? block[self, values] : yield(self, values)\n      end\n    rescue StandardError\n      @env['sinatra.error.params'] = @params\n      raise\n    ensure\n      params ||= {}\n      params.each { |k, _| @params.delete(k) } unless @env['sinatra.error.params']\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1138,
    "raw_source": "def route_missing\n      raise NotFound unless @app\n\n      forward\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1147,
    "raw_source": "def static!(options = {})\n      return if (public_dir = settings.public_folder).nil?\n\n      path = \"#{public_dir}#{URI_INSTANCE.unescape(request.path_info)}\"\n      return unless valid_path?(path)\n\n      path = File.expand_path(path)\n      return unless path.start_with?(\"#{File.expand_path(public_dir)}/\")\n\n      return unless File.file?(path)\n\n      env['sinatra.static_file'] = path\n      cache_control(*settings.static_cache_control) if settings.static_cache_control?\n\n      headers(settings.static_headers) if settings.static_headers?\n\n      send_file path, options.merge(disposition: nil)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1167,
    "raw_source": "def invoke(&block)\n      res = catch(:halt, &block)\n\n      res = [res] if (Integer === res) || (String === res)\n      if (Array === res) && (Integer === res.first)\n        res = res.dup\n        status(res.shift)\n        body(res.pop)\n        headers(*res)\n      elsif res.respond_to? :each\n        body res\n      end\n      nil # avoid double setting the same response tuple twice\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1183,
    "raw_source": "def dispatch!\n      # Avoid passing frozen string in force_encoding\n      @params.merge!(@request.params).each do |key, val|\n        next unless val.respond_to?(:force_encoding)\n\n        val = val.dup if val.frozen?\n        @params[key] = force_encoding(val)\n      end\n\n      invoke do\n        static! if settings.static? && (request.get? || request.head?)\n        filter! :before do\n          @pinned_response = !response['content-type'].nil?\n        end\n        route!\n      end\n    rescue ::Exception => e\n      invoke { handle_exception!(e) }\n    ensure\n      begin\n        filter! :after unless env['sinatra.static_file']\n      rescue ::Exception => e\n        invoke { handle_exception!(e) } unless @env['sinatra.error']\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1210,
    "raw_source": "def handle_exception!(boom)\n      error_params = @env['sinatra.error.params']\n\n      @params = @params.merge(error_params) if error_params\n\n      @env['sinatra.error'] = boom\n\n      http_status = if boom.is_a? Sinatra::Error\n                      if boom.respond_to? :http_status\n                        boom.http_status\n                      elsif settings.use_code? && boom.respond_to?(:code)\n                        boom.code\n                      end\n                    end\n\n      http_status = 500 unless http_status&.between?(400, 599)\n      status(http_status)\n\n      if server_error?\n        dump_errors! boom if settings.dump_errors?\n        raise boom if settings.show_exceptions? && (settings.show_exceptions != :after_handler)\n      elsif not_found?\n        headers['X-Cascade'] = 'pass' if settings.x_cascade?\n      end\n\n      if (res = error_block!(boom.class, boom) || error_block!(status, boom))\n        return res\n      end\n\n      if not_found? || bad_request?\n        if boom.message && boom.message != boom.class.name\n          body Rack::Utils.escape_html(boom.message)\n        else\n          content_type 'text/html'\n          body \"<h1>#{not_found? ? 'Not Found' : 'Bad Request'}</h1>\"\n        end\n      end\n\n      return unless server_error?\n\n      raise boom if settings.raise_errors? || settings.show_exceptions?\n\n      error_block! Exception, boom\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1256,
    "raw_source": "def error_block!(key, *block_params)\n      base = settings\n      while base.respond_to?(:errors)\n        args_array = base.errors[key]\n\n        next base = base.superclass unless args_array\n\n        args_array.reverse_each do |args|\n          first = args == args_array.first\n          args += [block_params]\n          resp = process_route(*args)\n          return resp unless resp.nil? && !first\n        end\n      end\n      return false unless key.respond_to?(:superclass) && (key.superclass < Exception)\n\n      error_block!(key.superclass, *block_params)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1275,
    "raw_source": "def dump_errors!(boom)\n      if boom.respond_to?(:detailed_message)\n        msg = boom.detailed_message(highlight: false)\n        if msg =~ /\\A(.*?)(?: \\(#{ Regexp.quote(boom.class.to_s) }\\))?\\n/\n          msg = $1\n          additional_msg = $'.lines(chomp: true)\n        else\n          additional_msg = []\n        end\n      else\n        msg = boom.message\n        additional_msg = []\n      end\n      msg = [\"#{Time.now.strftime('%Y-%m-%d %H:%M:%S')} - #{boom.class} - #{msg}:\", *additional_msg, *boom.backtrace].join(\"\\n\\t\")\n      @env['rack.errors'].puts(msg)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1307,
    "raw_source": "def callers_to_ignore\n        CALLERS_TO_IGNORE\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1313,
    "raw_source": "def reset!\n        @conditions     = []\n        @routes         = {}\n        @filters        = { before: [], after: [] }\n        @errors         = {}\n        @middleware     = []\n        @prototype      = nil\n        @extensions     = []\n\n        @templates = if superclass.respond_to?(:templates)\n                       Hash.new { |_hash, key| superclass.templates[key] }\n                     else\n                       {}\n                     end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1330,
    "raw_source": "def extensions\n        if superclass.respond_to?(:extensions)\n          (@extensions + superclass.extensions).uniq\n        else\n          @extensions\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1339,
    "raw_source": "def middleware\n        if superclass.respond_to?(:middleware)\n          superclass.middleware + @middleware\n        else\n          @middleware\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1349,
    "raw_source": "def set(option, value = (not_set = true), ignore_setter = false, &block)\n        raise ArgumentError if block && !not_set\n\n        if block\n          value = block\n          not_set = false\n        end\n\n        if not_set\n          raise ArgumentError unless option.respond_to?(:each)\n\n          option.each { |k, v| set(k, v) }\n          return self\n        end\n\n        if respond_to?(\"#{option}=\") && !ignore_setter\n          return __send__(\"#{option}=\", value)\n        end\n\n        setter = proc { |val| set option, val, true }\n        getter = proc { value }\n\n        case value\n        when Proc\n          getter = value\n        when Symbol, Integer, FalseClass, TrueClass, NilClass\n          getter = value.inspect\n        when Hash\n          setter = proc do |val|\n            val = value.merge val if Hash === val\n            set option, val, true\n          end\n        end\n\n        define_singleton(\"#{option}=\", setter)\n        define_singleton(option, getter)\n        define_singleton(\"#{option}?\", \"!!#{option}\") unless method_defined? \"#{option}?\"\n        self\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1390,
    "raw_source": "def enable(*opts)\n        opts.each { |key| set(key, true) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1395,
    "raw_source": "def disable(*opts)\n        opts.each { |key| set(key, false) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1402,
    "raw_source": "def error(*codes, &block)\n        args  = compile! 'ERROR', /.*/, block\n        codes = codes.flat_map(&method(:Array))\n        codes << Exception if codes.empty?\n        codes << Sinatra::NotFound if codes.include?(404)\n        codes.each { |c| (@errors[c] ||= []) << args }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1411,
    "raw_source": "def not_found(&block)\n        error(404, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1416,
    "raw_source": "def template(name, &block)\n        filename, line = caller_locations.first\n        templates[name] = [block, filename, line.to_i]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1422,
    "raw_source": "def layout(name = :layout, &block)\n        template name, &block\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1428,
    "raw_source": "def inline_templates=(file = nil)\n        file = (caller_files.first || File.expand_path($0)) if file.nil? || file == true\n\n        begin\n          io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file)\n          app, data = io.gsub(\"\\r\\n\", \"\\n\").split(/^__END__$/, 2)\n        rescue Errno::ENOENT\n          app, data = nil\n        end\n\n        return unless data\n\n        encoding = if app && app =~ /([^\\n]*\\n)?#[^\\n]*coding: *(\\S+)/m\n                     $2\n                   else\n                     settings.default_encoding\n                   end\n\n        lines = app.count(\"\\n\") + 1\n        template = nil\n        force_encoding data, encoding\n        data.each_line do |line|\n          lines += 1\n          if line =~ /^@@\\s*(.*\\S)\\s*$/\n            template = force_encoding(String.new, encoding)\n            templates[$1.to_sym] = [template, file, lines]\n          elsif template\n            template << line\n          end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1461,
    "raw_source": "def mime_type(type, value = nil)\n        return type      if type.nil?\n        return type.to_s if type.to_s.include?('/')\n\n        type = \".#{type}\" unless type.to_s[0] == '.'\n        return Rack::Mime.mime_type(type, nil) unless value\n\n        Rack::Mime::MIME_TYPES[type] = value\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1474,
    "raw_source": "def mime_types(type)\n        type = mime_type type\n        if type =~ %r{^application/(xml|javascript)$}\n          [type, \"text/#{$1}\"]\n        elsif type =~ %r{^text/(xml|javascript)$}\n          [type, \"application/#{$1}\"]\n        else\n          [type]\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1488,
    "raw_source": "def before(path = /.*/, **options, &block)\n        add_filter(:before, path, **options, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1495,
    "raw_source": "def after(path = /.*/, **options, &block)\n        add_filter(:after, path, **options, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1500,
    "raw_source": "def add_filter(type, path = /.*/, **options, &block)\n        filters[type] << compile!(type, path, block, **options)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1504,
    "raw_source": "def on_start(&on_start_callback)\n        @on_start_callback = on_start_callback\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1508,
    "raw_source": "def on_stop(&on_stop_callback)\n        @on_stop_callback = on_stop_callback\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1514,
    "raw_source": "def condition(name = \"#{caller.first[/`.*'/]} condition\", &block)\n        @conditions << generate_method(name, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1518,
    "raw_source": "def public=(value)\n        warn_for_deprecation ':public is no longer used to avoid overloading Module#public, use :public_folder or :public_dir instead'\n        set(:public_folder, value)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1523,
    "raw_source": "def public_dir=(value)\n        self.public_folder = value\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1527,
    "raw_source": "def public_dir\n        public_folder\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1533,
    "raw_source": "def get(path, opts = {}, &block)\n        conditions = @conditions.dup\n        route('GET', path, opts, &block)\n\n        @conditions = conditions\n        route('HEAD', path, opts, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1541,
    "raw_source": "def put(path, opts = {}, &block)     route 'PUT',     path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1543,
    "raw_source": "def post(path, opts = {}, &block)    route 'POST',    path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1545,
    "raw_source": "def delete(path, opts = {}, &block)  route 'DELETE',  path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1547,
    "raw_source": "def head(path, opts = {}, &block)    route 'HEAD',    path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1549,
    "raw_source": "def options(path, opts = {}, &block) route 'OPTIONS', path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1551,
    "raw_source": "def patch(path, opts = {}, &block)   route 'PATCH',   path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1553,
    "raw_source": "def link(path, opts = {}, &block)    route 'LINK',    path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1555,
    "raw_source": "def unlink(path, opts = {}, &block)  route 'UNLINK',  path, opts, &block end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1559,
    "raw_source": "def helpers(*extensions, &block)\n        class_eval(&block)   if block_given?\n        include(*extensions) if extensions.any?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1566,
    "raw_source": "def register(*extensions, &block)\n        extensions << Module.new(&block) if block_given?\n        @extensions += extensions\n        extensions.each do |extension|\n          extend extension\n          extension.registered(self) if extension.respond_to?(:registered)\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1575,
    "raw_source": "def development?; environment == :development end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1576,
    "raw_source": "def production?;  environment == :production  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1577,
    "raw_source": "def test?;        environment == :test        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1581,
    "raw_source": "def configure(*envs)\n        yield self if envs.empty? || envs.include?(environment.to_sym)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1586,
    "raw_source": "def use(middleware, *args, &block)\n        @prototype = nil\n        @middleware << [middleware, args, block]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1593,
    "raw_source": "def quit!\n        return unless running?\n\n        # Use Thin's hard #stop! if available, otherwise just #stop.\n        running_server.respond_to?(:stop!) ? running_server.stop! : running_server.stop\n        warn '== Sinatra has ended his set (crowd applauds)' unless suppress_messages?\n        set :running_server, nil\n        set :handler_name, nil\n\n        on_stop_callback.call unless on_stop_callback.nil?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1610,
    "raw_source": "def run!(options = {}, &block)\n        unless defined?(Rackup::Handler)\n          rackup_warning = <<~MISSING_RACKUP\n            Sinatra could not start, the required gems weren't found!\n\n            Add them to your bundle with:\n\n                bundle add rackup puma\n\n            or install them with:\n\n                gem install rackup puma\n\n          MISSING_RACKUP\n          warn rackup_warning\n          exit 1\n        end\n\n        return if running?\n\n        set options\n        handler         = Rackup::Handler.pick(server)\n        handler_name    = handler.name.gsub(/.*::/, '')\n        server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {}\n        server_settings.merge!(Port: port, Host: bind)\n\n        begin\n          start_server(handler, server_settings, handler_name, &block)\n        rescue Errno::EADDRINUSE\n          warn \"== Someone is already performing on port #{port}!\"\n          raise\n        ensure\n          quit!\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1649,
    "raw_source": "def running?\n        running_server?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1654,
    "raw_source": "def prototype\n        @prototype ||= new\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1664,
    "raw_source": "def new(*args, &block)\n        instance = new!(*args, &block)\n        Wrapper.new(build(instance).to_app, instance)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1672,
    "raw_source": "def build(app)\n        builder = Rack::Builder.new\n        setup_default_middleware builder\n        setup_middleware builder\n        builder.run app\n        builder\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1680,
    "raw_source": "def call(env)\n        synchronize { prototype.call(env) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1686,
    "raw_source": "def caller_files\n        cleaned_caller(1).flatten\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1693,
    "raw_source": "def start_server(handler, server_settings, handler_name)\n        # Ensure we initialize middleware before startup, to match standard Rack\n        # behavior, by ensuring an instance exists:\n        prototype\n        # Run the instance we created:\n        handler.run(self, **server_settings) do |server|\n          unless suppress_messages?\n            warn \"== Sinatra (v#{Sinatra::VERSION}) has taken the stage on #{port} for #{environment} with backup from #{handler_name}\"\n          end\n\n          setup_traps\n          set :running_server, server\n          set :handler_name,   handler_name\n          server.threaded = settings.threaded if server.respond_to? :threaded=\n          on_start_callback.call unless on_start_callback.nil?\n          yield server if block_given?\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1712,
    "raw_source": "def suppress_messages?\n        handler_name =~ /cgi/i || quiet\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1716,
    "raw_source": "def setup_traps\n        return unless traps?\n\n        at_exit { quit! }\n\n        %i[INT TERM].each do |signal|\n          old_handler = trap(signal) do\n            quit!\n            old_handler.call if old_handler.respond_to?(:call)\n          end\n        end\n\n        set :traps, false\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1732,
    "raw_source": "def define_singleton(name, content = Proc.new)\n        singleton_class.class_eval do\n          undef_method(name) if method_defined? name\n          String === content ? class_eval(\"def #{name}() #{content}; end\") : define_method(name, &content)\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1740,
    "raw_source": "def host_name(pattern)\n        condition { pattern === request.host }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1746,
    "raw_source": "def user_agent(pattern)\n        condition do\n          if request.user_agent.to_s =~ pattern\n            @params[:agent] = $~[1..-1]\n            true\n          else\n            false\n          end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1759,
    "raw_source": "def provides(*types)\n        types.map! { |t| mime_types(t) }\n        types.flatten!\n        condition do\n          response_content_type = response['content-type']\n          preferred_type = request.preferred_type(types)\n\n          if response_content_type\n            types.include?(response_content_type) || types.include?(response_content_type[/^[^;]+/])\n          elsif preferred_type\n            params = (preferred_type.respond_to?(:params) ? preferred_type.params : {})\n            content_type(preferred_type, params)\n            true\n          else\n            false\n          end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1778,
    "raw_source": "def route(verb, path, options = {}, &block)\n        enable :empty_path_info if path == '' && empty_path_info.nil?\n        signature = compile!(verb, path, block, **options)\n        (@routes[verb] ||= []) << signature\n        invoke_hook(:route_added, verb, path, block)\n        signature\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1786,
    "raw_source": "def invoke_hook(name, *args)\n        extensions.each { |e| e.send(name, *args) if e.respond_to?(name) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1790,
    "raw_source": "def generate_method(method_name, &block)\n        define_method(method_name, &block)\n        method = instance_method method_name\n        remove_method method_name\n        method\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1797,
    "raw_source": "def compile!(verb, path, block, **options)\n        # Because of self.options.host\n        host_name(options.delete(:host)) if options.key?(:host)\n        # Pass Mustermann opts to compile()\n        route_mustermann_opts = options.key?(:mustermann_opts) ? options.delete(:mustermann_opts) : {}.freeze\n\n        options.each_pair { |option, args| send(option, *args) }\n\n        pattern                 = compile(path, route_mustermann_opts)\n        method_name             = \"#{verb} #{path}\"\n        unbound_method          = generate_method(method_name, &block)\n        conditions = @conditions\n        @conditions = []\n        wrapper = block.arity.zero? ?\n          proc { |a, _p| unbound_method.bind(a).call } :\n          proc { |a, p| unbound_method.bind(a).call(*p) }\n\n        [pattern, conditions, wrapper]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1817,
    "raw_source": "def compile(path, route_mustermann_opts = {})\n        Mustermann.new(path, **mustermann_opts.merge(route_mustermann_opts))\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1821,
    "raw_source": "def setup_default_middleware(builder)\n        builder.use ExtendedRack\n        builder.use ShowExceptions       if show_exceptions?\n        builder.use Rack::MethodOverride if method_override?\n        builder.use Rack::Head\n        setup_logging    builder\n        setup_sessions   builder\n        setup_protection builder\n        setup_host_authorization builder\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1832,
    "raw_source": "def setup_middleware(builder)\n        middleware.each { |c, a, b| builder.use(c, *a, &b) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1836,
    "raw_source": "def setup_logging(builder)\n        if logging?\n          setup_common_logger(builder)\n          setup_custom_logger(builder)\n        elsif logging == false\n          setup_null_logger(builder)\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1845,
    "raw_source": "def setup_null_logger(builder)\n        builder.use Sinatra::Middleware::Logger, ::Logger::FATAL\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1849,
    "raw_source": "def setup_common_logger(builder)\n        builder.use Sinatra::CommonLogger\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1853,
    "raw_source": "def setup_custom_logger(builder)\n        if logging.respond_to? :to_int\n          builder.use Sinatra::Middleware::Logger, logging\n        else\n          builder.use Sinatra::Middleware::Logger\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1861,
    "raw_source": "def setup_protection(builder)\n        return unless protection?\n\n        options = Hash === protection ? protection.dup : {}\n        options = {\n          img_src: \"'self' data:\",\n          font_src: \"'self'\"\n        }.merge options\n\n        protect_session = options.fetch(:session) { sessions? }\n        options[:without_session] = !protect_session\n\n        options[:reaction] ||= :drop_session\n\n        builder.use Rack::Protection, options\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1878,
    "raw_source": "def setup_host_authorization(builder)\n        builder.use Rack::Protection::HostAuthorization, host_authorization\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1882,
    "raw_source": "def setup_sessions(builder)\n        return unless sessions?\n\n        options = {}\n        options[:secret] = session_secret if session_secret?\n        options.merge! sessions.to_hash if sessions.respond_to? :to_hash\n        builder.use session_store, options\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1891,
    "raw_source": "def inherited(subclass)\n        subclass.reset!\n        subclass.set :app_file, caller_files.first unless subclass.app_file?\n        super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1898,
    "raw_source": "def synchronize(&block)\n        if lock?\n          @@mutex.synchronize(&block)\n        else\n          yield\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1907,
    "raw_source": "def warn_for_deprecation(message)\n        warn message + \"\\n\\tfrom #{cleaned_caller.first.join(':')}\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1912,
    "raw_source": "def cleaned_caller(keep = 3)\n        caller(1)\n          .map! { |line| line.split(/:(?=\\d|in )/, 3)[0, keep] }\n          .reject { |file, *_| callers_to_ignore.any? { |pattern| file =~ pattern } }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1921,
    "raw_source": "def self.force_encoding(data, encoding = default_encoding)\n      return if data == settings || data.is_a?(Tempfile)\n\n      if data.respond_to? :force_encoding\n        data.force_encoding(encoding).encode!\n      elsif data.respond_to? :each_value\n        data.each_value { |v| force_encoding(v, encoding) }\n      elsif data.respond_to? :each\n        data.each { |v| force_encoding(v, encoding) }\n      end\n      data\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 1934,
    "raw_source": "def force_encoding(*args)\n      settings.force_encoding(*args)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2093,
    "raw_source": "def self.register(*extensions, &block) # :nodoc:\n      added_methods = extensions.flat_map(&:public_instance_methods)\n      Delegator.delegate(*added_methods)\n      super(*extensions, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2104,
    "raw_source": "def self.delegate(*methods)\n      methods.each do |method_name|\n        define_method(method_name) do |*args, &block|\n          return super(*args, &block) if respond_to? method_name\n\n          Delegator.target.send(method_name, *args, &block)\n        end\n        # ensure keyword argument passing is compatible with ruby >= 2.7\n        ruby2_keywords(method_name) if respond_to?(:ruby2_keywords, true)\n        private method_name\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2130,
    "raw_source": "def initialize(stack, instance)\n      @stack = stack\n      @instance = instance\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2135,
    "raw_source": "def settings\n      @instance.settings\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2139,
    "raw_source": "def helpers\n      @instance\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2143,
    "raw_source": "def call(env)\n      @stack.call(env)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2147,
    "raw_source": "def inspect\n      \"#<#{@instance.class} app_file=#{settings.app_file.inspect}>\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2153,
    "raw_source": "def self.new(base = Base, &block)\n    base = Class.new(base)\n    base.class_eval(&block) if block_given?\n    base\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2160,
    "raw_source": "def self.register(*extensions, &block)\n    Delegator.target.register(*extensions, &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2165,
    "raw_source": "def self.helpers(*extensions, &block)\n    Delegator.target.helpers(*extensions, &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/base.rb",
    "start_line": 2170,
    "raw_source": "def self.use(*args, &block)\n    Delegator.target.use(*args, &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 42,
    "raw_source": "def self.[](*args)\n      new.merge!(Hash[*args])\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 46,
    "raw_source": "def default(*args)\n      args.map!(&method(:convert_key))\n\n      super(*args)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 52,
    "raw_source": "def default=(value)\n      super(convert_value(value))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 56,
    "raw_source": "def assoc(key)\n      super(convert_key(key))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 60,
    "raw_source": "def rassoc(value)\n      super(convert_value(value))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 64,
    "raw_source": "def fetch(key, *args)\n      args.map!(&method(:convert_value))\n\n      super(convert_key(key), *args)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 70,
    "raw_source": "def [](key)\n      super(convert_key(key))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 74,
    "raw_source": "def []=(key, value)\n      super(convert_key(key), convert_value(value))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 80,
    "raw_source": "def key(value)\n      super(convert_value(value))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 84,
    "raw_source": "def key?(key)\n      super(convert_key(key))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 92,
    "raw_source": "def value?(value)\n      super(convert_value(value))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 98,
    "raw_source": "def delete(key)\n      super(convert_key(key))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 103,
    "raw_source": "def dig(key, *other_keys)\n      super(convert_key(key), *other_keys)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 107,
    "raw_source": "def fetch_values(*keys)\n      keys.map!(&method(:convert_key))\n\n      super(*keys)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 113,
    "raw_source": "def slice(*keys)\n      keys.map!(&method(:convert_key))\n\n      self.class[super(*keys)]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 119,
    "raw_source": "def values_at(*keys)\n      keys.map!(&method(:convert_key))\n\n      super(*keys)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 125,
    "raw_source": "def merge!(*other_hashes)\n      other_hashes.each do |other_hash|\n        if other_hash.is_a?(self.class)\n          super(other_hash)\n        else\n          other_hash.each_pair do |key, value|\n            key = convert_key(key)\n            value = yield(key, self[key], value) if block_given? && key?(key)\n            self[key] = convert_value(value)\n          end\n        end\n      end\n\n      self\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 143,
    "raw_source": "def merge(*other_hashes, &block)\n      dup.merge!(*other_hashes, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 147,
    "raw_source": "def replace(other_hash)\n      super(other_hash.is_a?(self.class) ? other_hash : self.class[other_hash])\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 151,
    "raw_source": "def transform_values(&block)\n      dup.transform_values!(&block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 155,
    "raw_source": "def transform_values!\n      super\n      super(&method(:convert_value))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 160,
    "raw_source": "def transform_keys(&block)\n      dup.transform_keys!(&block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 164,
    "raw_source": "def transform_keys!\n      super\n      super(&method(:convert_key))\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 169,
    "raw_source": "def select(*args, &block)\n      return to_enum(:select) unless block_given?\n\n      dup.tap { |hash| hash.select!(*args, &block) }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 175,
    "raw_source": "def reject(*args, &block)\n      return to_enum(:reject) unless block_given?\n\n      dup.tap { |hash| hash.reject!(*args, &block) }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 181,
    "raw_source": "def compact\n      dup.tap(&:compact!)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 185,
    "raw_source": "def except(*keys)\n      keys.map!(&method(:convert_key))\n\n      self.class[super(*keys)]\n    end if Gem::Version.new(RUBY_VERSION) >= Gem::Version.new(\"3.0\")"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 193,
    "raw_source": "def convert_key(key)\n      key.is_a?(Symbol) ? key.to_s : key\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/indifferent_hash.rb",
    "start_line": 197,
    "raw_source": "def convert_value(value)\n      case value\n      when Hash\n        value.is_a?(self.class) ? value : self.class[value]\n      when Array\n        value.map(&method(:convert_value))\n      else\n        value\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/middleware/logger.rb",
    "start_line": 8,
    "raw_source": "def initialize(app, level = ::Logger::INFO)\n        @app, @level = app, level\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/middleware/logger.rb",
    "start_line": 12,
    "raw_source": "def call(env)\n        logger = ::Logger.new(env[Rack::RACK_ERRORS])\n        logger.level = @level\n\n        env[Rack::RACK_LOGGER] = logger\n        @app.call(env)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 14,
    "raw_source": "def @@eats_errors.flush(*) end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 16,
    "raw_source": "def @@eats_errors.puts(*) end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 18,
    "raw_source": "def initialize(app)\n      @app = app\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 22,
    "raw_source": "def call(env)\n      @app.call(env)\n    rescue Exception => e\n      errors = env['rack.errors']\n      env['rack.errors'] = @@eats_errors\n\n      if prefers_plain_text?(env)\n        content_type = 'text/plain'\n        body = dump_exception(e)\n      else\n        content_type = 'text/html'\n        body = pretty(env, e)\n      end\n\n      env['rack.errors'] = errors\n\n      [\n        500,\n        {\n          'content-type' => content_type,\n          'content-length' => body.bytesize.to_s\n        },\n        [body]\n      ]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 48,
    "raw_source": "def template\n      TEMPLATE\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 54,
    "raw_source": "def bad_request?(exception)\n      Sinatra::BadRequest === exception\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 58,
    "raw_source": "def prefers_plain_text?(env)\n      Request.new(env).preferred_type('text/plain', 'text/html') != 'text/html' &&\n        [/curl/].index { |item| item =~ env['HTTP_USER_AGENT'] }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/lib/sinatra/show_exceptions.rb",
    "start_line": 63,
    "raw_source": "def frame_class(frame)\n      if frame.filename =~ %r{lib/sinatra.*\\.rb}\n        'framework'\n      elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) ||\n            frame.filename =~ %r{/bin/(\\w+)\\z}\n        'system'\n      else\n        'app'\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection.rb",
    "start_line": 27,
    "raw_source": "def self.new(app, options = {})\n      except = Array options[:except]\n      use_these = Array options[:use]\n\n      if options.fetch(:without_session, false)\n        except += %i[remote_token]\n      end\n\n      Rack::Builder.new do\n        # Off by default, unless added\n        use ::Rack::Protection::AuthenticityToken,     options if use_these.include? :authenticity_token\n        use ::Rack::Protection::ContentSecurityPolicy, options if use_these.include? :content_security_policy\n        use ::Rack::Protection::CookieTossing,         options if use_these.include? :cookie_tossing\n        use ::Rack::Protection::EscapedParams,         options if use_these.include? :escaped_params\n        use ::Rack::Protection::FormToken,             options if use_these.include? :form_token\n        use ::Rack::Protection::ReferrerPolicy,        options if use_these.include? :referrer_policy\n        use ::Rack::Protection::RemoteReferrer,        options if use_these.include? :remote_referrer\n        use ::Rack::Protection::SessionHijacking,      options if use_these.include? :session_hijacking\n        use ::Rack::Protection::StrictTransport,       options if use_these.include? :strict_transport\n\n        # On by default, unless skipped\n        use ::Rack::Protection::FrameOptions,          options unless except.include? :frame_options\n        use ::Rack::Protection::HttpOrigin,            options unless except.include? :http_origin\n        use ::Rack::Protection::IPSpoofing,            options unless except.include? :ip_spoofing\n        use ::Rack::Protection::JsonCsrf,              options unless except.include? :json_csrf\n        use ::Rack::Protection::PathTraversal,         options unless except.include? :path_traversal\n        use ::Rack::Protection::RemoteToken,           options unless except.include? :remote_token\n        use ::Rack::Protection::XSSHeader,             options unless except.include? :xss_header\n        run app\n      end.to_app\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 105,
    "raw_source": "def self.token(session, path: nil, method: :post)\n        new(nil).mask_authenticity_token(session, path: path, method: method)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 109,
    "raw_source": "def self.random_token\n        SecureRandom.urlsafe_base64(TOKEN_LENGTH, padding: false)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 113,
    "raw_source": "def accepts?(env)\n        session = session(env)\n        set_token(session)\n\n        safe?(env) ||\n          valid_token?(env, env['HTTP_X_CSRF_TOKEN']) ||\n          valid_token?(env, Request.new(env).params[options[:authenticity_param]]) ||\n          options[:allow_if]&.call(env)\n      rescue StandardError\n        false\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 125,
    "raw_source": "def mask_authenticity_token(session, path: nil, method: :post)\n        set_token(session)\n\n        token = if path && method\n                  per_form_token(session, path, method)\n                else\n                  global_token(session)\n                end\n\n        mask_token(token)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 142,
    "raw_source": "def set_token(session)\n        session[options[:key]] ||= self.class.random_token\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 148,
    "raw_source": "def valid_token?(env, token)\n        return false if token.nil? || !token.is_a?(String) || token.empty?\n\n        session = session(env)\n\n        begin\n          token = decode_token(token)\n        rescue ArgumentError # encoded_masked_token is invalid Base64\n          return false\n        end\n\n        # See if it's actually a masked token or not. We should be able\n        # to handle any unmasked tokens that we've issued without error.\n\n        if unmasked_token?(token)\n          compare_with_real_token(token, session)\n        elsif masked_token?(token)\n          token = unmask_token(token)\n\n          compare_with_global_token(token, session) ||\n            compare_with_real_token(token, session) ||\n            compare_with_per_form_token(token, session, Request.new(env))\n        else\n          false # Token is malformed\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 178,
    "raw_source": "def mask_token(token)\n        one_time_pad = SecureRandom.random_bytes(token.length)\n        encrypted_token = xor_byte_strings(one_time_pad, token)\n        masked_token = one_time_pad + encrypted_token\n        encode_token(masked_token)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 186,
    "raw_source": "def unmask_token(masked_token)\n        # Split the token into the one-time pad and the encrypted\n        # value and decrypt it\n        token_length = masked_token.length / 2\n        one_time_pad = masked_token[0...token_length]\n        encrypted_token = masked_token[token_length..]\n        xor_byte_strings(one_time_pad, encrypted_token)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 195,
    "raw_source": "def unmasked_token?(token)\n        token.length == TOKEN_LENGTH\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 199,
    "raw_source": "def masked_token?(token)\n        token.length == TOKEN_LENGTH * 2\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 203,
    "raw_source": "def compare_with_real_token(token, session)\n        secure_compare(token, real_token(session))\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 207,
    "raw_source": "def compare_with_global_token(token, session)\n        secure_compare(token, global_token(session))\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 211,
    "raw_source": "def compare_with_per_form_token(token, session, request)\n        secure_compare(token,\n                       per_form_token(session, request.path.chomp('/'), request.request_method))\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 216,
    "raw_source": "def real_token(session)\n        decode_token(session[options[:key]])\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 220,
    "raw_source": "def global_token(session)\n        token_hmac(session, GLOBAL_TOKEN_IDENTIFIER)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 224,
    "raw_source": "def per_form_token(session, path, method)\n        token_hmac(session, \"#{path}##{method.downcase}\")\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 228,
    "raw_source": "def encode_token(token)\n        Base64.urlsafe_encode64(token)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 232,
    "raw_source": "def decode_token(token)\n        Base64.urlsafe_decode64(token)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 236,
    "raw_source": "def token_hmac(session, identifier)\n        OpenSSL::HMAC.digest(\n          OpenSSL::Digest.new('SHA256'),\n          real_token(session),\n          identifier\n        )\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/authenticity_token.rb",
    "start_line": 244,
    "raw_source": "def xor_byte_strings(s1, s2)\n        s2 = s2.dup\n        size = s1.bytesize\n        i = 0\n        while i < size\n          s2.setbyte(i, s1.getbyte(i) ^ s2.getbyte(i))\n          i += 1\n        end\n        s2\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 23,
    "raw_source": "def self.default_options(options)\n        define_method(:default_options) { super().merge(options) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 27,
    "raw_source": "def self.default_reaction(reaction)\n        alias_method(:default_reaction, reaction)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 31,
    "raw_source": "def default_options\n        DEFAULT_OPTIONS\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 35,
    "raw_source": "def initialize(app, options = {})\n        @app = app\n        @options = default_options.merge(options)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 40,
    "raw_source": "def safe?(env)\n        %w[GET HEAD OPTIONS TRACE].include? env['REQUEST_METHOD']\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 44,
    "raw_source": "def accepts?(env)\n        raise NotImplementedError, \"#{self.class} implementation pending\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 48,
    "raw_source": "def call(env)\n        unless accepts? env\n          instrument env\n          result = react env\n        end\n        result or app.call(env)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 56,
    "raw_source": "def react(env)\n        result = send(options[:reaction], env)\n        result if (Array === result) && (result.size == 3)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 61,
    "raw_source": "def debug(env, message)\n        return unless options[:logging]\n\n        l = options[:logger] || env['rack.logger'] || ::Logger.new(env['rack.errors'])\n        l.debug(message)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 68,
    "raw_source": "def warn(env, message)\n        return unless options[:logging]\n\n        l = options[:logger] || env['rack.logger'] || ::Logger.new(env['rack.errors'])\n        l.warn(message)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 75,
    "raw_source": "def instrument(env)\n        return unless (i = options[:instrumenter])\n\n        env['rack.protection.attack'] = self.class.name.split('::').last.downcase\n        i.instrument('rack.protection', env)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 82,
    "raw_source": "def deny(env)\n        warn env, \"attack prevented by #{self.class}\"\n        [options[:status], { 'content-type' => 'text/plain' }, [options[:message]]]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 87,
    "raw_source": "def report(env)\n        warn env, \"attack reported by #{self.class}\"\n        env[options[:report_key]] = true\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 92,
    "raw_source": "def session?(env)\n        env.include? options[:session_key]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 96,
    "raw_source": "def session(env)\n        return env[options[:session_key]] if session? env\n\n        raise \"you need to set up a session middleware *before* #{self.class}\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 102,
    "raw_source": "def drop_session(env)\n        return unless session? env\n\n        session(env).clear\n\n        return if [\"1\", \"true\"].include?(ENV[\"RACK_PROTECTION_SILENCE_DROP_SESSION_WARNING\"])\n\n        warn env, \"session dropped by #{self.class}\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 112,
    "raw_source": "def referrer(env)\n        ref = env['HTTP_REFERER'].to_s\n        return if !options[:allow_empty_referrer] && ref.empty?\n\n        URI.parse(ref).host || Request.new(env).host\n      rescue URI::InvalidURIError\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 120,
    "raw_source": "def origin(env)\n        env['HTTP_ORIGIN'] || env['HTTP_X_ORIGIN']\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 124,
    "raw_source": "def random_string(secure = defined? SecureRandom)\n        secure ? SecureRandom.hex(16) : '%032x' % rand((2**128) - 1)\n      rescue NotImplementedError\n        random_string false\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 130,
    "raw_source": "def encrypt(value)\n        options[:encryptor].hexdigest value.to_s\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 134,
    "raw_source": "def secure_compare(a, b)\n        Rack::Utils.secure_compare(a.to_s, b.to_s)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/base.rb",
    "start_line": 140,
    "raw_source": "def html?(headers)\n        return false unless (header = headers.detect { |k, _v| k.downcase == 'content-type' })\n\n        options[:html_types].include? header.last[%r{^\\w+/\\w+}]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/content_security_policy.rb",
    "start_line": 53,
    "raw_source": "def csp_policy\n        directives = []\n\n        DIRECTIVES.each do |d|\n          if options.key?(d)\n            directives << \"#{d.to_s.sub(/_/, '-')} #{options[d]}\"\n          end\n        end\n\n        # Set these key values to boolean 'true' to include in policy\n        NO_ARG_DIRECTIVES.each do |d|\n          if options.key?(d) && options[d].is_a?(TrueClass)\n            directives << d.to_s.tr('_', '-')\n          end\n        end\n\n        directives.compact.sort.join('; ')\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/content_security_policy.rb",
    "start_line": 72,
    "raw_source": "def call(env)\n        status, headers, body = @app.call(env)\n        header = options[:report_only] ? 'content-security-policy-report-only' : 'content-security-policy'\n        headers[header] ||= csp_policy if html? headers\n        [status, headers, body]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 22,
    "raw_source": "def call(env)\n        status, headers, body = super\n        response = Rack::Response.new(body, status, headers)\n        request = Rack::Request.new(env)\n        remove_bad_cookies(request, response)\n        response.finish\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 30,
    "raw_source": "def accepts?(env)\n        cookie_header = env['HTTP_COOKIE']\n        cookies = Rack::Utils.parse_query(cookie_header, ';,') { |s| s }\n        cookies.each do |k, v|\n          if (k == session_key && Array(v).size > 1) ||\n             (k != session_key && Rack::Utils.unescape(k) == session_key)\n            bad_cookies << k\n          end\n        end\n        bad_cookies.empty?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 42,
    "raw_source": "def remove_bad_cookies(request, response)\n        return if bad_cookies.empty?\n\n        paths = cookie_paths(request.path)\n        bad_cookies.each do |name|\n          paths.each { |path| response.set_cookie name, empty_cookie(request.host, path) }\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 51,
    "raw_source": "def redirect(env)\n        request = Request.new(env)\n        warn env, \"attack prevented by #{self.class}\"\n        [302, { 'content-type' => 'text/html', 'location' => request.path }, []]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 57,
    "raw_source": "def bad_cookies\n        @bad_cookies ||= []\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 61,
    "raw_source": "def cookie_paths(path)\n        path = '/' if path.to_s.empty?\n        paths = []\n        Pathname.new(path).descend { |p| paths << p.to_s }\n        paths\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 68,
    "raw_source": "def empty_cookie(host, path)\n        { value: '', domain: host, path: path, expires: Time.at(0) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/cookie_tossing.rb",
    "start_line": 72,
    "raw_source": "def session_key\n        @session_key ||= options[:session_key]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/escaped_params.rb",
    "start_line": 36,
    "raw_source": "def initialize(*)\n        super\n\n        modes       = Array options[:escape]\n        @escaper    = options[:escaper]\n        @html       = modes.include? :html\n        @javascript = modes.include? :javascript\n        @url        = modes.include? :url\n\n        return unless @javascript && (!@escaper.respond_to? :escape_javascript)\n\n        raise('Use EscapeUtils for JavaScript escaping.')\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/escaped_params.rb",
    "start_line": 50,
    "raw_source": "def call(env)\n        request  = Request.new(env)\n        get_was  = handle(request.GET)\n        post_was = begin\n          handle(request.POST)\n        rescue StandardError\n          nil\n        end\n        app.call env\n      ensure\n        request.GET.replace  get_was  if get_was\n        request.POST.replace post_was if post_was\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/escaped_params.rb",
    "start_line": 64,
    "raw_source": "def handle(hash)\n        was = hash.dup\n        hash.replace escape(hash)\n        was\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/escaped_params.rb",
    "start_line": 70,
    "raw_source": "def escape(object)\n        case object\n        when Hash   then escape_hash(object)\n        when Array  then object.map { |o| escape(o) }\n        when String then escape_string(object)\n        when Tempfile then object\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/escaped_params.rb",
    "start_line": 79,
    "raw_source": "def escape_hash(hash)\n        hash = hash.dup\n        hash.each { |k, v| hash[k] = escape(v) }\n        hash\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/escaped_params.rb",
    "start_line": 85,
    "raw_source": "def escape_string(str)\n        str = @escaper.escape_url(str)        if @url\n        str = @escaper.escape_html(str)       if @html\n        str = @escaper.escape_javascript(str) if @javascript\n        str\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/form_token.rb",
    "start_line": 20,
    "raw_source": "def accepts?(env)\n        env['HTTP_X_REQUESTED_WITH'] == 'XMLHttpRequest' or super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/frame_options.rb",
    "start_line": 24,
    "raw_source": "def frame_options\n        @frame_options ||= begin\n          frame_options = options[:frame_options]\n          frame_options = options[:frame_options].to_s.upcase unless frame_options.respond_to? :to_str\n          frame_options.to_str\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/frame_options.rb",
    "start_line": 32,
    "raw_source": "def call(env)\n        status, headers, body        = @app.call(env)\n        headers['x-frame-options'] ||= frame_options if html? headers\n        [status, headers, body]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/host_authorization.rb",
    "start_line": 33,
    "raw_source": "def initialize(*)\n        super\n        @permitted_hosts = []\n        @domain_hosts = []\n        @ip_hosts = []\n        @all_permitted_hosts = Array(options[:permitted_hosts])\n\n        @all_permitted_hosts.each do |host|\n          case host\n          when String\n            if host.start_with?(DOT)\n              domain = host[1..-1]\n              @permitted_hosts << domain.downcase\n              @domain_hosts << /\\A#{SUBDOMAINS}#{Regexp.escape(domain)}\\z/i\n            else\n              @permitted_hosts << host.downcase\n            end\n          when IPAddr then @ip_hosts << host\n          end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/host_authorization.rb",
    "start_line": 55,
    "raw_source": "def accepts?(env)\n        return true if options[:allow_if]&.call(env)\n        return true if @all_permitted_hosts.empty?\n\n        request = Request.new(env)\n        origin_host = extract_host(request.host_authority)\n        forwarded_host = extract_host(request.forwarded_authority)\n\n        debug env, \"#{self.class} \" \\\n                   \"@all_permitted_hosts=#{@all_permitted_hosts.inspect} \" \\\n                   \"@permitted_hosts=#{@permitted_hosts.inspect} \" \\\n                   \"@domain_hosts=#{@domain_hosts.inspect} \" \\\n                   \"@ip_hosts=#{@ip_hosts.inspect} \" \\\n                   \"origin_host=#{origin_host.inspect} \" \\\n                   \"forwarded_host=#{forwarded_host.inspect}\"\n\n        if host_permitted?(origin_host)\n          if forwarded_host.nil?\n            true\n          else\n            host_permitted?(forwarded_host)\n          end\n        else\n          false\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/host_authorization.rb",
    "start_line": 84,
    "raw_source": "def extract_host(authority)\n        authority.to_s.split(PORT_REGEXP).first&.downcase\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/host_authorization.rb",
    "start_line": 88,
    "raw_source": "def host_permitted?(host)\n        exact_match?(host) || domain_match?(host) || ip_match?(host)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/host_authorization.rb",
    "start_line": 92,
    "raw_source": "def exact_match?(host)\n        @permitted_hosts.include?(host)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/host_authorization.rb",
    "start_line": 96,
    "raw_source": "def domain_match?(host)\n        return false if host.nil?\n        return false if host.start_with?(DOT)\n\n        @domain_hosts.any? { |domain_host| host.match?(domain_host) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/host_authorization.rb",
    "start_line": 103,
    "raw_source": "def ip_match?(host)\n        @ip_hosts.any? { |ip_host| ip_host.include?(host) }\n      rescue IPAddr::InvalidAddressError\n        false\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/http_origin.rb",
    "start_line": 26,
    "raw_source": "def base_url(env)\n        request = Rack::Request.new(env)\n        port = \":#{request.port}\" unless request.port == DEFAULT_PORTS[request.scheme]\n        \"#{request.scheme}://#{request.host}#{port}\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/http_origin.rb",
    "start_line": 32,
    "raw_source": "def accepts?(env)\n        return true if safe? env\n        return true unless (origin = env['HTTP_ORIGIN'])\n        return true if base_url(env) == origin\n        return true if options[:allow_if]&.call(env)\n\n        permitted_origins = options[:permitted_origins]\n        Array(permitted_origins).include? origin\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/ip_spoofing.rb",
    "start_line": 16,
    "raw_source": "def accepts?(env)\n        return true unless env.include? 'HTTP_X_FORWARDED_FOR'\n\n        ips = env['HTTP_X_FORWARDED_FOR'].split(',').map(&:strip)\n        return false if env.include?('HTTP_CLIENT_IP') && (!ips.include? env['HTTP_CLIENT_IP'])\n        return false if env.include?('HTTP_X_REAL_IP') && (!ips.include? env['HTTP_X_REAL_IP'])\n\n        true\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/json_csrf.rb",
    "start_line": 26,
    "raw_source": "def call(env)\n        request               = Request.new(env)\n        status, headers, body = app.call(env)\n\n        if has_vector?(request, headers)\n          warn env, \"attack prevented by #{self.class}\"\n\n          react_and_close(env, body) or [status, headers, body]\n        else\n          [status, headers, body]\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/json_csrf.rb",
    "start_line": 39,
    "raw_source": "def has_vector?(request, headers)\n        return false if request.xhr?\n        return false if options[:allow_if]&.call(request.env)\n        return false unless headers['content-type'].to_s.split(';', 2).first =~ %r{^\\s*application/json\\s*$}\n\n        origin(request.env).nil? and referrer(request.env) != request.host\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/json_csrf.rb",
    "start_line": 47,
    "raw_source": "def react_and_close(env, body)\n        reaction = react(env)\n\n        close_body(body) if reaction\n\n        reaction\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/json_csrf.rb",
    "start_line": 55,
    "raw_source": "def close_body(body)\n        body.close if body.respond_to?(:close)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/path_traversal.rb",
    "start_line": 15,
    "raw_source": "def call(env)\n        path_was         = env['PATH_INFO']\n        env['PATH_INFO'] = cleanup path_was if path_was && !path_was.empty?\n        app.call env\n      ensure\n        env['PATH_INFO'] = path_was\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/path_traversal.rb",
    "start_line": 23,
    "raw_source": "def cleanup(path)\n        encoding = path.encoding\n        dot   = '.'.encode(encoding)\n        slash = '/'.encode(encoding)\n        backslash = '\\\\'.encode(encoding)\n\n        parts     = []\n        unescaped = path.gsub(/%2e/i, dot).gsub(/%2f/i, slash).gsub(/%5c/i, backslash)\n        unescaped = unescaped.gsub(backslash, slash)\n\n        unescaped.split(slash).each do |part|\n          next if part.empty? || (part == dot)\n\n          part == '..' ? parts.pop : parts << part\n        end\n\n        cleaned = slash + parts.join(slash)\n        cleaned << slash if parts.any? && unescaped =~ (%r{/\\.{0,2}$})\n        cleaned\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/referrer_policy.rb",
    "start_line": 20,
    "raw_source": "def call(env)\n        status, headers, body = @app.call(env)\n        headers['referrer-policy'] ||= options[:referrer_policy]\n        [status, headers, body]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/remote_referrer.rb",
    "start_line": 17,
    "raw_source": "def accepts?(env)\n        safe?(env) or referrer(env) == Request.new(env).host\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/remote_token.rb",
    "start_line": 19,
    "raw_source": "def accepts?(env)\n        super or referrer(env) == Request.new(env).host\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/session_hijacking.rb",
    "start_line": 21,
    "raw_source": "def accepts?(env)\n        session = session env\n        key     = options[:tracking_key]\n        if session.include? key\n          session[key].all? { |k, v| v == encode(env[k]) }\n        else\n          session[key] = {}\n          options[:track].each { |k| session[key][k] = encode(env[k]) }\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/session_hijacking.rb",
    "start_line": 32,
    "raw_source": "def encode(value)\n        value.to_s.downcase\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/strict_transport.rb",
    "start_line": 25,
    "raw_source": "def strict_transport\n        @strict_transport ||= begin\n          strict_transport = \"max-age=#{options[:max_age]}\"\n          strict_transport += '; includeSubDomains' if options[:include_subdomains]\n          strict_transport += '; preload' if options[:preload]\n          strict_transport.to_str\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/strict_transport.rb",
    "start_line": 34,
    "raw_source": "def call(env)\n        status, headers, body = @app.call(env)\n        headers['strict-transport-security'] ||= strict_transport\n        [status, headers, body]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/lib/rack/protection/xss_header.rb",
    "start_line": 19,
    "raw_source": "def call(env)\n        status, headers, body = @app.call(env)\n        headers['x-xss-protection']       ||= \"1; mode=#{options[:xss_mode]}\" if html? headers\n        headers['x-content-type-options'] ||= 'nosniff'                       if options[:nosniff]\n        [status, headers, body]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/lib/rack/protection/host_authorization_spec.rb",
    "start_line": 8,
    "raw_source": "def assert_response(outcome:, headers:, last_response:)\n    fail_message = \"Expected outcome '#{outcome}' for headers '#{headers}' \" \\\n                   \"last_response.status '#{last_response.status}'\"\n\n    case outcome\n    when :allowed\n      expect(last_response).to be_ok, fail_message\n    when :stopped\n      expect(last_response.status).to eq(403), fail_message\n      expect(last_response.body).to eq('Host not permitted'), fail_message\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/lib/rack/protection/json_csrf_spec.rb",
    "start_line": 8,
    "raw_source": "def close\n        @closed = true\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/lib/rack/protection/json_csrf_spec.rb",
    "start_line": 12,
    "raw_source": "def closed?\n        @closed\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/lib/rack/protection/json_csrf_spec.rb",
    "start_line": 17,
    "raw_source": "def self.body\n      @body ||= begin\n        body = ['ok']\n        body.extend(Closeable)\n        body\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/lib/rack/protection/json_csrf_spec.rb",
    "start_line": 25,
    "raw_source": "def self.call(env)\n      Thread.current[:last_env] = env\n      [200, { 'content-type' => 'application/json' }, body]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/dummy_app.rb",
    "start_line": 4,
    "raw_source": "def self.call(env)\n    Thread.current[:last_env] = env\n    body = (env['REQUEST_METHOD'] == 'HEAD' ? '' : 'ok')\n    [200, { 'content-type' => env['wants'] || 'text/plain' }, [body]]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/not_implemented_as_pending.rb",
    "start_line": 5,
    "raw_source": "def self.included(base)\n    base.class_eval do\n      alias_method :__finish__, :finish\n      remove_method :finish\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/not_implemented_as_pending.rb",
    "start_line": 12,
    "raw_source": "def finish(reporter)\n    if @exception.is_a?(NotImplementedError)\n      from = @exception.backtrace[0]\n      message = \"#{@exception.message} (from #{from})\"\n      @pending_declared_in_example = message\n      metadata[:pending] = true\n      @exception = nil\n    end\n\n    __finish__(reporter)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/shared_examples.rb",
    "start_line": 16,
    "raw_source": "def call(env)\n        was = env.dup\n        res = app.call(env)\n        was.each do |k, v|\n          next if env[k] == v\n\n          raise \"env[#{k.inspect}] changed from #{v.inspect} to #{env[k].inspect}\"\n        end\n        res\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/shared_examples.rb",
    "start_line": 42,
    "raw_source": "def call(env)\n        env['foo.bar'] = 42\n        app.call(env)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/shared_examples.rb",
    "start_line": 48,
    "raw_source": "def call(env)\n        app.call(env)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/spec_helpers.rb",
    "start_line": 11,
    "raw_source": "def app\n    @app ||= nil\n    @app || mock_app(DummyApp)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/spec_helpers.rb",
    "start_line": 16,
    "raw_source": "def mock_app(app = nil, lint: true, &block)\n    app = block if app.nil? && (block.arity == 1)\n    if app\n      klass = described_class\n      mock_app do\n        use Rack::Head\n        use(Rack::Config) { |e| e['rack.session'] ||= {} }\n        use klass\n        run app\n      end\n    elsif lint\n      @app = Rack::Lint.new Rack::Builder.new(&block).to_app\n    else\n      @app = Rack::Builder.new(&block).to_app\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/spec_helpers.rb",
    "start_line": 33,
    "raw_source": "def with_headers(headers)\n    proc { [200, { 'content-type' => 'text/plain' }.merge(headers), ['ok']] }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/rack-protection/spec/support/spec_helpers.rb",
    "start_line": 37,
    "raw_source": "def env\n    Thread.current[:last_env]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/capture.rb",
    "start_line": 87,
    "raw_source": "def capture(*args, &block)\n      return block[*args] if ruby?\n\n      if haml? && Tilt[:haml] == Tilt::HamlTemplate && defined?(Haml::Buffer)\n        buffer = Haml::Buffer.new(nil, Haml::Options.new.for_buffer)\n        with_haml_buffer(buffer) { capture_haml(*args, &block) }\n      else\n        buf_was = @_out_buf\n        @_out_buf = +''\n        begin\n          raw = block[*args]\n          captured = block.binding.eval('@_out_buf')\n          captured.empty? ? raw : captured\n        ensure\n          @_out_buf = buf_was\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/capture.rb",
    "start_line": 106,
    "raw_source": "def capture_later(&block)\n      engine = current_engine\n      proc { |*a| with_engine(engine) { @capture = capture(*a, &block) } }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/config_file.rb",
    "start_line": 111,
    "raw_source": "def self.registered(base)\n      base.set :environments, %w[test production development]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/config_file.rb",
    "start_line": 118,
    "raw_source": "def config_file(*paths)\n      Dir.chdir(root || '.') do\n        paths.each do |pattern|\n          Dir.glob(pattern) do |file|\n            raise UnsupportedConfigType unless ['.yml', '.yaml', '.erb'].include?(File.extname(file))\n\n            logger.info \"loading config file '#{file}'\" if logging? && respond_to?(:logger)\n            document = ERB.new(File.read(file)).result\n            yaml = YAML.respond_to?(:unsafe_load) ? YAML.unsafe_load(document) : YAML.load(document)\n            config = config_for_env(yaml)\n            config.each_pair { |key, value| set(key, value) }\n          end\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/config_file.rb",
    "start_line": 135,
    "raw_source": "def message\n        'Invalid config file type, use .yml, .yaml or .erb'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/config_file.rb",
    "start_line": 145,
    "raw_source": "def config_for_env(hash)\n      return from_environment_key(hash) if environment_keys?(hash)\n\n      hash.each_with_object(IndifferentHash[]) do |(k, v), acc|\n        if environment_keys?(v)\n          acc.merge!(k => v[environment.to_s]) if v.key?(environment.to_s)\n        else\n          acc.merge!(k => v)\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/config_file.rb",
    "start_line": 159,
    "raw_source": "def from_environment_key(hash)\n      hash[environment.to_s] || hash[environment.to_sym] || {}\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/config_file.rb",
    "start_line": 165,
    "raw_source": "def environment_keys?(hash)\n      hash.is_a?(Hash) && hash.any? { |k, _| environments.include?(k.to_s) }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/content_for.rb",
    "start_line": 132,
    "raw_source": "def content_for(key, value = nil, options = {}, &block)\n      block ||= proc { |*| value }\n      clear_content_for(key) if options[:flush]\n      content_blocks[key.to_sym] << capture_later(&block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/content_for.rb",
    "start_line": 148,
    "raw_source": "def content_for?(key)\n      content_blocks[key.to_sym].any?\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/content_for.rb",
    "start_line": 155,
    "raw_source": "def clear_content_for(key)\n      content_blocks.delete(key.to_sym) if content_for?(key)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/content_for.rb",
    "start_line": 176,
    "raw_source": "def yield_content(key, *args, &block)\n      if block_given? && !content_for?(key)\n        haml? && Tilt[:haml] == Tilt::HamlTemplate && respond_to?(:capture_haml) ? capture_haml(*args, &block) : yield(*args)\n      else\n        content = content_blocks[key.to_sym].map { |b| capture(*args, &b) }\n        content.join.tap do |c|\n          if block_given? && (erb? || erubi?)\n            @_out_buf << c\n          end\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/content_for.rb",
    "start_line": 191,
    "raw_source": "def content_blocks\n      @content_blocks ||= Hash.new { |h, k| h[k] = [] }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/contrib/setup.rb",
    "start_line": 9,
    "raw_source": "def extensions\n        @extensions ||= { helpers: [], register: [] }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/contrib/setup.rb",
    "start_line": 13,
    "raw_source": "def register(name, path)\n        autoload name, path, :register\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/contrib/setup.rb",
    "start_line": 17,
    "raw_source": "def helpers(name, path)\n        autoload name, path, :helpers\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/contrib/setup.rb",
    "start_line": 21,
    "raw_source": "def autoload(name, path, method = nil)\n        extensions[method] << name if method\n        Sinatra.autoload(name, path)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/contrib/setup.rb",
    "start_line": 26,
    "raw_source": "def registered(base)\n        @extensions.each do |method, list|\n          list = list.map { |name| Sinatra.const_get name }\n          base.send(method, *list) unless base == ::Sinatra::Application\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/contrib/setup.rb",
    "start_line": 43,
    "raw_source": "def self.registered(base)\n        base.register Common, Custom\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/contrib/setup.rb",
    "start_line": 49,
    "raw_source": "def self.registered(base)\n      base.register Common, Custom\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 62,
    "raw_source": "def initialize(app)\n        @response_array  = nil\n        @response_hash   = {}\n        @response        = app.response\n        @request         = app.request\n        @deleted         = []\n\n        @options = {\n          path: @request.script_name.to_s.empty? ? '/' : @request.script_name,\n          domain: @request.host == 'localhost' ? nil : @request.host,\n          secure: @request.secure?,\n          httponly: true\n        }\n\n        return unless app.settings.respond_to? :cookie_options\n\n        @options.merge! app.settings.cookie_options\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 81,
    "raw_source": "def ==(other)\n        other.respond_to? :to_hash and to_hash == other.to_hash\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 85,
    "raw_source": "def [](key)\n        response_cookies[key.to_s] || request_cookies[key.to_s]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 89,
    "raw_source": "def []=(key, value)\n        set(key, value: value)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 94,
    "raw_source": "def assoc(key)\n          to_hash.assoc(key.to_s)\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 99,
    "raw_source": "def clear\n        each_key { |k| delete(k) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 103,
    "raw_source": "def compare_by_identity?\n        false\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 107,
    "raw_source": "def default\n        nil\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 113,
    "raw_source": "def delete(key)\n        result = self[key]\n        @response.delete_cookie(key.to_s, @options)\n        result\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 119,
    "raw_source": "def delete_if\n        return enum_for(__method__) unless block_given?\n\n        each { |k, v| delete(k) if yield(k, v) }\n        self\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 126,
    "raw_source": "def each(&block)\n        return enum_for(__method__) unless block_given?\n\n        to_hash.each(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 132,
    "raw_source": "def each_key(&block)\n        return enum_for(__method__) unless block_given?\n\n        to_hash.each_key(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 140,
    "raw_source": "def each_value(&block)\n        return enum_for(__method__) unless block_given?\n\n        to_hash.each_value(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 146,
    "raw_source": "def empty?\n        to_hash.empty?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 150,
    "raw_source": "def fetch(key, &block)\n        response_cookies.fetch(key.to_s) do\n          request_cookies.fetch(key.to_s, &block)\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 157,
    "raw_source": "def flatten\n          to_hash.flatten\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 162,
    "raw_source": "def has_key?(key)\n        response_cookies.key? key.to_s or request_cookies.key? key.to_s\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 166,
    "raw_source": "def has_value?(value)\n        response_cookies.value? value or request_cookies.value? value\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 170,
    "raw_source": "def hash\n        to_hash.hash\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 177,
    "raw_source": "def inspect\n        \"<##{self.class}: #{to_hash.inspect[1..-2]}>\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 182,
    "raw_source": "def invert\n          to_hash.invert\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 187,
    "raw_source": "def keep_if\n        return enum_for(__method__) unless block_given?\n\n        delete_if { |*a| !yield(*a) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 193,
    "raw_source": "def key(value)\n        to_hash.key(value)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 199,
    "raw_source": "def keys\n        to_hash.keys\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 203,
    "raw_source": "def length\n        to_hash.length\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 207,
    "raw_source": "def merge(other, &block)\n        to_hash.merge(other, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 211,
    "raw_source": "def merge!(other)\n        other.each_pair do |key, value|\n          self[key] = if block_given? && include?(key)\n                        yield(key.to_s, self[key], value)\n                      else\n                        value\n                      end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 221,
    "raw_source": "def rassoc(value)\n        to_hash.rassoc(value)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 225,
    "raw_source": "def rehash\n        response_cookies.rehash\n        request_cookies.rehash\n        self\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 231,
    "raw_source": "def reject(&block)\n        return enum_for(__method__) unless block_given?\n\n        to_hash.reject(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 239,
    "raw_source": "def replace(other)\n        select! { |k, _v| other.include?(k) or other.include?(k.to_s) }\n        merge! other\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 244,
    "raw_source": "def select(&block)\n        return enum_for(__method__) unless block_given?\n\n        to_hash.select(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 252,
    "raw_source": "def set(key, options = {})\n        @response.set_cookie key.to_s, @options.merge(options)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 256,
    "raw_source": "def shift\n        key, value = to_hash.shift\n        delete(key)\n        [key, value]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 265,
    "raw_source": "def sort(&block)\n          to_hash.sort(&block)\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 272,
    "raw_source": "def to_hash\n        request_cookies.merge(response_cookies)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 276,
    "raw_source": "def to_a\n        to_hash.to_a\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 280,
    "raw_source": "def to_s\n        to_hash.to_s\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 287,
    "raw_source": "def values\n        to_hash.values\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 291,
    "raw_source": "def values_at(*list)\n        list.map { |k| self[k] }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 297,
    "raw_source": "def warn(message)\n        super \"#{caller.first[/^[^:]:\\d+:/]} warning: #{message}\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 301,
    "raw_source": "def deleted\n        parse_response\n        @deleted\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 306,
    "raw_source": "def response_cookies\n        parse_response\n        @response_hash\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 311,
    "raw_source": "def parse_response\n        cookies_from_response = Array(@response['Set-Cookie'])\n        return if @response_array == cookies_from_response\n\n        hash = {}\n\n        cookies_from_response.each do |line|\n          key, value = line.split(';', 2).first.to_s.split('=', 2)\n          next if key.nil?\n\n          key = Rack::Utils.unescape(key)\n          if line =~ /expires=Thu, 01[-\\s]Jan[-\\s]1970/\n            @deleted << key\n          else\n            @deleted.delete key\n            hash[key] = value\n          end\n        end\n\n        @response_hash.replace hash\n        @response_array = cookies_from_response\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 334,
    "raw_source": "def request_cookies\n        @request.cookies.reject { |key, _value| deleted.include? key }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/cookies.rb",
    "start_line": 339,
    "raw_source": "def cookies\n      @cookies ||= Jar.new(self)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/custom_logger.rb",
    "start_line": 51,
    "raw_source": "def logger\n      if settings.respond_to?(:logger)\n        settings.logger\n      else\n        request.logger\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 12,
    "raw_source": "def erb?\n      @current_engine == :erb\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 20,
    "raw_source": "def erubi?\n      @current_engine == :erubi or\n        (erb? && Tilt[:erb] == Tilt::ErubiTemplate)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 26,
    "raw_source": "def haml?\n      @current_engine == :haml\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 31,
    "raw_source": "def sass?\n      @current_engine == :sass\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 36,
    "raw_source": "def scss?\n      @current_engine == :scss\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 41,
    "raw_source": "def builder?\n      @current_engine == :builder\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 46,
    "raw_source": "def liquid?\n      @current_engine == :liquid\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 51,
    "raw_source": "def markdown?\n      @current_engine == :markdown\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 56,
    "raw_source": "def rdoc?\n      @current_engine == :rdoc\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 61,
    "raw_source": "def markaby?\n      @current_engine == :markaby\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 66,
    "raw_source": "def nokogiri?\n      @current_engine == :nokogiri\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 71,
    "raw_source": "def slim?\n      @current_engine == :slim\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 76,
    "raw_source": "def ruby?\n      @current_engine == :ruby\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 80,
    "raw_source": "def initialize(*)\n      @current_engine = :ruby\n      super\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 86,
    "raw_source": "def with_engine(engine)\n      engine_was = @current_engine\n      @current_engine = engine.to_sym\n      yield\n    ensure\n      @current_engine = engine_was\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/engine_tracking.rb",
    "start_line": 96,
    "raw_source": "def render(engine, *)\n      with_engine(engine) { super }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 51,
    "raw_source": "def self.new(&block)\n      ext = Module.new.extend(self)\n      ext.class_eval(&block)\n      ext\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 57,
    "raw_source": "def settings\n      self\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 61,
    "raw_source": "def configure(*args, &block)\n      record(:configure, *args) { |c| c.instance_exec(c, &block) }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 65,
    "raw_source": "def registered(base = nil, &block)\n      base ? replay(base) : record(:class_eval, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 71,
    "raw_source": "def record(method, *args, &block)\n      recorded_methods << [method, args, block]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 75,
    "raw_source": "def replay(object)\n      recorded_methods.each { |m, a, b| object.send(m, *a, &b) }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 79,
    "raw_source": "def recorded_methods\n      @recorded_methods ||= []\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 83,
    "raw_source": "def method_missing(method, *args, &block)\n      return super unless Sinatra::Base.respond_to? method\n\n      record(method, *args, &block)\n      DontCall.new(method)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 91,
    "raw_source": "def initialize(method) @method = method end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 92,
    "raw_source": "def method_missing(*) raise \"not supposed to use result of #{@method}!\" end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/extension.rb",
    "start_line": 93,
    "raw_source": "def inspect; \"#<#{self.class}: #{@method}>\" end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/haml_helpers.rb",
    "start_line": 32,
    "raw_source": "def surround(front, back = front, &block)\n      \"#{front}#{_capture_haml(&block).chomp}#{back}\\n\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/haml_helpers.rb",
    "start_line": 36,
    "raw_source": "def precede(str, &block)\n      \"#{str}#{_capture_haml(&block).chomp}\\n\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/haml_helpers.rb",
    "start_line": 40,
    "raw_source": "def succeed(str, &block)\n      \"#{_capture_haml(&block).chomp}#{str}\\n\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/haml_helpers.rb",
    "start_line": 44,
    "raw_source": "def _capture_haml(*args, &block)\n      capture(*args, &block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/json.rb",
    "start_line": 92,
    "raw_source": "def encode(object)\n        ::MultiJson.dump(object)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/json.rb",
    "start_line": 97,
    "raw_source": "def json(object, options = {})\n      content_type resolve_content_type(options)\n      resolve_encoder_action object, resolve_encoder(options)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/json.rb",
    "start_line": 104,
    "raw_source": "def resolve_content_type(options = {})\n      options[:content_type] || settings.json_content_type\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/json.rb",
    "start_line": 108,
    "raw_source": "def resolve_encoder(options = {})\n      options[:json_encoder] || settings.json_encoder\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/json.rb",
    "start_line": 112,
    "raw_source": "def resolve_encoder_action(object, encoder)\n      %i[encode generate].each do |method|\n        return encoder.send(method, object) if encoder.respond_to? method\n      end\n      raise \"#{encoder} does not respond to #generate nor #encode\" unless encoder.is_a? Symbol\n\n      object.__send__(encoder)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/link_header.rb",
    "start_line": 58,
    "raw_source": "def prefetch(*urls)\n      link(:prefetch, *urls)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/link_header.rb",
    "start_line": 64,
    "raw_source": "def stylesheet(*urls)\n      urls << {} unless urls.last.respond_to? :to_hash\n      urls.last[:type] ||= mime_type(:css)\n      link(:stylesheet, *urls)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/link_header.rb",
    "start_line": 83,
    "raw_source": "def link(*urls)\n      opts          = urls.last.respond_to?(:to_hash) ? urls.pop : {}\n      opts[:rel]    = urls.shift unless urls.first.respond_to? :to_str\n      options       = opts.map { |k, v| \" #{k}=#{v.to_s.inspect}\" }\n      html_pattern  = \"<link href=\\\"%s\\\"#{options.join} />\"\n      http_pattern  = ['<%s>', *options].join ';'\n      link          = (response['Link'] ||= '')\n\n      link = response['Link'] = +link\n\n      urls.map do |url|\n        link << \",\" unless link.empty?\n        link << (http_pattern % url)\n        html_pattern % url\n      end.join\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/link_header.rb",
    "start_line": 118,
    "raw_source": "def link_headers\n      yield if block_given?\n      return '' unless response.include? 'Link'\n\n      response['Link'].split(\",\").map do |line|\n        url, *opts = line.split(';').map(&:strip)\n        \"<link href=\\\"#{url[1..-2]}\\\" #{opts.join ' '} />\"\n      end.join\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/link_header.rb",
    "start_line": 128,
    "raw_source": "def self.registered(_base)\n      puts \"WARNING: #{self} is a helpers module, not an extension.\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 61,
    "raw_source": "def head(*args, &block)     super(*route_args(args), &block)  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 62,
    "raw_source": "def delete(*args, &block)   super(*route_args(args), &block)  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 63,
    "raw_source": "def get(*args, &block)      super(*route_args(args), &block)  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 64,
    "raw_source": "def options(*args, &block)  super(*route_args(args), &block)  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 65,
    "raw_source": "def patch(*args, &block)    super(*route_args(args), &block)  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 66,
    "raw_source": "def post(*args, &block)     super(*route_args(args), &block)  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 67,
    "raw_source": "def put(*args, &block)      super(*route_args(args), &block)  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 69,
    "raw_source": "def route(*args, &block)\n      options = Hash === args.last ? args.pop : {}\n      routes = [*args.pop]\n      args.each do |verb|\n        verb = verb.to_s.upcase if Symbol === verb\n        routes.each do |route|\n          super(verb, route, options, &block)\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/multi_route.rb",
    "start_line": 82,
    "raw_source": "def route_args(args)\n      options = Hash === args.last ? args.pop : {}\n      [args, options]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 189,
    "raw_source": "def self.new(base, pattern, conditions = {}, &block)\n      Module.new do\n        # quelch uninitialized variable warnings, since these get used by compile method.\n        @pattern = nil\n        @conditions = nil\n        extend NamespacedMethods\n        include InstanceMethods\n        @base = base\n        @extensions = []\n        @errors = {}\n        @pattern, @conditions = compile(pattern, conditions)\n        @templates            = Hash.new { |_h, k| @base.templates[k] }\n        namespace = self\n        before { extend(@namespace = namespace) }\n        class_eval(&block)\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 208,
    "raw_source": "def settings\n        @namespace\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 212,
    "raw_source": "def template_cache\n        super.fetch(:nested, @namespace) { TemplateCache.new }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 216,
    "raw_source": "def redirect_to(uri, *args)\n        redirect(\"#{@namespace.pattern}#{uri}\", *args)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 222,
    "raw_source": "def namespace(pattern, conditions = {}, &block)\n        Sinatra::Namespace.new(self, pattern, conditions, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 237,
    "raw_source": "def self.prefixed(*names)\n        names.each { |n| define_method(n) { |*a, &b| prefixed(n, *a, &b) } }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 243,
    "raw_source": "def helpers(*extensions, &block)\n        class_eval(&block) if block_given?\n        include(*extensions) if extensions.any?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 248,
    "raw_source": "def register(*extensions, &block)\n        extensions << Module.new(&block) if block_given?\n        @extensions += extensions\n        extensions.each do |extension|\n          extend extension\n          extension.registered(self) if extension.respond_to?(:registered)\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 257,
    "raw_source": "def invoke_hook(name, *args)\n        @extensions.each { |e| e.send(name, *args) if e.respond_to?(name) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 261,
    "raw_source": "def not_found(&block)\n        error(Sinatra::NotFound, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 265,
    "raw_source": "def errors\n        base.errors.merge(namespace_errors)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 269,
    "raw_source": "def namespace_errors\n        @errors\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 273,
    "raw_source": "def error(*codes, &block)\n        args  = Sinatra::Base.send(:compile!, 'ERROR', /.*/, block)\n        codes = codes.map { |c| Array(c) }.flatten\n        codes << Exception if codes.empty?\n        codes << Sinatra::NotFound if codes.include?(404)\n\n        codes.each do |c|\n          errors = @errors[c] ||= []\n          errors << args\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 285,
    "raw_source": "def respond_to(*args)\n        return @conditions[:provides] || base.respond_to if args.empty?\n\n        @conditions[:provides] = args\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 291,
    "raw_source": "def set(key, value = self, &block)\n        return key.each { |k, v| set(k, v) } if key.respond_to?(:each) && block.nil? && (value == self)\n        raise ArgumentError, \"may not set #{key}\" unless ([:views] + ALLOWED_ENGINES).include?(key)\n\n        block ||= proc { value }\n        singleton_class.send(:define_method, key, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 299,
    "raw_source": "def enable(*opts)\n        opts.each { |key| set(key, true) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 303,
    "raw_source": "def disable(*opts)\n        opts.each { |key| set(key, false) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 307,
    "raw_source": "def template(name, &block)\n        first_location = caller_locations.first\n        filename = first_location.path\n        line = first_location.lineno\n        templates[name] = [block, filename, line]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 314,
    "raw_source": "def layout(name = :layout, &block)\n        template name, &block\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 318,
    "raw_source": "def pattern\n        @pattern\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 324,
    "raw_source": "def app\n        base.respond_to?(:base) ? base.base : base\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 328,
    "raw_source": "def compile(pattern, conditions, default_pattern = nil)\n        if pattern.respond_to? :to_hash\n          conditions = conditions.merge pattern.to_hash\n          pattern = nil\n        end\n        base_pattern = @pattern\n        base_conditions = @conditions\n        pattern ||= default_pattern\n        [prefixed_path(base_pattern, pattern),\n         (base_conditions || {}).merge(conditions)]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 340,
    "raw_source": "def prefixed_path(a, b)\n        return a || b || /.*/ unless a && b\n        return Mustermann.new(b) if a == /.*/\n\n        Mustermann.new(a) + Mustermann.new(b)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 347,
    "raw_source": "def prefixed(method, pattern = nil, conditions = {}, &block)\n        default = %r{(?:/.*)?} if (method == :before) || (method == :after)\n        pattern, conditions = compile pattern, conditions, default\n        result = base.send(method, pattern, **conditions, &block)\n        invoke_hook :route_added, method.to_s.upcase, pattern, block\n        result\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 355,
    "raw_source": "def method_missing(method, *args, &block)\n        base.send(method, *args, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 359,
    "raw_source": "def respond_to?(method, include_private = false)\n        super || base.respond_to?(method, include_private)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/namespace.rb",
    "start_line": 368,
    "raw_source": "def self.extended(base)\n      base.extend BaseMethods\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/quiet_logger.rb",
    "start_line": 37,
    "raw_source": "def self.registered(app)\n      quiet_logger_prefixes = begin\n        app.settings.quiet_logger_prefixes.join('|')\n      rescue StandardError\n        ''\n      end\n      return warn('You need to specify the paths you wish to exclude from logging via `set :quiet_logger_prefixes, %w(images css fonts)`') if quiet_logger_prefixes.empty?\n\n      const_set('QUIET_LOGGER_REGEX', %r(\\A/{0,2}(?:#{quiet_logger_prefixes})))\n      ::Rack::CommonLogger.prepend(\n        ::Module.new do\n          def log(env, *)\n            super unless env['PATH_INFO'] =~ QUIET_LOGGER_REGEX\n          end\n        end\n      )\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/quiet_logger.rb",
    "start_line": 48,
    "raw_source": "def log(env, *)\n            super unless env['PATH_INFO'] =~ QUIET_LOGGER_REGEX\n          end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 128,
    "raw_source": "def self.for(app)\n          @app_list_map[app]\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 133,
    "raw_source": "def initialize\n          @path_watcher_map = Hash.new do |hash, key|\n            hash[key] = Watcher.new(key)\n          end\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 142,
    "raw_source": "def watch(path, element)\n          watcher_for(path).elements << element\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 149,
    "raw_source": "def ignore(path)\n          watcher_for(path).ignore\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 155,
    "raw_source": "def watcher_for(path)\n          @path_watcher_map[File.expand_path(path)]\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 161,
    "raw_source": "def watchers\n          @path_watcher_map.values\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 167,
    "raw_source": "def updated\n          watchers.find_all(&:updated?)\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 175,
    "raw_source": "def initialize(path)\n        @ignore = nil\n        @path = path\n        @elements = []\n        update\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 183,
    "raw_source": "def updated?\n        !ignore? && !removed? && mtime != File.mtime(path)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 188,
    "raw_source": "def update\n        @mtime = File.mtime(path)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 194,
    "raw_source": "def inline_templates?\n        elements.any? { |element| element.type == :inline_templates }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 200,
    "raw_source": "def ignore\n        @ignore = true\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 206,
    "raw_source": "def ignore?\n        !!@ignore\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 211,
    "raw_source": "def removed?\n        !File.exist?(path)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 220,
    "raw_source": "def after_reload(&block)\n      @@after_reload << block\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 227,
    "raw_source": "def self.registered(klass)\n      @reloader_loaded_in ||= {}\n      return if @reloader_loaded_in[klass]\n\n      @reloader_loaded_in[klass] = true\n\n      klass.extend BaseMethods\n      klass.extend ExtensionMethods\n      klass.set(:reloader) { klass.development? }\n      klass.set(:reload_templates) { klass.reloader? }\n      klass.before do\n        if klass.reloader?\n          MUTEX_FOR_PERFORM.synchronize { Reloader.perform(klass) }\n        end\n      end\n      klass.set(:inline_templates, klass.app_file) if klass == Sinatra::Application\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 247,
    "raw_source": "def self.perform(klass)\n      reloaded_paths = []\n      Watcher::List.for(klass).updated.each do |watcher|\n        klass.set(:inline_templates, watcher.path) if watcher.inline_templates?\n        watcher.elements.each { |element| klass.deactivate(element) }\n        # Deletes all old elements.\n        watcher.elements.delete_if { true }\n        $LOADED_FEATURES.delete(watcher.path)\n        require watcher.path\n        watcher.update\n        reloaded_paths << watcher.path\n      end\n      return if reloaded_paths.empty?\n\n      @@after_reload.each do |block|\n        block.arity.zero? ? block.call : block.call(reloaded_paths)\n      end\n      # Prevents after_reload from increasing each time it's reloaded.\n      @@after_reload.delete_if do |blk|\n        path, = blk.source_location\n        path && reloaded_paths.include?(path)\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 274,
    "raw_source": "def run!(*args)\n        if settings.reloader?\n          super unless running?\n        else\n          super\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 288,
    "raw_source": "def compile!(verb, path, block, **options)\n        source_location = block.respond_to?(:source_location) ?\n          block.source_location.first : caller_files[1]\n        signature = super\n        watch_element(\n          source_location, :route, { verb: verb, signature: signature }\n        )\n        signature\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 302,
    "raw_source": "def inline_templates=(file = nil)\n        file = (caller_files[1] || File.expand_path($0)) if file.nil? || file == true\n        watch_element(file, :inline_templates)\n        super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 311,
    "raw_source": "def use(middleware, *args, &block)\n        path = caller_files[1] || File.expand_path($0)\n        watch_element(path, :middleware, [middleware, args, block])\n        super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 320,
    "raw_source": "def add_filter(type, path = nil, **options, &block)\n        source_location = block.respond_to?(:source_location) ?\n          block.source_location.first : caller_files[1]\n        result = super\n        watch_element(source_location, :\"#{type}_filter\", filters[type].last)\n        result\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 331,
    "raw_source": "def error(*codes, &block)\n        path = caller_files[1] || File.expand_path($0)\n        result = super\n        codes.each do |c|\n          watch_element(path, :error, code: c, handler: @errors[c])\n        end\n        result\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 343,
    "raw_source": "def register(*extensions, &block)\n        start_registering_extension\n        result = super\n        stop_registering_extension\n        result\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 352,
    "raw_source": "def inherited(subclass)\n        result = super\n        subclass.register Sinatra::Reloader\n        result\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 362,
    "raw_source": "def deactivate(element)\n        case element.type\n        when :route\n          verb      = element.representation[:verb]\n          signature = element.representation[:signature]\n          (routes[verb] ||= []).delete(signature)\n        when :middleware\n          @middleware.delete(element.representation)\n        when :before_filter\n          filters[:before].delete(element.representation)\n        when :after_filter\n          filters[:after].delete(element.representation)\n        when :error\n          code    = element.representation[:code]\n          handler = element.representation[:handler]\n          @errors.delete(code) if @errors[code] == handler\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 383,
    "raw_source": "def also_reload(*glob)\n        Dir[*glob].each { |path| Watcher::List.for(self).watch_file(path) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 389,
    "raw_source": "def dont_reload(*glob)\n        Dir[*glob].each { |path| Watcher::List.for(self).ignore(path) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 396,
    "raw_source": "def register_path; @register_path ||= nil; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 399,
    "raw_source": "def start_registering_extension\n        @register_path = caller_files[2]\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 404,
    "raw_source": "def stop_registering_extension\n        @register_path = nil\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 409,
    "raw_source": "def registering_extension?\n        !register_path.nil?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/reloader.rb",
    "start_line": 421,
    "raw_source": "def watch_element(path, type, representation = nil)\n        list = Watcher::List.for(self)\n        element = Watcher::Element.new(type, representation)\n        list.watch(path, element)\n        list.watch(register_path, element) if registering_extension?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/required_params.rb",
    "start_line": 49,
    "raw_source": "def required_params(*keys)\n      _required_params(params, *keys)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/required_params.rb",
    "start_line": 55,
    "raw_source": "def _required_params(p, *keys)\n      keys.each do |key|\n        if key.is_a?(Hash)\n          _required_params(p, *key.keys)\n          key.each do |k, v|\n            _required_params(p[k.to_s], v)\n          end\n        elsif key.is_a?(Array)\n          _required_params(p, *key)\n        else\n          halt 400 unless p.respond_to?(:key?) && p&.key?(key.to_s)\n        end\n      end\n      true\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 92,
    "raw_source": "def initialize(app)\n        @app = app\n        @map = {}\n        @generic = {}\n        @default = nil\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 99,
    "raw_source": "def on(type, &block)\n        @app.settings.mime_types(type).each do |mime|\n          case mime\n          when '*/*'            then @default     = block\n          when %r{^([^/]+)/\\*$} then @generic[$1] = block\n          else                       @map[mime]   = block\n          end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 109,
    "raw_source": "def finish\n        yield self if block_given?\n        mime_type = @app.content_type ||\n                    @app.request.preferred_type(@map.keys)  ||\n                    @app.request.preferred_type             ||\n                    'text/html'\n        type = mime_type.split(/\\s*;\\s*/, 2).first\n        handlers = [@map[type], @generic[type[%r{^[^/]+}]], @default].compact\n        handlers.each do |block|\n          if (result = block.call(type))\n            @app.content_type mime_type\n            @app.halt result\n          end\n        end\n        @app.halt 500, 'Unknown template engine'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 126,
    "raw_source": "def method_missing(method, *args, &block)\n        return super if args.any? || block.nil? || !@app.mime_type(method)\n\n        on(method, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 136,
    "raw_source": "def respond_with(template, object = nil, &block)\n        unless Symbol === template\n          object = template\n          template = nil\n        end\n        format = Format.new(self)\n        format.on '*/*' do |type|\n          exts = settings.ext_map[type]\n          exts << :xml if type.end_with? '+xml'\n          if template\n            args = template_cache.fetch(type, template) { template_for(template, exts) }\n            if args.any?\n              locals = { object: object }\n              locals.merge! object.to_hash if object.respond_to? :to_hash\n\n              renderer = args.first\n              options = args[1..] + [{ locals: locals }]\n\n              halt send(renderer, *options)\n            end\n          end\n          if object\n            exts.each do |ext|\n              halt json(object) if ext == :json\n              next unless object.respond_to? method = \"to_#{ext}\"\n\n              halt(*object.send(method))\n            end\n          end\n          false\n        end\n        format.finish(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 170,
    "raw_source": "def respond_to(&block)\n        Format.new(self).finish(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 176,
    "raw_source": "def template_for(name, exts)\n        # in production this is cached, so don't worry too much about runtime\n        possible = []\n        settings.template_engines[:all].each do |engine|\n          exts.each { |ext| possible << [engine, \"#{name}.#{ext}\"] }\n        end\n\n        exts.each do |ext|\n          settings.template_engines[ext].each { |e| possible << [e, name] }\n        end\n\n        possible.each do |engine, template|\n          klass = Tilt.default_mapping.template_map[engine.to_s] ||\n                  Tilt.lazy_map[engine.to_s].fetch(0, [])[0]\n\n          find_template(settings.views, template, klass) do |file|\n            next unless File.exist? file\n\n            return settings.rendering_method(engine) << template.to_sym\n          end\n        end\n        [] # nil or false would not be cached\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 201,
    "raw_source": "def remap_extensions\n      ext_map.clear\n      Rack::Mime::MIME_TYPES.each { |e, t| ext_map[t] << e[1..].to_sym }\n      ext_map['text/javascript'] << 'js'\n      ext_map['text/xml'] << 'xml'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 208,
    "raw_source": "def mime_type(*)\n      result = super\n      remap_extensions\n      result\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 214,
    "raw_source": "def respond_to(*formats)\n      @respond_to ||= nil\n\n      if formats.any?\n        @respond_to ||= []\n        @respond_to.concat formats\n      elsif @respond_to.nil? && superclass.respond_to?(:respond_to)\n        superclass.respond_to\n      else\n        @respond_to\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 227,
    "raw_source": "def rendering_method(engine)\n      return [engine] if Sinatra::Templates.method_defined? engine\n      return [:mab] if engine.to_sym == :markaby\n\n      %i[render engine]\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 236,
    "raw_source": "def compile!(verb, path, block, **options)\n      options[:provides] ||= respond_to if respond_to\n      super\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 241,
    "raw_source": "def self.jrubyify(engs)\n      not_supported = [:markdown]\n      engs.each_key do |key|\n        engs[key].collect! { |eng| eng == :yajl ? :json_pure : eng }\n        engs[key].delete_if { |eng| not_supported.include?(eng) }\n      end\n      engs\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 250,
    "raw_source": "def self.engines\n      engines = {\n        css: %i[sass scss],\n        xml: %i[builder nokogiri],\n        html: %i[erb erubi haml hamlit slim liquid\n                 mab markdown rdoc],\n        all: (Sinatra::Templates.instance_methods.map(&:to_sym) +\n          [:mab] - %i[find_template markaby]),\n        json: [:yajl]\n      }\n      engines.default = []\n      defined?(JRUBY_VERSION) ? jrubyify(engines) : engines\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/respond_with.rb",
    "start_line": 264,
    "raw_source": "def self.registered(base)\n      base.set :ext_map, Hash.new { |h, k| h[k] = [] }\n      base.set :template_engines, engines\n      base.remap_extensions\n      base.helpers Helpers\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 53,
    "raw_source": "def app_file\n      File.expand_path('server.rb', __dir__)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 57,
    "raw_source": "def run\n      @pipe     = start\n      @started  = Time.now\n      warn \"#{server} up and running on port #{port}\" if ping\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 63,
    "raw_source": "def kill\n      return unless pipe\n\n      Process.kill('KILL', pipe.pid)\n    rescue NotImplementedError\n      system \"kill -9 #{pipe.pid}\"\n    rescue Errno::ESRCH\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 72,
    "raw_source": "def get(url)\n      Timeout.timeout(1) { get_url(\"#{protocol}://127.0.0.1:#{port}#{url}\") }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 76,
    "raw_source": "def get_stream(url = '/stream', &block)\n      Net::HTTP.start '127.0.0.1', port do |http|\n        request = Net::HTTP::Get.new url\n        http.request request do |response|\n          response.read_body(&block)\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 85,
    "raw_source": "def get_response(url)\n      Net::HTTP.start '127.0.0.1', port do |http|\n        request = Net::HTTP::Get.new url\n        http.request request do |response|\n          response\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 94,
    "raw_source": "def log\n      @log ||= +''\n      loop { @log << pipe.read_nonblock(1) }\n    rescue Exception\n      @log\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 105,
    "raw_source": "def start\n      IO.popen(command)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 110,
    "raw_source": "def command\n      \"bundle exec ruby #{app_file} -p #{port} -e production\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 114,
    "raw_source": "def ping(timeout = 30)\n      loop do\n        return if alive?\n\n        if Time.now - @started > timeout\n          warn command, log\n          raise \"timeout starting server with command '#{command}'\"\n        else\n          sleep 0.1\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 127,
    "raw_source": "def alive?\n      3.times { get(ping_path) }\n      true\n    rescue EOFError, SystemCallError, OpenURI::HTTPError, Timeout::Error\n      false\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 135,
    "raw_source": "def ping_path\n      '/ping'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 140,
    "raw_source": "def port\n      4567\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 144,
    "raw_source": "def protocol\n      'http'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 148,
    "raw_source": "def get_url(url)\n      uri = URI.parse(url)\n\n      return uri.read unless protocol == 'https'\n\n      get_https_url(uri)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/runner.rb",
    "start_line": 156,
    "raw_source": "def get_https_url(uri)\n      http = Net::HTTP.new(uri.host, uri.port)\n      http.use_ssl      = true\n      http.verify_mode  = OpenSSL::SSL::VERIFY_NONE\n      request = Net::HTTP::Get.new(uri.request_uri)\n      http.request(request).body\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 79,
    "raw_source": "def stream(*)\n      stream = super\n      stream.extend Stream\n      stream.app = self\n      env['async.close'].callback { stream.close } if env.key? 'async.close'\n      stream\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 92,
    "raw_source": "def self.extended(obj)\n        obj.closed = false\n        obj.lineno = 0\n        obj.pos = 0\n        obj.callback { obj.closed = true }\n        obj.errback  { obj.closed = true }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 100,
    "raw_source": "def <<(data)\n        raise IOError, 'not opened for writing' if closed?\n\n        @transformer ||= nil\n        data = data.to_s\n        data = @transformer[data] if @transformer\n        @pos += data.bytesize\n        super(data)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 110,
    "raw_source": "def each\n        # that way body.each.map { ... } works\n        return self unless block_given?\n\n        super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 117,
    "raw_source": "def map(&block)\n        # dup would not copy the mixin\n        clone.map!(&block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 122,
    "raw_source": "def map!(&block)\n        @transformer ||= nil\n\n        if @transformer\n          inner = @transformer\n          outer = block\n          block = proc { |value| outer[inner[value]] }\n        end\n        @transformer = block\n        self\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 134,
    "raw_source": "def write(data)\n        self << data\n        data.to_s.bytesize\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 142,
    "raw_source": "def print(*args)\n        args.each { |arg| self << arg }\n        nil\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 147,
    "raw_source": "def printf(format, *args)\n        print(format.to_s % args)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 151,
    "raw_source": "def putc(c)\n        print c.chr\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 155,
    "raw_source": "def puts(*args)\n        args.each { |arg| self << \"#{arg}\\n\" }\n        nil\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 160,
    "raw_source": "def close_read\n        raise IOError, 'closing non-duplex IO for reading'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 164,
    "raw_source": "def closed_read?\n        true\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 168,
    "raw_source": "def closed_write?\n        closed?\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 172,
    "raw_source": "def external_encoding\n        Encoding.find settings.default_encoding\n      rescue NameError\n        settings.default_encoding\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 178,
    "raw_source": "def settings\n        app.settings\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 182,
    "raw_source": "def rewind\n        @pos = @lineno = 0\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 186,
    "raw_source": "def not_open_for_reading(*)\n        raise IOError, 'not opened for reading'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 208,
    "raw_source": "def enum_not_open_for_reading(*)\n        not_open_for_reading if block_given?\n        enum_for(:not_open_for_reading)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 220,
    "raw_source": "def dummy(*) end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 227,
    "raw_source": "def seek(*)\n        0\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 233,
    "raw_source": "def sync\n        true\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/streaming.rb",
    "start_line": 237,
    "raw_source": "def tty?\n        false\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 123,
    "raw_source": "def mock_app(base = Sinatra::Base, &block)\n      inner = nil\n      @app  = Sinatra.new(base) do\n        inner = self\n        class_eval(&block)\n      end\n      @settings = inner\n      app\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 136,
    "raw_source": "def app=(base)\n      @app = base\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 151,
    "raw_source": "def app\n      @app ||= Class.new Sinatra::Base\n      Rack::Lint.new @app\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 162,
    "raw_source": "def options(uri, params = {}, env = {}, &block)\n        env = env_for(uri, env.merge(method: 'OPTIONS', params: params))\n        current_session.send(:process_request, uri, env, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 174,
    "raw_source": "def patch(uri, params = {}, env = {}, &block)\n        env = env_for(uri, env.merge(method: 'PATCH', params: params))\n        current_session.send(:process_request, uri, env, &block)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 181,
    "raw_source": "def last_request?\n      last_request\n      true\n    rescue Rack::Test::Error\n      false\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 190,
    "raw_source": "def session\n      return {} unless last_request?\n      raise Rack::Test::Error, 'session not enabled for app' unless last_env['rack.session'] || app.session?\n\n      last_request.session\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/test_helpers.rb",
    "start_line": 198,
    "raw_source": "def last_env\n      last_request.env\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 34,
    "raw_source": "def self.registered(_)\n      Sinatra::Request.include WebDAV::Request\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 39,
    "raw_source": "def self.included(base)\n        base.class_eval do\n          alias_method :_safe?, :safe?\n          alias_method :_idempotent?, :idempotent?\n\n          def safe?\n            _safe? or propfind?\n          end\n\n          def idempotent?\n            _idempotent? or propfind? or move? or unlock? # or lock?\n          end\n        end\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 44,
    "raw_source": "def safe?\n            _safe? or propfind?\n          end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 48,
    "raw_source": "def idempotent?\n            _idempotent? or propfind? or move? or unlock? # or lock?\n          end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 54,
    "raw_source": "def propfind?\n        request_method == 'PROPFIND'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 58,
    "raw_source": "def proppatch?\n        request_method == 'PROPPATCH'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 62,
    "raw_source": "def mkcol?\n        request_method == 'MKCOL'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 66,
    "raw_source": "def copy?\n        request_method == 'COPY'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 70,
    "raw_source": "def move?\n        request_method == 'MOVE'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 78,
    "raw_source": "def unlock?\n        request_method == 'UNLOCK'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 83,
    "raw_source": "def propfind(path, opts = {}, &bk)  route 'PROPFIND',  path, opts, &bk end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 84,
    "raw_source": "def proppatch(path, opts = {}, &bk) route 'PROPPATCH', path, opts, &bk end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 85,
    "raw_source": "def mkcol(path, opts = {}, &bk)     route 'MKCOL',     path, opts, &bk end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 86,
    "raw_source": "def copy(path, opts = {}, &bk)      route 'COPY',      path, opts, &bk end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 87,
    "raw_source": "def move(path, opts = {}, &bk)      route 'MOVE',      path, opts, &bk end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/lib/sinatra/webdav.rb",
    "start_line": 89,
    "raw_source": "def unlock(path, opts = {}, &bk)    route 'UNLOCK',    path, opts, &bk end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/capture_spec.rb",
    "start_line": 17,
    "raw_source": "def render(engine, template)\n    subject.send(:render, engine, template.to_sym).strip.gsub(/\\s+/, ' ')\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/config_file_spec.rb",
    "start_line": 4,
    "raw_source": "def config_file(*args, &block)\n    mock_app do\n      register Sinatra::ConfigFile\n      set :root, File.expand_path('config_file', __dir__)\n      instance_eval(&block) if block\n      config_file(*args)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/content_for_spec.rb",
    "start_line": 17,
    "raw_source": "def render(engine, template)\n    subject.send(:render, engine, template, :layout => false).gsub(/\\s/, '')\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/content_for_spec.rb",
    "start_line": 202,
    "raw_source": "def body\n            last_response.body.gsub(/\\s/, '')\n          end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/cookies_spec.rb",
    "start_line": 4,
    "raw_source": "def cookie_route(*cookies, headers: {}, &block)\n    result = nil\n    set_cookie(cookies)\n    @cookie_app.get('/') do\n      result = instance_eval(&block)\n      \"ok\"\n    end\n    get '/', {}, headers || {}\n    expect(last_response).to be_ok\n    expect(body).to eq(\"ok\")\n    result\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/cookies_spec.rb",
    "start_line": 17,
    "raw_source": "def cookies(*set_cookies)\n    cookie_route(*set_cookies) { cookies }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/json_spec.rb",
    "start_line": 33,
    "raw_source": "def mock_app(&block)\n    super do\n      class_eval(&block)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/json_spec.rb",
    "start_line": 39,
    "raw_source": "def results_in(obj)\n    expect(OkJson.decode(get('/').body)).to eq(obj)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/json_spec.rb",
    "start_line": 68,
    "raw_source": "def enc.generate(obj) obj.inspect end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/json_spec.rb",
    "start_line": 75,
    "raw_source": "def enc.encode(obj) obj.inspect end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/json_spec.rb",
    "start_line": 87,
    "raw_source": "def enc.generate(obj) obj.inspect end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/json_spec.rb",
    "start_line": 97,
    "raw_source": "def enc.encode(obj) obj.inspect end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 6,
    "raw_source": "def mock_app(&block)\n    super do\n      register Sinatra::Namespace\n      class_eval(&block)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 13,
    "raw_source": "def namespace(*args, &block)\n    mock_app { namespace(*args, &block) }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 142,
    "raw_source": "def foo\n                  'foo'\n                end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 336,
    "raw_source": "def magic\n                42\n              end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 352,
    "raw_source": "def magic\n              42\n            end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 367,
    "raw_source": "def magic\n              42\n            end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 386,
    "raw_source": "def magic\n                42\n              end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 405,
    "raw_source": "def magic\n              42\n            end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 429,
    "raw_source": "def magic\n                42\n              end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 448,
    "raw_source": "def magic\n                42\n              end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 454,
    "raw_source": "def magic\n                super - 19\n              end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 497,
    "raw_source": "def magic\n                42\n              end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 516,
    "raw_source": "def magic\n                42\n              end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 844,
    "raw_source": "def dump_args(*args)\n            args.inspect\n          end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 851,
    "raw_source": "def dump_args(*args)\n              super(:foo, *args)\n            end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/namespace_spec.rb",
    "start_line": 860,
    "raw_source": "def dump_args(*args)\n              super(:foo_bar, *args)\n            end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 40,
    "raw_source": "def decode(s)\n    ts = lex(s)\n    v, ts = textparse(ts)\n    if ts.length > 0\n      raise Error, 'trailing garbage'\n    end\n    v\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 54,
    "raw_source": "def textparse(ts)\n    if ts.length < 0\n      raise Error, 'empty'\n    end\n\n    typ, _, val = ts[0]\n    case typ\n    when '{' then objparse(ts)\n    when '[' then arrparse(ts)\n    else\n      raise Error, \"unexpected #{val.inspect}\"\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 71,
    "raw_source": "def valparse(ts)\n    if ts.length < 0\n      raise Error, 'empty'\n    end\n\n    typ, _, val = ts[0]\n    case typ\n    when '{' then objparse(ts)\n    when '[' then arrparse(ts)\n    when :val,:str then [val, ts[1..-1]]\n    else\n      raise Error, \"unexpected #{val.inspect}\"\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 89,
    "raw_source": "def objparse(ts)\n    ts = eat('{', ts)\n    obj = {}\n\n    if ts[0][0] == '}'\n      return obj, ts[1..-1]\n    end\n\n    k, v, ts = pairparse(ts)\n    obj[k] = v\n\n    if ts[0][0] == '}'\n      return obj, ts[1..-1]\n    end\n\n    loop do\n      ts = eat(',', ts)\n\n      k, v, ts = pairparse(ts)\n      obj[k] = v\n\n      if ts[0][0] == '}'\n        return obj, ts[1..-1]\n      end\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 119,
    "raw_source": "def pairparse(ts)\n    (typ, _, k), ts = ts[0], ts[1..-1]\n    if typ != :str\n      raise Error, \"unexpected #{k.inspect}\"\n    end\n    ts = eat(':', ts)\n    v, ts = valparse(ts)\n    [k, v, ts]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 132,
    "raw_source": "def arrparse(ts)\n    ts = eat('[', ts)\n    arr = []\n\n    if ts[0][0] == ']'\n      return arr, ts[1..-1]\n    end\n\n    v, ts = valparse(ts)\n    arr << v\n\n    if ts[0][0] == ']'\n      return arr, ts[1..-1]\n    end\n\n    loop do\n      ts = eat(',', ts)\n\n      v, ts = valparse(ts)\n      arr << v\n\n      if ts[0][0] == ']'\n        return arr, ts[1..-1]\n      end\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 160,
    "raw_source": "def eat(typ, ts)\n    if ts[0][0] != typ\n      raise Error, \"expected #{typ} (got #{ts[0].inspect})\"\n    end\n    ts[1..-1]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 170,
    "raw_source": "def lex(s)\n    ts = []\n    while s.length > 0\n      typ, lexeme, val = tok(s)\n      if typ == nil\n        raise Error, \"invalid character at #{s[0,10].inspect}\"\n      end\n      if typ != :space\n        ts << [typ, lexeme, val]\n      end\n      s = s[lexeme.length..-1]\n    end\n    ts\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 199,
    "raw_source": "def tok(s)\n    case s[0]\n    when ?{  then ['{', s[0,1], s[0,1]]\n    when ?}  then ['}', s[0,1], s[0,1]]\n    when ?:  then [':', s[0,1], s[0,1]]\n    when ?,  then [',', s[0,1], s[0,1]]\n    when ?[  then ['[', s[0,1], s[0,1]]\n    when ?]  then [']', s[0,1], s[0,1]]\n    when ?n  then nulltok(s)\n    when ?t  then truetok(s)\n    when ?f  then falsetok(s)\n    when ?\"  then strtok(s)\n    when Spc then [:space, s[0,1], s[0,1]]\n    when ?\\t then [:space, s[0,1], s[0,1]]\n    when ?\\n then [:space, s[0,1], s[0,1]]\n    when ?\\r then [:space, s[0,1], s[0,1]]\n    else          numtok(s)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 220,
    "raw_source": "def nulltok(s);  s[0,4] == 'null'  && [:val, 'null',  nil]   end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 221,
    "raw_source": "def truetok(s);  s[0,4] == 'true'  && [:val, 'true',  true]  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 222,
    "raw_source": "def falsetok(s); s[0,5] == 'false' && [:val, 'false', false] end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 225,
    "raw_source": "def numtok(s)\n    m = /-?([1-9][0-9]+|[0-9])([.][0-9]+)?([eE][+-]?[0-9]+)?/.match(s)\n    if m && m.begin(0) == 0\n      if m[3] && !m[2]\n        [:val, m[0], Integer(m[1])*(10**Integer(m[3][1..-1]))]\n      elsif m[2]\n        [:val, m[0], Float(m[0])]\n      else\n        [:val, m[0], Integer(m[0])]\n      end\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 239,
    "raw_source": "def strtok(s)\n    m = /\"([^\"\\\\]|\\\\[\"\\/\\\\bfnrt]|\\\\u[0-9a-fA-F]{4})*\"/.match(s)\n    if ! m\n      raise Error, \"invalid string literal at #{abbrev(s)}\"\n    end\n    [:str, m[0], unquote(m[0])]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 248,
    "raw_source": "def abbrev(s)\n    t = s[0,10]\n    p = t['`']\n    t = t[0,p] if p\n    t = t + '...' if t.length < s.length\n    '`' + t + '`'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 260,
    "raw_source": "def unquote(q)\n    q = q[1...-1]\n    a = q.dup # allocate a big enough string\n    r, w = 0, 0\n    while r < q.length\n      c = q[r]\n      case true\n      when c == ?\\\\\n        r += 1\n        if r >= q.length\n          raise Error, \"string literal ends with a \\\"\\\\\\\": \\\"#{q}\\\"\"\n        end\n\n        case q[r]\n        when ?\",?\\\\,?/,?'\n          a[w] = q[r]\n          r += 1\n          w += 1\n        when ?b,?f,?n,?r,?t\n          a[w] = Unesc[q[r]]\n          r += 1\n          w += 1\n        when ?u\n          r += 1\n          uchar = begin\n            hexdec4(q[r,4])\n          rescue RuntimeError => e\n            raise Error, \"invalid escape sequence \\\\u#{q[r,4]}: #{e}\"\n          end\n          r += 4\n          if surrogate? uchar\n            if q.length >= r+6\n              uchar1 = hexdec4(q[r+2,4])\n              uchar = subst(uchar, uchar1)\n              if uchar != Ucharerr\n                # A valid pair; consume.\n                r += 6\n              end\n            end\n          end\n          w += ucharenc(a, w, uchar)\n        else\n          raise Error, \"invalid escape char #{q[r]} in \\\"#{q}\\\"\"\n        end\n      when c == ?\", c < Spc\n        raise Error, \"invalid character in string literal \\\"#{q}\\\"\"\n      else\n        # Copy anything else byte-for-byte.\n        # Valid UTF-8 will remain valid UTF-8.\n        # Invalid UTF-8 will remain invalid UTF-8.\n        a[w] = c\n        r += 1\n        w += 1\n      end\n    end\n    a[0,w]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 322,
    "raw_source": "def ucharenc(a, i, u)\n    case true\n    when u <= Uchar1max\n      a[i] = (u & 0xff).chr\n      1\n    when u <= Uchar2max\n      a[i+0] = (Utag2 | ((u>>6)&0xff)).chr\n      a[i+1] = (Utagx | (u&Umaskx)).chr\n      2\n    when u <= Uchar3max\n      a[i+0] = (Utag3 | ((u>>12)&0xff)).chr\n      a[i+1] = (Utagx | ((u>>6)&Umaskx)).chr\n      a[i+2] = (Utagx | (u&Umaskx)).chr\n      3\n    else\n      a[i+0] = (Utag4 | ((u>>18)&0xff)).chr\n      a[i+1] = (Utagx | ((u>>12)&Umaskx)).chr\n      a[i+2] = (Utagx | ((u>>6)&Umaskx)).chr\n      a[i+3] = (Utagx | (u&Umaskx)).chr\n      4\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 346,
    "raw_source": "def hexdec4(s)\n    if s.length != 4\n      raise Error, 'short'\n    end\n    (nibble(s[0])<<12) | (nibble(s[1])<<8) | (nibble(s[2])<<4) | nibble(s[3])\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 354,
    "raw_source": "def subst(u1, u2)\n    if Usurr1 <= u1 && u1 < Usurr2 && Usurr2 <= u2 && u2 < Usurr3\n      return ((u1-Usurr1)<<10) | (u2-Usurr2) + Usurrself\n    end\n    return Ucharerr\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 362,
    "raw_source": "def unsubst(u)\n    if u < Usurrself || u > Umax || surrogate?(u)\n      return Ucharerr, Ucharerr\n    end\n    u -= Usurrself\n    [Usurr1 + ((u>>10)&0x3ff), Usurr2 + (u&0x3ff)]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 371,
    "raw_source": "def surrogate?(u)\n    Usurr1 <= u && u < Usurr3\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 376,
    "raw_source": "def nibble(c)\n    case true\n    when ?0 <= c && c <= ?9 then c.ord - ?0.ord\n    when ?a <= c && c <= ?z then c.ord - ?a.ord + 10\n    when ?A <= c && c <= ?Z then c.ord - ?A.ord + 10\n    else\n      raise Error, \"invalid hex code #{c}\"\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 396,
    "raw_source": "def encode(x)\n    case x\n    when Hash    then objenc(x)\n    when Array   then arrenc(x)\n    else\n      raise Error, 'root value must be an Array or a Hash'\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 406,
    "raw_source": "def valenc(x)\n    case x\n    when Hash    then objenc(x)\n    when Array   then arrenc(x)\n    when String  then strenc(x)\n    when Numeric then numenc(x)\n    when true    then \"true\"\n    when false   then \"false\"\n    when nil     then \"null\"\n    else\n      raise Error, \"cannot encode #{x.class}: #{x.inspect}\"\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 421,
    "raw_source": "def objenc(x)\n    '{' + x.map{|k,v| keyenc(k) + ':' + valenc(v)}.join(',') + '}'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 426,
    "raw_source": "def arrenc(a)\n    '[' + a.map{|x| valenc(x)}.join(',') + ']'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 431,
    "raw_source": "def keyenc(k)\n    case k\n    when String then strenc(k)\n    else\n      raise Error, \"Hash key is not a string: #{k.inspect}\"\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 440,
    "raw_source": "def strenc(s)\n    t = StringIO.new\n    t.putc(?\")\n    r = 0\n    while r < s.length\n      case s[r]\n      when ?\"  then t.print('\\\\\"')\n      when ?\\\\ then t.print('\\\\\\\\')\n      when ?\\b then t.print('\\\\b')\n      when ?\\f then t.print('\\\\f')\n      when ?\\n then t.print('\\\\n')\n      when ?\\r then t.print('\\\\r')\n      when ?\\t then t.print('\\\\t')\n      else\n        c = s[r]\n        case true\n        when Spc <= c && c <= ?~\n          t.putc(c)\n        when true\n          u, size = uchardec(s, r)\n          r += size - 1 # we add one more at the bottom of the loop\n          if u < 0x10000\n            t.print('\\\\u')\n            hexenc4(t, u)\n          else\n            u1, u2 = unsubst(u)\n            t.print('\\\\u')\n            hexenc4(t, u1)\n            t.print('\\\\u')\n            hexenc4(t, u2)\n          end\n        else\n          # invalid byte; skip it\n        end\n      end\n      r += 1\n    end\n    t.putc(?\")\n    t.string\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 482,
    "raw_source": "def hexenc4(t, u)\n    t.putc(Hex[(u>>12)&0xf])\n    t.putc(Hex[(u>>8)&0xf])\n    t.putc(Hex[(u>>4)&0xf])\n    t.putc(Hex[u&0xf])\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 490,
    "raw_source": "def numenc(x)\n    if x.nan? || x.infinite?\n      return 'null'\n    end rescue nil\n    \"#{x}\"\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/okjson.rb",
    "start_line": 501,
    "raw_source": "def uchardec(s, i)\n    n = s.length - i\n    return [Ucharerr, 1] if n < 1\n\n    c0 = s[i].ord\n\n    # 1-byte, 7-bit sequence?\n    if c0 < Utagx\n      return [c0, 1]\n    end\n\n    # unexpected continuation byte?\n    return [Ucharerr, 1] if c0 < Utag2\n\n    # need continuation byte\n    return [Ucharerr, 1] if n < 2\n    c1 = s[i+1].ord\n    return [Ucharerr, 1] if c1 < Utagx || Utag2 <= c1\n\n    # 2-byte, 11-bit sequence?\n    if c0 < Utag3\n      u = (c0&Umask2)<<6 | (c1&Umaskx)\n      return [Ucharerr, 1] if u <= Uchar1max\n      return [u, 2]\n    end\n\n    # need second continuation byte\n    return [Ucharerr, 1] if n < 3\n    c2 = s[i+2].ord\n    return [Ucharerr, 1] if c2 < Utagx || Utag2 <= c2\n\n    # 3-byte, 16-bit sequence?\n    if c0 < Utag4\n      u = (c0&Umask3)<<12 | (c1&Umaskx)<<6 | (c2&Umaskx)\n      return [Ucharerr, 1] if u <= Uchar2max\n      return [u, 3]\n    end\n\n    # need third continuation byte\n    return [Ucharerr, 1] if n < 4\n    c3 = s[i+3].ord\n    return [Ucharerr, 1] if c3 < Utagx || Utag2 <= c3\n\n    # 4-byte, 21-bit sequence?\n    if c0 < Utag5\n      u = (c0&Umask4)<<18 | (c1&Umaskx)<<12 | (c2&Umaskx)<<6 | (c3&Umaskx)\n      return [Ucharerr, 1] if u <= Uchar3max\n      return [u, 4]\n    end\n\n    return [Ucharerr, 1]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 6,
    "raw_source": "def tmp_dir\n    File.expand_path('../tmp', __dir__)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 12,
    "raw_source": "def app_file_path\n    File.join(tmp_dir, \"example_app_#{$example_app_counter}.rb\")\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 19,
    "raw_source": "def app_name\n    \"ExampleApp#{$example_app_counter}\"\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 25,
    "raw_source": "def app_const\n    Module.const_get(app_name)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 39,
    "raw_source": "def write_app_file(options={})\n    options[:routes] ||= ['get(\"/foo\") { erb :foo }']\n    options[:inline_templates] ||= nil\n    options[:extensions] ||= []\n    options[:middlewares] ||= []\n    options[:filters] ||= []\n    options[:errors] ||= {}\n    options[:name] ||= app_name\n    options[:enable_reloader] = true unless options[:enable_reloader] === false\n    options[:parent] ||= 'Sinatra::Base'\n\n    update_file(app_file_path) do |f|\n      template_path = File.expand_path('reloader/app.rb.erb', __dir__)\n      template = Tilt.new(template_path, nil, :trim => '<>')\n      f.write template.render(Object.new, options)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 61,
    "raw_source": "def update_file(path, &block)\n    original_mtime = File.exist?(path) ? File.mtime(path) : Time.at(0)\n    new_time = original_mtime + 1\n    File.open(path, 'w', &block)\n    File.utime(new_time, new_time, path)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 71,
    "raw_source": "def setup_example_app(options={})\n    $example_app_counter ||= 0\n    $example_app_counter += 1\n\n    FileUtils.mkdir_p(tmp_dir)\n    write_app_file(options)\n    $LOADED_FEATURES.delete app_file_path\n    require app_file_path\n    self.app = app_const\n    app_const.enable :reloader\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 261,
    "raw_source": "def self.registered(klass)\n          klass.get('/bar') { 'bar' }\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 282,
    "raw_source": "def self.registered(klass)\n          klass.use Rack::Head\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 303,
    "raw_source": "def self.registered(klass)\n          klass.before { @hi = 'hi' }\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/reloader_spec.rb",
    "start_line": 324,
    "raw_source": "def self.registered(klass)\n          klass.after { @bye = 'bye' }\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/respond_with_spec.rb",
    "start_line": 7,
    "raw_source": "def respond_app(&block)\n    mock_app do\n      set :app_file, __FILE__\n      set :views, root + '/respond_with'\n      register Sinatra::RespondWith\n      class_eval(&block)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/respond_with_spec.rb",
    "start_line": 16,
    "raw_source": "def respond_to(*args, &block)\n    respond_app { get('/') { respond_to(*args, &block) } }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/respond_with_spec.rb",
    "start_line": 20,
    "raw_source": "def respond_with(*args, &block)\n    respond_app { get('/') { respond_with(*args, &block) } }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/respond_with_spec.rb",
    "start_line": 24,
    "raw_source": "def req(*types)\n    path = types.shift if types.first.is_a?(String) && types.first.start_with?('/')\n    accept = types.map { |t| Sinatra::Base.mime_type(t).to_s }.join ','\n    get (path || '/'), {}, 'HTTP_ACCEPT' => accept\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/respond_with_spec.rb",
    "start_line": 221,
    "raw_source": "def object.to_pdf; \"hi\" end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 4,
    "raw_source": "def stream(&block)\n    rack_middleware = @use\n    out = nil\n    mock_app do\n      rack_middleware.each { |args| use(*args) }\n      helpers Sinatra::Streaming\n      get('/') { out = stream(&block) }\n    end\n    get('/')\n    out\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 16,
    "raw_source": "def use(*args)\n    @use << args\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 147,
    "raw_source": "def initialize(app) @app = app end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 148,
    "raw_source": "def call(env)\n          status, headers, body = @app.call(env)\n          body.map! { |s| s.upcase }\n          [status, headers, body]\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 172,
    "raw_source": "def initialize(app) @app = app end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 173,
    "raw_source": "def call(env)\n          status, headers, body = @app.call(env)\n          [status, headers, body.map(&:upcase)]\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 186,
    "raw_source": "def initialize(app) @app = app end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 187,
    "raw_source": "def call(env)\n          status, headers, body = @app.call(env)\n          [status, headers, body.map(&:upcase).map(&:reverse)]\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 200,
    "raw_source": "def initialize(app) @app = app end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/sinatra-contrib/spec/streaming_spec.rb",
    "start_line": 201,
    "raw_source": "def call(env)\n          status, headers, body = @app.call(env)\n          [status, headers, body.each.map(&:upcase)]\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/asciidoctor_test.rb",
    "start_line": 7,
    "raw_source": "def asciidoc_app(&block)\n      mock_app do\n        set :views, __dir__ + '/views'\n        get('/', &block)\n      end\n      get '/'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/base_test.rb",
    "start_line": 10,
    "raw_source": "def initialize(argument:)\n        @argument = argument\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/base_test.rb",
    "start_line": 109,
    "raw_source": "def route_missing\n        env['sinatra.route-missing'] = '1'\n        super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/builder_test.rb",
    "start_line": 7,
    "raw_source": "def builder_app(options = {}, &block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      set options\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/compile_test.rb",
    "start_line": 4,
    "raw_source": "def self.parses pattern, example, expected_params, mtype = :sinatra, mopts = {}\n    it \"parses #{example} with #{pattern} into params #{expected_params}\" do\n      compiled = mock_app { set :mustermann_opts, :type => mtype }.send(:compile, pattern, mopts)\n      params = compiled.params(example)\n      fail %Q{\"#{example}\" does not parse on pattern \"#{pattern}\".} unless params\n\n      assert_equal expected_params, params, \"Pattern #{pattern} does not match path #{example}.\"\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/compile_test.rb",
    "start_line": 14,
    "raw_source": "def self.fails pattern, example, mtype = :sinatra, mopts = {}\n    it \"does not parse #{example} with #{pattern}\" do\n      compiled = mock_app { set :mustermann_opts, :type => mtype }.send(:compile, pattern, mopts)\n      match = compiled.match(example)\n      fail %Q{\"#{pattern}\" does parse \"#{example}\" but it should fail} if match\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/compile_test.rb",
    "start_line": 22,
    "raw_source": "def self.raises pattern, mtype = :sinatra, mopts = {}\n    it \"does not compile #{pattern}\" do\n      assert_raises(Mustermann::CompileError, %Q{Pattern \"#{pattern}\" compiles but it should not}) do\n        mock_app { set :mustermann_opts, :type => mtype }.send(:compile, pattern, mopts)\n      end\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 29,
    "raw_source": "def self.setup(&block)     setup_blocks    << block  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 30,
    "raw_source": "def self.teardown(&block)  teardown_blocks << block  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 31,
    "raw_source": "def self.setup_blocks()    @setup_blocks    ||= []   end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 32,
    "raw_source": "def self.teardown_blocks() @teardown_blocks ||= []   end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 34,
    "raw_source": "def setup_blocks(base = self.class)\n    setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks\n    base.setup_blocks.each do |block|\n      instance_eval(&block)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 41,
    "raw_source": "def teardown_blocks(base = self.class)\n    teardown_blocks base.superclass if base.superclass.respond_to? :teardown_blocks\n    base.teardown_blocks.each do |block|\n      instance_eval(&block)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 51,
    "raw_source": "def self.context(*name, &block)\n    subclass = Class.new(self)\n    remove_tests(subclass)\n    subclass.class_eval(&block) if block_given?\n    const_set(context_name(name.join(\" \")), subclass)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 58,
    "raw_source": "def self.test(name, &block)\n    define_method(test_name(name), &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 69,
    "raw_source": "def self.context_name(name)\n    # \"Test#{sanitize_name(name).gsub(/(^| )(\\w)/) { $2.upcase }}\".to_sym\n    name = \"Test#{sanitize_name(name).gsub(/(^| )(\\w)/) { $2.upcase }}\"\n    name.tr(\" \", \"_\").to_sym\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 75,
    "raw_source": "def self.test_name(name)\n    name = \"test_#{sanitize_name(name).gsub(/\\s+/,'_')}_0\"\n    name = name.succ while method_defined? name\n    name.to_sym\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 81,
    "raw_source": "def self.sanitize_name(name)\n    # name.gsub(/\\W+/, ' ').strip\n    name.gsub(/\\W+/, ' ')\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/contest.rb",
    "start_line": 86,
    "raw_source": "def self.remove_tests(subclass)\n    subclass.public_instance_methods.grep(/^test_/).each do |meth|\n      subclass.send(:undef_method, meth.to_sym)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 6,
    "raw_source": "def method_missing(*a, &b)\n      @last_call = [*a.map(&:to_s)]\n      @last_call << b if b\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 12,
    "raw_source": "def self.delegates(name)\n    it \"delegates #{name}\" do\n      m = mirror { send name }\n      assert_equal [name.to_s], m.last_call\n    end\n\n    it \"delegates #{name} with arguments\" do\n      m = mirror { send name, \"foo\", \"bar\" }\n      assert_equal [name.to_s, \"foo\", \"bar\"], m.last_call\n    end\n\n    it \"delegates #{name} with block\" do\n      block = proc { }\n      m = mirror { send(name, &block) }\n      assert_equal [name.to_s, block], m.last_call\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 34,
    "raw_source": "def teardown\n    Sinatra::Delegator.target = @target_was\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 38,
    "raw_source": "def delegation_app(&block)\n    mock_app { Sinatra::Delegator.target = self }\n    delegate(&block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 43,
    "raw_source": "def mirror(&block)\n    mirror = Mirror.new\n    Sinatra::Delegator.target = mirror\n    delegate(&block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 49,
    "raw_source": "def delegate(&block)\n    assert Sinatra::Delegator.target != Sinatra::Application\n    Object.new.extend(Sinatra::Delegator).instance_eval(&block) if block\n    Sinatra::Delegator.target\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 55,
    "raw_source": "def target\n    Sinatra::Delegator.target\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 122,
    "raw_source": "def respond_to?(method, *)\n        method.to_sym == :options or super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/delegator_test.rb",
    "start_line": 126,
    "raw_source": "def method_missing(method, *args, &block)\n        return super unless method.to_sym == :options\n        {:some => :option}\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/erb_test.rb",
    "start_line": 4,
    "raw_source": "def engine\n    Tilt::ERBTemplate\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/erb_test.rb",
    "start_line": 8,
    "raw_source": "def setup\n    Tilt.prefer engine, :erb\n    super\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/erb_test.rb",
    "start_line": 13,
    "raw_source": "def erb_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/erb_test.rb",
    "start_line": 64,
    "raw_source": "def container\n        @_out_buf << \"THIS.\"\n        yield\n        @_out_buf << \"SPARTA!\"\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/erb_test.rb",
    "start_line": 69,
    "raw_source": "def is; \"IS.\" end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/erb_test.rb",
    "start_line": 111,
    "raw_source": "def engine; Tilt::ErubiTemplate end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 5,
    "raw_source": "def foo\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 9,
    "raw_source": "def im_hiding_in_ur_foos\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 14,
    "raw_source": "def bar\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 19,
    "raw_source": "def baz\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 24,
    "raw_source": "def quux\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 29,
    "raw_source": "def foo=(name); end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 30,
    "raw_source": "def bar?(name); end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 31,
    "raw_source": "def fizz!(name); end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 45,
    "raw_source": "Sinatra::Base.register { def im_in_ur_anonymous_module; end }"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 79,
    "raw_source": "def bizzle\n      bizzle_option\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/extensions_test.rb",
    "start_line": 83,
    "raw_source": "def self.registered(base)\n      fail \"base should be BizzleApp\" unless base == BizzleApp\n      fail \"base should have already extended BizzleExtension\" unless base.respond_to?(:bizzle)\n      base.set :bizzle_option, 'bizzle!'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/haml_test.rb",
    "start_line": 7,
    "raw_source": "def haml_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 6,
    "raw_source": "def test_default\n    assert true\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 10,
    "raw_source": "def status_app(code, &block)\n    code += 2 if [204, 304].include? code\n    block ||= proc { }\n    mock_app do\n      get('/') do\n        status code\n        instance_eval(&block).inspect\n      end\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 761,
    "raw_source": "def attachment_app(filename=nil)\n      mock_app do\n        get('/attachment') do\n          attachment filename\n          response.write(\"<sinatra></sinatra>\")\n        end\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 818,
    "raw_source": "def teardown\n      File.unlink @file\n      @file = nil\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 823,
    "raw_source": "def send_file_app(opts={})\n      path = @file\n      mock_app {\n        get '/file.txt' do\n          send_file path, opts\n        end\n      }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 1012,
    "raw_source": "def obj.method_missing(*a, &b) 60.send(*a, &b) end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 1013,
    "raw_source": "def obj.is_a?(thing) 60.is_a?(thing) end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 1944,
    "raw_source": "module ::HelperOne; def one; '1'; end; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 1945,
    "raw_source": "module ::HelperTwo; def two; '2'; end; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 1967,
    "raw_source": "def foo\n            'foo'\n          end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 1998,
    "raw_source": "def one; nil end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 1999,
    "raw_source": "def two; nil end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 2003,
    "raw_source": "def two; '2' end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 2018,
    "raw_source": "def my_test\n        'BaseHelper#test'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 2031,
    "raw_source": "def my_test\n          'InlineHelper#test'\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 2045,
    "raw_source": "def self.included(base)\n        base.extend(ClassMethods)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/helpers_test.rb",
    "start_line": 2050,
    "raw_source": "def nickname(name)\n          # do something.\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 10,
    "raw_source": "def test_flattened_constructor\n    hash = Sinatra::IndifferentHash[:a, 1, ?b, 2]\n    assert_equal 1, hash[?a]\n    assert_equal 2, hash[?b]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 16,
    "raw_source": "def test_pairs_constructor\n    hash = Sinatra::IndifferentHash[[[:a, 1], [?b, 2]]]\n    assert_equal 1, hash[?a]\n    assert_equal 2, hash[?b]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 22,
    "raw_source": "def test_default_block\n    hash = Sinatra::IndifferentHash.new { |h, k| h[k] = k.upcase }\n    assert_nil hash.default\n    assert_equal ?A, hash.default(:a)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 28,
    "raw_source": "def test_default_object\n    hash = Sinatra::IndifferentHash.new({:a=>1, ?b=>2})\n    assert_equal({ :a=>1, ?b=>2 }, hash.default)\n    assert_equal({ :a=>1, ?b=>2 }, hash[:a])\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 34,
    "raw_source": "def test_default_assignment\n    hash = Sinatra::IndifferentHash.new\n    hash.default = { :a=>1, ?b=>2 }\n    assert_equal({ ?a=>1, ?b=>2 }, hash.default)\n    assert_equal({ ?a=>1, ?b=>2 }, hash[:a])\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 41,
    "raw_source": "def test_assignment\n    hash = Sinatra::IndifferentHash.new\n    hash[:a] = :a\n    hash[?b] = :b\n    hash[3] = 3\n    hash[:simple_nested] = { :a=>:a, ?b=>:b }\n\n    assert_equal :a, hash[?a]\n    assert_equal :b, hash[?b]\n    assert_equal 3, hash[3]\n    assert_equal({ ?a=>:a, ?b=>:b }, hash['simple_nested'])\n    assert_nil hash[?d]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 55,
    "raw_source": "def test_merge!\n    # merge! is already mostly tested by the different constructors, so we\n    # really just need to test the block form here\n    hash = Sinatra::IndifferentHash[:a=>'a', ?b=>'b', 3=>3]\n    hash.merge!(?a=>'A', :b=>'B', :d=>'D') do |key, oldval, newval|\n      \"#{oldval}*#{key}*#{newval}\"\n    end\n\n    assert_equal({ ?a=>'a*a*A', ?b=>'b*b*B', 3=>3, ?d=>'D' }, hash)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 68,
    "raw_source": "def setup\n    @hash = Sinatra::IndifferentHash[:a=>:a, ?b=>:b, 3=>3,\n      :simple_nested=>{ :a=>:a, ?b=>:b },\n      :nested=>{ :a=>[{ :a=>:a, ?b=>:b }, :c, 4], ?f=>:f, 7=>7 }\n    ]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 75,
    "raw_source": "def test_hash_constructor\n    assert_equal :a, @hash[?a]\n    assert_equal :b, @hash[?b]\n    assert_equal 3, @hash[3]\n    assert_equal({ ?a=>:a, ?b=>:b }, @hash['nested'][?a][0])\n    assert_equal :c, @hash['nested'][?a][1]\n    assert_equal 4, @hash['nested'][?a][2]\n    assert_equal :f, @hash['nested'][?f]\n    assert_equal 7, @hash['nested'][7]\n    assert_equal :a, @hash['simple_nested'][?a]\n    assert_equal :b, @hash['simple_nested'][?b]\n    assert_nil @hash[?d]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 89,
    "raw_source": "def test_assoc\n    assert_nil @hash.assoc(:d)\n    assert_equal [?a, :a], @hash.assoc(:a)\n    assert_equal [?b, :b], @hash.assoc(:b)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 95,
    "raw_source": "def test_rassoc\n    assert_nil @hash.rassoc(:d)\n    assert_equal [?a, :a], @hash.rassoc(:a)\n    assert_equal [?b, :b], @hash.rassoc(:b)\n    assert_equal ['simple_nested', { ?a=>:a, ?b=>:b }], @hash.rassoc(:a=>:a, ?b=>:b)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 102,
    "raw_source": "def test_fetch\n    assert_raises(KeyError) { @hash.fetch(:d) }\n    assert_equal 1, @hash.fetch(:d, 1)\n    assert_equal 2, @hash.fetch(:d) { 2 }\n    assert_equal ?d, @hash.fetch(:d) { |k| k }\n    assert_equal :a, @hash.fetch(:a, 1)\n    assert_equal :a, @hash.fetch(:a) { 2 }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 111,
    "raw_source": "def test_symbolic_retrieval\n    assert_equal :a, @hash[:a]\n    assert_equal :b, @hash[:b]\n    assert_equal({ ?a=>:a, ?b=>:b }, @hash[:nested][:a][0])\n    assert_equal :c, @hash[:nested][:a][1]\n    assert_equal 4, @hash[:nested][:a][2]\n    assert_equal :f, @hash[:nested][:f]\n    assert_equal 7, @hash[:nested][7]\n    assert_equal :a, @hash[:simple_nested][:a]\n    assert_equal :b, @hash[:simple_nested][:b]\n    assert_nil @hash[:d]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 124,
    "raw_source": "def test_key\n    assert_nil @hash.key(:d)\n    assert_equal ?a, @hash.key(:a)\n    assert_equal 'simple_nested', @hash.key(:a=>:a, ?b=>:b)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 130,
    "raw_source": "def test_key?\n    assert_operator @hash, :key?, :a\n    assert_operator @hash, :key?, ?b\n    assert_operator @hash, :key?, 3\n    refute_operator @hash, :key?, :d\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 137,
    "raw_source": "def test_value?\n    assert_operator @hash, :value?, :a\n    assert_operator @hash, :value?, :b\n    assert_operator @hash, :value?, 3\n    assert_operator @hash, :value?, { :a=>:a, ?b=>:b }\n    refute_operator @hash, :value?, :d\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 145,
    "raw_source": "def test_delete\n    @hash.delete(:a)\n    @hash.delete(?b)\n    assert_nil @hash[:a]\n    assert_nil @hash[?b]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 152,
    "raw_source": "def test_dig\n    assert_equal :a, @hash.dig(:a)\n    assert_equal :b, @hash.dig(?b)\n    assert_nil @hash.dig(:d)\n\n    assert_equal :a, @hash.dig(:simple_nested, :a)\n    assert_equal :b, @hash.dig('simple_nested', ?b)\n    assert_nil @hash.dig('simple_nested', :d)\n\n    assert_equal :a, @hash.dig(:nested, :a, 0, :a)\n    assert_equal :b, @hash.dig('nested', ?a, 0, ?b)\n    assert_nil @hash.dig('nested', ?a, 0, :d)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 166,
    "raw_source": "def test_slice\n    assert_equal Sinatra::IndifferentHash[a: :a], @hash.slice(:a)\n    assert_equal Sinatra::IndifferentHash[b: :b], @hash.slice(?b)\n    assert_equal Sinatra::IndifferentHash[3 => 3], @hash.slice(3)\n    assert_equal Sinatra::IndifferentHash.new, @hash.slice(:d)\n    assert_equal Sinatra::IndifferentHash[a: :a, b: :b, 3 => 3], @hash.slice(:a, :b, 3)\n    assert_equal Sinatra::IndifferentHash[simple_nested: { a: :a, ?b => :b }], @hash.slice(:simple_nested)\n    assert_equal Sinatra::IndifferentHash[nested: { a: [{ a: :a, ?b => :b }, :c, 4], ?f => :f, 7 => 7 }], @hash.slice(:nested)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 176,
    "raw_source": "def test_fetch_values\n    assert_raises(KeyError) { @hash.fetch_values(3, :d) }\n    assert_equal [:a, :b, 3, ?D], @hash.fetch_values(:a, ?b, 3, :d) { |k| k.upcase }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 181,
    "raw_source": "def test_values_at\n    assert_equal [:a, :b, 3, nil], @hash.values_at(:a, ?b, 3, :d)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 185,
    "raw_source": "def test_merge\n    # merge just calls merge!, which is already thoroughly tested\n    hash2 = @hash.merge(?a=>1, :q=>2) { |key, oldval, newval| \"#{oldval}*#{key}*#{newval}\" }\n\n    refute_equal @hash, hash2\n    assert_equal 'a*a*1', hash2[:a]\n    assert_equal 2, hash2[?q]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 194,
    "raw_source": "def test_merge_with_multiple_argument\n    hash = Sinatra::IndifferentHash.new.merge({a: 1}, {b: 2}, {c: 3})\n    assert_equal 1, hash[?a]\n    assert_equal 2, hash[?b]\n    assert_equal 3, hash[?c]\n\n    hash2 = Sinatra::IndifferentHash[d: 4]\n    hash3 = {e: 5}\n    hash.merge!(hash2, hash3)\n\n    assert_equal 4, hash[?d]\n    assert_equal 5, hash[?e]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 208,
    "raw_source": "def test_replace\n    @hash.replace(?a=>1, :q=>2)\n    assert_equal({ ?a=>1, ?q=>2 }, @hash)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 213,
    "raw_source": "def test_transform_values!\n    @hash.transform_values! { |v| v.is_a?(Hash) ? Hash[v.to_a] : v }\n\n    assert_instance_of Sinatra::IndifferentHash, @hash[:simple_nested]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 219,
    "raw_source": "def test_transform_values\n    hash2 = @hash.transform_values { |v| v.respond_to?(:upcase) ? v.upcase : v }\n\n    refute_equal @hash, hash2\n    assert_equal :A, hash2[:a]\n    assert_equal :A, hash2[?a]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 227,
    "raw_source": "def test_transform_keys!\n    @hash.transform_keys! { |k| k.respond_to?(:to_sym) ? k.to_sym : k }\n\n    assert_equal :a, @hash[:a]\n    assert_equal :a, @hash[?a]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 234,
    "raw_source": "def test_transform_keys\n    hash2 = @hash.transform_keys { |k| k.respond_to?(:upcase) ? k.upcase : k }\n\n    refute_equal @hash, hash2\n    refute_operator hash2, :key?, :a\n    refute_operator hash2, :key?, ?a\n    assert_equal :a, hash2[:A]\n    assert_equal :a, hash2[?A]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 244,
    "raw_source": "def test_select\n    hash = @hash.select { |k, v| v == :a }\n    assert_equal Sinatra::IndifferentHash[a: :a], hash\n    assert_instance_of Sinatra::IndifferentHash, hash\n\n    hash2 = @hash.select { |k, v| true }\n    assert_equal @hash, hash2\n    assert_instance_of Sinatra::IndifferentHash, hash2\n\n    enum = @hash.select\n    assert_instance_of Enumerator, enum\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 257,
    "raw_source": "def test_select!\n    @hash.select! { |k, v| v == :a }\n    assert_equal Sinatra::IndifferentHash[a: :a], @hash\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 262,
    "raw_source": "def test_reject\n    hash = @hash.reject { |k, v| v != :a }\n    assert_equal Sinatra::IndifferentHash[a: :a], hash\n    assert_instance_of Sinatra::IndifferentHash, hash\n\n    hash2 = @hash.reject { |k, v| false }\n    assert_equal @hash, hash2\n    assert_instance_of Sinatra::IndifferentHash, hash2\n\n    enum = @hash.reject\n    assert_instance_of Enumerator, enum\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 275,
    "raw_source": "def test_reject!\n    @hash.reject! { |k, v| v != :a }\n    assert_equal Sinatra::IndifferentHash[a: :a], @hash\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 280,
    "raw_source": "def test_compact\n    hash_with_nil_values = @hash.merge({?z => nil})\n    compacted_hash = hash_with_nil_values.compact\n    assert_equal @hash, compacted_hash\n    assert_instance_of Sinatra::IndifferentHash, compacted_hash\n\n    empty_hash = Sinatra::IndifferentHash.new\n    compacted_hash = empty_hash.compact\n    assert_equal empty_hash, compacted_hash\n\n    non_empty_hash = Sinatra::IndifferentHash[a: :a]\n    compacted_hash = non_empty_hash.compact\n    assert_equal non_empty_hash, compacted_hash\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/indifferent_hash_test.rb",
    "start_line": 295,
    "raw_source": "def test_except\n    hash = @hash.except(?b, 3, :simple_nested, 'nested')\n    assert_equal Sinatra::IndifferentHash[a: :a], hash\n    assert_instance_of Sinatra::IndifferentHash, hash\n  end if Gem::Version.new(RUBY_VERSION) >= Gem::Version.new(\"3.0\")"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_async_helper.rb",
    "start_line": 6,
    "raw_source": "def it(message, &block)\n    Server.all_async.each do |server|\n      next unless server.installed?\n      super(\"with #{server.name}: #{message}\") { server.run_test(self, &block) }\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_async_helper.rb",
    "start_line": 13,
    "raw_source": "def self.extend_object(obj)\n    super\n\n    base_port = 5100 + Process.pid % 100\n    servers = %w(puma)\n\n    servers.each_with_index do |server, index|\n      Server.run(server, base_port+index, async: true)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 12,
    "raw_source": "def self.all\n      @all ||= []\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 16,
    "raw_source": "def self.all_async\n      @all_async ||= []\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 20,
    "raw_source": "def self.each(&block)\n      all.each(&block)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 24,
    "raw_source": "def self.run(server, port, async: false)\n      new(server, port, async).run\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 28,
    "raw_source": "def app_file\n      File.expand_path('integration/app.rb', __dir__)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 32,
    "raw_source": "def environment\n      \"development\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 36,
    "raw_source": "def initialize(server, port, async)\n      @installed, @pipe, @server, @port = nil, nil, server, port\n      ENV['PUMA_MIN_THREADS'] = '1' if server == 'puma'\n      if async\n        Server.all_async << self\n      else\n        Server.all << self\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 46,
    "raw_source": "def run\n      return unless installed?\n      kill\n      @log     = +\"\"\n      super\n      at_exit { kill }\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 54,
    "raw_source": "def installed?\n      return @installed unless @installed.nil?\n      s = server == 'HTTP' ? 'net/http/server' : server\n      require s\n      @installed = true\n    rescue LoadError\n      warn \"#{server} is not installed, skipping integration tests\"\n      @installed = false\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 64,
    "raw_source": "def command\n      @command ||= begin\n        cmd = [\"APP_ENV=#{environment}\", \"exec\"]\n        if RbConfig.respond_to? :ruby\n          cmd << RbConfig.ruby.inspect\n        else\n          file, dir = RbConfig::CONFIG.values_at('ruby_install_name', 'bindir')\n          cmd << File.expand_path(file, dir).inspect\n        end\n        cmd << \"-w\" unless net_http_server?\n        cmd << \"-I\" << File.expand_path('../lib', __dir__).inspect\n        cmd << app_file.inspect << '-s' << server << '-o' << '127.0.0.1' << '-p' << port\n        cmd << \"-e\" << environment.to_s << '2>&1'\n        cmd.join \" \"\n      end\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 81,
    "raw_source": "def webrick?\n      name.to_s == \"webrick\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 85,
    "raw_source": "def puma?\n      name.to_s == \"puma\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 89,
    "raw_source": "def falcon?\n      name.to_s == \"falcon\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 93,
    "raw_source": "def trinidad?\n      name.to_s == \"trinidad\"\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 97,
    "raw_source": "def net_http_server?\n      name.to_s == 'HTTP'\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 101,
    "raw_source": "def warnings\n      log.scan(%r[(?:\\(eval|lib/sinatra).*warning:.*$])\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 105,
    "raw_source": "def run_test(target, &block)\n      retries ||= 3\n      target.server = self\n      run unless alive?\n      target.instance_eval(&block)\n    rescue Exception => error\n      retries -= 1\n      kill\n      retries < 0 ? retry : raise(error)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 119,
    "raw_source": "def it(message, &block)\n    Server.each do |server|\n      next unless server.installed?\n      super(\"with #{server.name}: #{message}\") { server.run_test(self, &block) }\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_helper.rb",
    "start_line": 126,
    "raw_source": "def self.extend_object(obj)\n    super\n\n    base_port = 5000 + Process.pid % 100\n    servers = Sinatra::Base.server.dup\n\n    # TruffleRuby doesn't support `Fiber.set_scheduler` yet\n    unsupported_truffleruby = RUBY_ENGINE == \"truffleruby\" && !Fiber.respond_to?(:set_scheduler)\n    # Ruby 2.7 uses falcon 0.42.3 which isn't working with rackup 2.2.0+\n    too_old_ruby = RUBY_VERSION <= \"3.0.0\"\n\n    if unsupported_truffleruby || too_old_ruby\n      warn \"skip falcon server\"\n      servers.delete('falcon')\n    end\n\n    servers.each_with_index do |server, index|\n      Server.run(server, base_port+index)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_helper.rb",
    "start_line": 6,
    "raw_source": "def command_for(app_file)\n    [\n      \"ruby\",\n      app_file,\n      \"-p\",\n      \"0\", # any free port\n      \"-s\",\n      \"puma\",\n    ]\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_helper.rb",
    "start_line": 17,
    "raw_source": "def with_process(command:, env: {}, debug: false)\n    process = ChildProcess.build(*command)\n    process.leader = true # ensure entire process tree dies\n    process.environment.merge!(env)\n    read_io, write_io = IO.pipe\n    process.io.stdout = write_io\n    process.io.stderr = write_io\n    process.start\n    # Close parent's copy of the write end of the pipe so when the (forked) child\n    # process closes its write end of the pipe the parent receives EOF when\n    # attempting to read from it. If the parent leaves its write end open, it\n    # will not detect EOF.\n    write_io.close\n\n    echo_output(read_io) if debug || debug_all?\n\n    yield process, read_io\n  ensure\n    read_io.close\n    process.stop\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_helper.rb",
    "start_line": 39,
    "raw_source": "def echo_output(read_io)\n    Thread.new do\n      begin\n        loop { print read_io.readpartial(8192) }\n      rescue EOFError\n      end\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_helper.rb",
    "start_line": 48,
    "raw_source": "def debug_all?\n    ENV.key?(\"DEBUG_START_PROCESS\")\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_helper.rb",
    "start_line": 52,
    "raw_source": "def wait_timeout\n    case RUBY_ENGINE\n    when \"jruby\", \"truffleruby\"\n      # takes some time to start the JVM\n      10.0\n    else\n      3.0\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_helper.rb",
    "start_line": 62,
    "raw_source": "def wait_for_output(read_io, matcher, timeout = wait_timeout)\n    return true if read_io.expect(matcher, timeout).to_a.any?\n\n    raise \"Waited for #{timeout} seconds, but received no output matching: \" \\\n          \"#{matcher.source}\"\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_test.rb",
    "start_line": 6,
    "raw_source": "def test_app_start_without_rackup\n    # Why we skip head versions: The Gemfile used here would have to support\n    # the ENVs and we would need to bundle before starting the app\n    #\n    # Example from locally playing with this:\n    #\n    #   root@df8b1e7cb106:/app# rack_session=head BUNDLE_GEMFILE=./test/integration/gemfile_without_rackup.rb ruby ./test/integration/simple_app.rb -p 0 -s puma\n    #   The git source https://github.com/rack/rack-session.git is not yet checked out. Please run `bundle install` before trying to start your application\n    #\n    # Using bundler/inline is an idea, but it would add to the startup time\n    skip \"So much work to run with rack head branch\" if ENV['rack'] == 'head'\n    skip \"So much work to run with rack-session head branch\" if ENV['rack_session'] == 'head'\n\n    app_file = File.join(__dir__, \"integration\", \"simple_app.rb\")\n    gem_file = File.join(__dir__, \"integration\", \"gemfile_without_rackup.rb\")\n    command = command_for(app_file)\n    env = { \"BUNDLE_GEMFILE\" => gem_file }\n\n    with_process(command: command, env: env) do |process, read_io|\n      assert wait_for_output(read_io, /Sinatra could not start, the required gems weren't found/)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_test.rb",
    "start_line": 29,
    "raw_source": "def test_classic_app_start\n    app_file = File.join(__dir__, \"integration\", \"simple_app.rb\")\n    command = command_for(app_file)\n    with_process(command: command) do |process, read_io|\n      assert wait_for_output(read_io, /Sinatra \\(v.+\\) has taken the stage/)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/integration_start_test.rb",
    "start_line": 37,
    "raw_source": "def test_classic_app_with_zeitwerk\n    app_file = File.join(__dir__, \"integration\", \"zeitwerk_app.rb\")\n    command = command_for(app_file)\n    with_process(command: command) do |process, read_io|\n      assert wait_for_output(read_io, /Sinatra \\(v.+\\) has taken the stage/)\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/liquid_test.rb",
    "start_line": 7,
    "raw_source": "def liquid_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/mapped_error_test.rb",
    "start_line": 10,
    "raw_source": "def http_status; 501 end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/mapped_error_test.rb",
    "start_line": 14,
    "raw_source": "def code; 4000 end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/mapped_error_test.rb",
    "start_line": 18,
    "raw_source": "def code; 419 end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/mapped_error_test.rb",
    "start_line": 25,
    "raw_source": "def test_default\n    assert true\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/markaby_test.rb",
    "start_line": 7,
    "raw_source": "def markaby_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/markdown_test.rb",
    "start_line": 4,
    "raw_source": "def markdown_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/markdown_test.rb",
    "start_line": 12,
    "raw_source": "def setup\n    Tilt.prefer engine, 'markdown', 'mkd', 'md'\n    super\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/middleware_test.rb",
    "start_line": 16,
    "raw_source": "def call(env)\n      (env['test.ran'] ||= []) << self.class.to_s\n      app.call(env)\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/middleware_test.rb",
    "start_line": 23,
    "raw_source": "def call(env)\n      env['PATH_INFO'] = env['PATH_INFO'].upcase\n      super\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/middleware_test.rb",
    "start_line": 37,
    "raw_source": "def call(env)\n      env['PATH_INFO'] = env['PATH_INFO'].downcase\n      super\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/middleware_test.rb",
    "start_line": 70,
    "raw_source": "def call(env)\n      req = Rack::Request.new(env)\n      req.update_param('bar', 'baz'.freeze)\n      super\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/middleware_test.rb",
    "start_line": 83,
    "raw_source": "def call(env)\n      req = Rack::Request.new(env)\n      req.update_param('s', :s)\n      req.update_param('i', 1)\n      req.update_param('c', 3.to_c)\n      req.update_param('t', true)\n      req.update_param('f', false)\n      req.update_param('n', nil)\n      super\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/middleware_test.rb",
    "start_line": 101,
    "raw_source": "def initialize(app, **)\n      super app\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/nokogiri_test.rb",
    "start_line": 7,
    "raw_source": "def nokogiri_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/rabl_test.rb",
    "start_line": 11,
    "raw_source": "def rabl_app(&block)\n    mock_app {\n      set :views, __dir__ + '/views'\n      get '/', &block\n    }\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/rack_test.rb",
    "start_line": 10,
    "raw_source": "def build(*middleware)\n    endpoint = middleware.pop\n    @app = Rack::Builder.app do\n      middleware.each { |m| use m }\n      run endpoint\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/rack_test.rb",
    "start_line": 18,
    "raw_source": "def check(*middleware)\n    build(*middleware)\n    assert get('/foo').ok?\n    assert_body 'foo'\n    assert get('/bar').ok?\n    assert_body 'bar'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/rdoc_test.rb",
    "start_line": 8,
    "raw_source": "def rdoc_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/response_test.rb",
    "start_line": 6,
    "raw_source": "def assert_same_body(a, b)\n    assert_equal a.to_enum(:each).to_a, b.to_enum(:each).to_a\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/response_test.rb",
    "start_line": 58,
    "raw_source": "def object.inject(*) fail 'called' end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/response_test.rb",
    "start_line": 59,
    "raw_source": "def object.to_ary(*) fail 'called' end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/response_test.rb",
    "start_line": 60,
    "raw_source": "def object.each(*) end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/result_test.rb",
    "start_line": 4,
    "raw_source": "def http_status; 400 end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/result_test.rb",
    "start_line": 28,
    "raw_source": "def res.each ; yield call ; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/route_added_hook_test.rb",
    "start_line": 5,
    "raw_source": "def self.routes ; @routes ; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/route_added_hook_test.rb",
    "start_line": 6,
    "raw_source": "def self.procs ; @procs ; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/route_added_hook_test.rb",
    "start_line": 7,
    "raw_source": "def self.route_added(verb, path, proc)\n    @routes << [verb, path]\n    @procs << proc\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/routing_test.rb",
    "start_line": 4,
    "raw_source": "def route_def(pattern)\n  mock_app { get(pattern) { } }\nend"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/routing_test.rb",
    "start_line": 9,
    "raw_source": "def to_pattern(*)\n    self\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/routing_test.rb",
    "start_line": 13,
    "raw_source": "def params(input)\n    { \"one\" => +\"this\", \"two\" => +\"is\", \"three\" => +\"a\", \"four\" => +\"test\" }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/routing_test.rb",
    "start_line": 1510,
    "raw_source": "def protect(*args)\n        condition {\n          unless authorize(params[\"user\"], params[\"password\"])\n            halt 403, \"go away\"\n          end\n        }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/routing_test.rb",
    "start_line": 1523,
    "raw_source": "def authorize(username, password)\n          username == \"foo\" && password == \"bar\"\n        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/sass_test.rb",
    "start_line": 7,
    "raw_source": "def sass_app(options = {}, &block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      set options\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/scss_test.rb",
    "start_line": 7,
    "raw_source": "def scss_app(options = {}, &block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      set options\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 8,
    "raw_source": "def self.assertions\n      @assertions ||= 0\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 12,
    "raw_source": "def self.assertions= assertions\n      @assertions = assertions\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 16,
    "raw_source": "def self.run(app, options={})\n      assert(app < Sinatra::Base)\n      assert_equal 9001, options[:Port]\n      assert_equal 'foo.local', options[:Host]\n      yield new\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 23,
    "raw_source": "def stop\n    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 40,
    "raw_source": "def teardown\n    $stderr = STDERR\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 50,
    "raw_source": "def self.start_hook; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 51,
    "raw_source": "def self.stop_hook; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 96,
    "raw_source": "def initialize(app)\n        @@initialized = true\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 99,
    "raw_source": "def self.initialized\n        @@initialized\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/server_test.rb",
    "start_line": 102,
    "raw_source": "def call(env)\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/settings_test.rb",
    "start_line": 106,
    "raw_source": "def foo\n        @foo\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/settings_test.rb",
    "start_line": 109,
    "raw_source": "def foo=(value)\n        @foo = 'oops'\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/settings_test.rb",
    "start_line": 458,
    "raw_source": "def priv; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/settings_test.rb",
    "start_line": 460,
    "raw_source": "def pub; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/settings_test.rb",
    "start_line": 580,
    "raw_source": "def self.track\n        Rack.send :remove_const, :Builder\n        Rack.const_set :Builder, MiddlewareTracker\n        MiddlewareTracker.used.clear\n        yield\n      ensure\n        Rack.send :remove_const, :Builder\n        Rack.const_set :Builder, MiddlewareTracker.superclass\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/settings_test.rb",
    "start_line": 590,
    "raw_source": "def self.used\n        @used ||= []\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/settings_test.rb",
    "start_line": 594,
    "raw_source": "def use(middleware, *)\n        MiddlewareTracker.used << middleware\n        super\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/slim_test.rb",
    "start_line": 7,
    "raw_source": "def slim_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/static_test.rb",
    "start_line": 106,
    "raw_source": "def assert_valid_range(http_range, range, path, file)\n    request = Rack::MockRequest.new(@app)\n    response = request.get(\"/#{File.basename(path)}\", 'HTTP_RANGE' => http_range)\n\n    should_be = file[range]\n    expected_range = \"bytes #{range.begin}-#{range.end}/#{file.length}\"\n\n    assert_equal(\n      206,response.status,\n      \"Should be HTTP/1.1 206 Partial content\"\n    )\n    assert_equal(\n      should_be.length,\n      response.body.length,\n      \"Unexpected response length for #{http_range}\"\n    )\n    assert_equal(\n      should_be,\n      response.body,\n      \"Unexpected response data for #{http_range}\"\n    )\n    assert_equal(\n      should_be.length.to_s,\n      response['Content-Length'],\n      \"Incorrect Content-Length for #{http_range}\"\n    )\n    assert_equal(\n      expected_range,\n      response['Content-Range'],\n      \"Incorrect Content-Range for #{http_range}\"\n    )\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/streaming_test.rb",
    "start_line": 70,
    "raw_source": "def initialize(*)     @schedule, @defer = [], []                end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/streaming_test.rb",
    "start_line": 71,
    "raw_source": "def schedule(&block)  @schedule << block                        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/streaming_test.rb",
    "start_line": 72,
    "raw_source": "def defer(&block)     @defer    << block                        end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/streaming_test.rb",
    "start_line": 73,
    "raw_source": "def schedule!(*)      @schedule.pop.call until @schedule.empty? end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/streaming_test.rb",
    "start_line": 74,
    "raw_source": "def defer!(*)         @defer.pop.call    until @defer.empty?    end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/streaming_test.rb",
    "start_line": 131,
    "raw_source": "def close.callback; yield end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/streaming_test.rb",
    "start_line": 132,
    "raw_source": "def close.errback; end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/templates_test.rb",
    "start_line": 5,
    "raw_source": "def prepare\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/templates_test.rb",
    "start_line": 8,
    "raw_source": "def evaluate(scope, locals={}, &block)\n    inner = block ? block.call : ''\n    data + inner\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/templates_test.rb",
    "start_line": 17,
    "raw_source": "def render_app(base=Sinatra::Base, options = {}, &block)\n    base, options = Sinatra::Base, base if base.is_a? Hash\n    mock_app(base) do\n      set :views, __dir__ + '/views'\n      set options\n      get('/', &block)\n      template(:layout3) { \"Layout 3!\\n\" }\n    end\n    get '/'\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/templates_test.rb",
    "start_line": 28,
    "raw_source": "def with_default_layout\n    layout = __dir__ + '/views/layout.test'\n    File.open(layout, 'wb') { |io| io.write \"Layout!\\n\" }\n    yield\n  ensure\n    File.unlink(layout) rescue nil\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/templates_test.rb",
    "start_line": 363,
    "raw_source": "def some_scope.foo() 'World!' end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/templates_test.rb",
    "start_line": 376,
    "raw_source": "def find_template(views, name, engine, &block)\n        Array(views).each { |v| super(v, name, engine, &block) }\n      end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 40,
    "raw_source": "def assertions\n    @assertions ||= 0\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 48,
    "raw_source": "def include?(middleware)\n    @ins.any? { |m| middleware === m }\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 63,
    "raw_source": "def self.example(desc = nil, &block)\n    @example_count = 0 unless instance_variable_defined? :@example_count\n    @example_count += 1\n    it(desc || \"Example #{@example_count}\", &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 78,
    "raw_source": "def mock_app(base=Sinatra::Base, &block)\n    @app = Sinatra.new(base, &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 82,
    "raw_source": "def app\n    Rack::Lint.new(@app)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 86,
    "raw_source": "def body\n    response.body.to_s\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 90,
    "raw_source": "def assert_body(value)\n    if value.respond_to? :to_str\n      assert_equal value.lstrip.gsub(/\\s*\\n\\s*/, \"\"), body.lstrip.gsub(/\\s*\\n\\s*/, \"\")\n    else\n      assert_match value, body\n    end\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 98,
    "raw_source": "def assert_status(expected)\n    assert_equal Integer(expected), Integer(status)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 102,
    "raw_source": "def assert_like(a,b)\n    pattern = /id=['\"][^\"']*[\"']|\\s+/\n    assert_equal a.strip.gsub(pattern, \"\"), b.strip.gsub(pattern, \"\")\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 107,
    "raw_source": "def assert_include(str, substr)\n    assert str.include?(substr), \"expected #{str.inspect} to include #{substr.inspect}\"\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 111,
    "raw_source": "def options(uri, params = {}, env = {}, &block)\n    request(uri, env.merge(:method => \"OPTIONS\", :params => params), &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 115,
    "raw_source": "def patch(uri, params = {}, env = {}, &block)\n    request(uri, env.merge(:method => \"PATCH\", :params => params), &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 119,
    "raw_source": "def link(uri, params = {}, env = {}, &block)\n    request(uri, env.merge(:method => \"LINK\", :params => params), &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 123,
    "raw_source": "def unlink(uri, params = {}, env = {}, &block)\n    request(uri, env.merge(:method => \"UNLINK\", :params => params), &block)\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 128,
    "raw_source": "def method_missing(name, *args, &block)\n    if response && response.respond_to?(name)\n      response.send(name, *args, &block)\n    else\n      super\n    end\n  rescue Rack::Test::Error\n    super\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/test_helper.rb",
    "start_line": 139,
    "raw_source": "def silence_warnings\n    $VERBOSE, v = nil, $VERBOSE\n    yield\n  ensure\n    $VERBOSE = v\n  end"
  },
  {
    "repo_name": "sinatra",
    "file_path": "./repos/sinatra/test/yajl_test.rb",
    "start_line": 7,
    "raw_source": "def yajl_app(&block)\n    mock_app do\n      set :views, __dir__ + '/views'\n      get('/', &block)\n    end\n    get '/'\n  end"
  }
]